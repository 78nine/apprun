{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to AppRun Docs","text":"<p>Welcome to the AppRun user guide! This guide shows you how to get started creating web applications using AppRun.</p>"},{"location":"#what-is-apprun","title":"What is AppRun?","text":"<p>AppRun is a JavaScript library for building applications. But, you may ask, there are many successful Javascript frameworks and libraries like Angular, React, Vue, and Svelte already; why AppRun? AppRun provides elm-inspired architecture and embraces the event-driven programming pattern, making AppRun different from other frameworks and libraries.</p> <p>AppRun has the following benefits overall.</p> <ul> <li>Clean architecture that needs less code</li> <li>State management and routing included</li> <li>No proprietary syntax to learn (no hooks)</li> <li>Use directly in the browser or with a compiler/bundler</li> <li>Advanced features: JSX, Web Components, Dev Tools, SSR, etc.</li> </ul>"},{"location":"#is-apprun-for-me","title":"Is AppRun for me?","text":"<p>If you are a beginner developer, you will learn how to build web applications with outstanding architecture quickly. Also, what you learned in AppRun will help you to understand other frameworks and libraries.</p> <p>If you are an experienced developer, you will learn AppRun is a lightweight alternative to other frameworks and libraries. As a result, you will have one more good tool in your toolbox to meet your client's needs.</p> <p>Note</p> <p>Most of the code snippets in this guide are interactive you can edit and see the results.</p> <p>Ready to try it yourself?</p> <p>Head over to Getting Started or explore the AppRun Architecture.</p>"},{"location":"3rd-party-libs/","title":"3rd Party Libraries","text":"<p>Using jQuery and jQuery plugins is not an anti-pattern. On the contrary, it is welcomed and encouraged. AppRun embraces 3rd libraries and recommends you use them in your AppRun application development.</p> <p>AppRun was designed to support 3rd party libraries in mind. The AppRun VDOM is resilient to allow other libraries to change to DOM.</p> <p>You can embed a DOM element into JSX or use the JSX ref attribute.</p>"},{"location":"3rd-party-libs/#embed-element","title":"Embed Element","text":"<p>It is straightforward to create a DOM element and modify it using the 3rd party library. The DOM element can be embedded into JSX directly. e.g., the example of using chart.js below. The chart.js example above also demonstrates using the unload function to destroy the Chart object.</p> <pre><code>export default class extends Component {\nstate = {\ndata: {\n/* ... */\n}\n};\n\nview = state =&gt; {\nconst canvas = document.createElement('canvas');\nconst ctx = canvas.getContext('2d');\nstate.chart = new Chart(ctx, state.data);\nreturn (\n&lt;Card header=\"Chart JS\"&gt;\n{canvas}\n&lt;/Card&gt;\n);\n};\n\nunload = state =&gt; {\nstate.chart?.destroy();\nconsole.log('chart destroyed');\n}\n}\n</code></pre>"},{"location":"3rd-party-libs/#ref-attribute","title":"Ref Attribute","text":"<p>The JSX ref attribute is a callback function called when the specific DOM element is rendered. The DOM element can be any element in JSX. e.g., the d3 example below. The d3 example also demonstrates using the mounted function to initialize the state as a Promise.</p> <pre><code>const map = (element, features) =&gt; { /*...*/}\nexport default class extends Component {\nstate = {};\nview = features =&gt; (\n&lt;Card header={&lt;div id=\"map-text\"&gt;D3 Map&lt;/div&gt;}&gt;\n&lt;svg ref={el =&gt; map(el, features)}&gt;&lt;/svg&gt;\n&lt;/Card&gt;\n);\nmounted = () =&gt;\nnew Promise((resolve, reject) =&gt; {\nd3.json('./world-110m.json', (error, topo) =&gt; {\nif (error) throw reject(error);\nconst features = topojson.feature(topo, topo.objects.countries)\n.features;\nresolve(features);\n});\n});\n}\n</code></pre> <p>Combing component life cycle events and embedding DOM and the ref attribute provides a convenient way to use 3rd party libraries in the AppRun application. You can find out more from the following examples.</p>"},{"location":"3rd-party-libs/#bootstrap-admin-dashboard","title":"Bootstrap Admin Dashboard","text":"<p>The bootstrap admin dashboard uses the Bootstrap layout. It also uses jQuery DataTables and FullCalendar and chart.js and D3.</p> <p></p>"},{"location":"3rd-party-libs/#coreui-admin-template","title":"CoreUI Admin Template","text":"<p>Another example is using the CoreUI for AppRun application.</p> <p></p>"},{"location":"about/","title":"About","text":""},{"location":"about/#introduction","title":"Introduction","text":"<p>The recently updated AppRun Docs Site has made the code snippets in the documents runnable and editable, making the technical documentation interactive and much more fun to use.</p> <p>The site is built with Material for MkDocs, a beautiful and powerful tool for building technical documentation sites. We extended it by adding a web component built with AppRun to deliver interactive experiences.</p> <p>In this post, I Will explain how it's made. Let's start with reviewing the user experience.</p>"},{"location":"about/#user-experience","title":"User Experience","text":"<p>Technical documents usually have code snippets. Often the code has syntax highlighted for easy reading. However, users usually can only see screenshots but not live results of the code. Screenshots have limitations. For example, when describing how to make animation, a static screenshot is not helpful. We need a way to display the live code execution results.</p>"},{"location":"about/#see-the-results","title":"See the Results","text":"<p>You can visit the AppRun Docs Page to see a live animation.</p> <p></p>"},{"location":"about/#try-the-code","title":"Try the Code","text":"<p>Furthermore, users might have been inspired by the code examples and want to try different ideas. Traditionally, they could copy and paste the code to run it in their code editors. It would be nice for users to edit the code right on the doc site and see the results.</p> <p>You can click the \"Try the Code\" button of the AppRun Docs Page. It opens the AppRun Playground with an editor and preview pane to play the code.</p> <p></p> <p>The user experiences have improved with the capabilities of seeing the code results and trying the code in technical documents.</p>"},{"location":"about/#author-experience","title":"Author Experience","text":"<p>Not only is it much more attractive to the readers, but also the authors will feel it is much more enjoyable when writing the documents.</p>"},{"location":"about/#present-the-live-code","title":"Present the Live Code","text":"<p>Traditionally, authors copy and paste the code snippets from their testing projects into the markdown documents as code blocks. The limitation is that they can only present the code but not the running code. Sometimes, it would be hard to describe the code behavior. For example, describing a calculator could need a long text, but it could be easier to present the calculator for users to click.</p> <p>You can visit the AppRun Docs Page to see a running calculator.</p> <p></p> <p>All we need to do is to add a web component, called apprun-play under the code blocks.</p> <pre><code>```js\n// code snippets\n```\n&lt;apprun-play&gt;&lt;/apprun-play&gt;\n```\n</code></pre>"},{"location":"about/#control-the-presentation","title":"Control the Presentation","text":"<p>You probably have noticed that the page shows only the results but not the source code. It is because we can control whether to show the source code. We can also decide whether to see the \"Try the Code\" button.</p> <pre><code>```js\n// code snippets\n```\n&lt;apprun-play hide_src=\"true\" hide_button=\"true\"&gt;&lt;/apprun-play&gt;\n</code></pre> <p>You can visit the AppRun Docs Page to see an example of only displaying the running results.</p> <p></p> <p>We can present the code snippets, but we can also embed whole applications because the apprun-play web component supports HTML.</p> <p></p> <p>We can use the embedding external files feature of Material for MkDocs. This way, the markdown document does not include the source code and can remain simple and clean. Automatic Test of the Code</p> <p>When it displays the code result automatically means automatic testing of the code, which tells the author if the code works as expected.</p> <p>Also, while writing, the authors can come up with new ideas. With apprun-play web component, they can edit the code and see the live results. Once it's done, they can copy and paste the code back into the document.</p> <p>Overall, the apprun-play web component is a helpful tool for the document author.</p>"},{"location":"about/#how-its-made","title":"How It's Made","text":"<p>Web components/custom elements are safe in the markdown documents. We can build web components out of the AppRun Components quickly.</p> <p>The apprun-play web component is an AppRun component that gets the source code from its previous sibling element, a textarea, or a div with highlighted code. Then, the apprun-play web component creates an iframe for the code.</p> <p>You can find the source code here.</p> <p>You can download compiled the apprun-play web component and add it to the configuration file of Material for MkDocs, mkdocs.yml</p> <pre><code>extra_css:\n  - assets/vendor/codemirror/codemirror.css\n\nextra_javascript:\n  - assets/vendor/codemirror/codemirror.js\n  - assets/vendor/codemirror/mode/javascript/javascript.js\n  - assets/vendor/codemirror/mode/xml/xml.js\n  - assets/vendor/codemirror/mode/jsx/jsx.js\n  - assets/apprun-play.js\n</code></pre> <p>That's it. The apprun-play web component is ready for use in all the markdown documents.</p> <p>Finally, the AppRun Docs Site Github project is: https://github.com/apprunjs/apprun-docs/</p> <p>Please enjoy and send pull requests.</p>"},{"location":"apprun-site-build/","title":"AppRun-Site Build","text":"<p>The AppRun-Site build command compiles your page to ES Modules with esbuild.</p> <pre><code>npx apprun-site build\n</code></pre> <p>The build command scans your pages in the <code>pages</code> directory and compiles them into the <code>public</code> directory.</p> <pre><code>/public             &lt;- compiled site\n  /index.html       &lt;- copied from `pages/index.html`\n  /index.js         &lt;- compiled from `pages/index.md`\n  /main.js          &lt;- compiled from `pages/main.tsx` and some bootstrap code\n  /about\n    index.js        &lt;- compiled from `pages/about/index.md`\n  /contact\n    index.js        &lt;- compiled from `pages/contact/index.tsx`\n\n/pages              &lt;- source pages\n  /index.html       &lt;- index page\n  /index.md         &lt;- home page\n  /main.tsx         &lt;- start up code\n  /about\n    index.md        &lt;- about page, markdown\n  /contact\n    contact.tsx     &lt;- contact page, AppRun component\n</code></pre> <p>The compiled js files are ES modules. They are compatible on the client-side and server-side.</p> <p>Next, you will learn about client-side rendering.</p>"},{"location":"apprun-site-cli/","title":"AppRun-Site Command Line","text":"<p>The AppRun-site command line has the following commands:</p> <pre><code>Usage: apprun-site [options] [command]\n\nOptions:\n  -h, --help                  display help for command\n\nCommands:\n  build [options] [source]    build site\n  serv [options] [source]     launch development server, watch and no live reload\n  dev [options] [source]      launch development server, watch and live reload\n  help [command]              display help for command\n</code></pre>"},{"location":"apprun-site-cli/#build-command-options","title":"Build Command Options","text":"<p>You can use the following command-line options for the build command.</p> <pre><code>Usage: apprun-site build [options] [source]\n\nbuild site\n\nOptions:\n  -c, --clean            clean the output directory (default: false)\n-w, --watch            watch the directory (default: false)\n-r, --render           pre-render html pages (default: false)\n-o, --output [output]  output directory (default: \"public\")\n-p, --pages [pages]    pages directory (default: \"pages\")\n-h, --help             display help for command\n</code></pre>"},{"location":"apprun-site-cli/#dev-command-options","title":"Dev Command Options","text":"<pre><code>Usage: apprun-site dev [options] [source]\n\nlaunch development server, watch and live reload\n\nOptions:\n  -o, --output [output]  output directory (default: \"public\")\n-p, --pages [pages]    pages directory (default: \"pages\")\n-n, --no_ssr           disable server side rendering (default: false)\n-h, --help             display help for command\n\u279c  apprun git:(master) \u2717 npx apprun-site@latest serve -h\n</code></pre>"},{"location":"apprun-site-cli/#serve-command-options","title":"Serve Command Options","text":"<pre><code>Usage: apprun-site serve [options] [source]\n\nlaunch development server, live reload is optional\n\nOptions:\n  -o, --output [output]  output directory (default: \"public\")\n  -p, --pages [pages]    pages directory (default: \"pages\")\n  -n, --no_ssr           disable server side rendering (default: false)\n  -l, --live_reload      enable live reload (default: false)\n  -h, --help             display help for command\n</code></pre>"},{"location":"apprun-site-cli/#apprun-site-config-file","title":"AppRun-Site Config File","text":"<p>In addition, you can also customize the AppRun-Site in the <code>apprun-site.yml</code> config file.</p> <pre><code>site_name: AppRun Site\nsite_url: /\n\nno-startup: true   # don't inject startup code for dynamic routing\nno-sss: true       # don't use server-side-rendering\n\ndev-server:\n  port: 8080\n\nstatic-pages:     # additional pages to pre-render for the static site\n  - /products/1\n  - /products/2\n  - /products/3\n</code></pre> <p>WIP, more options to come.</p>"},{"location":"apprun-site-csr/","title":"AppRun-Site Client-Side Rendering","text":"<p>The AppRun-Site build command creates pages as ES modules that can be loaded dynamically. The AppRun-Site build command injects the client-side code into the main.js file for routing and loading the pages. To conclude, AppRun Sites are Single Page Applications (SPA).</p>"},{"location":"apprun-site-csr/#app-startup","title":"App Startup","text":"<p>If you have a startup code, you can add it to the main.tsx file. The AppRun-Site build command injects calls to the default exported function of the main.tsx file.</p> <pre><code>/pages              &lt;- pages of the website\n  /main.tsx         &lt;- startup code\n</code></pre>"},{"location":"apprun-site-csr/#example-of-a-markdown-page","title":"Example of a markdown page:","text":"<pre><code>import app from 'apprun';\nimport Layout from '../components/layout'\nimport Comic from '../components/comic';\n\nexport default () =&gt; {\napp.webComponent('ws-comic', Comic);        // register web component\napp.render(document.body, &lt;Layout /&gt;);      // render site layout\n}\n</code></pre>"},{"location":"apprun-site-csr/#no-code-routing","title":"No-Code Routing","text":"<p>You don't need to write any code to route an URL to a component. When users visit an URL, the client-side code will load, route, and render the page dynamically.</p> <p>E.g., when the URL in the browser address bar becomes http://.../contact, it triggers the /contact event. The Contact component reacts to the /contact and renders itself to the screen.</p> <p>The event handler for the /contact event is also injected. Therefore, there is no need to code for routing.</p>"},{"location":"apprun-site-csr/#routing-parameters","title":"Routing Parameters","text":"<p>However, if you want to pass parameters to the component through the URL, you can create your event handler. For example: <pre><code>import { app, Component } from 'apprun';\nexport default class extends Component {\nstate = async () =&gt; { ... }\nview = state =&gt; &lt;div&gt;...&lt;/div&gt;;\nupdate = {\n'/products': async (state, id) =&gt; {\nstate = await Promise.resolve(state);\nreturn ({ ...state, id: parseInt(id) })\n}\n};\n}\n</code></pre> When the URL in the browser address bar becomes http://.../products/1, it triggers the /products event and passes the 1 as the parameter to your event handler.</p>"},{"location":"apprun-site-csr/#pretty-links","title":"Pretty Links","text":"<p>AppRun-Site injects code by default to support pretty links (a.k.a. non-hash links), e.g., http://.../products/1. You don't need to write any code to support pretty links. However, you will need a webserver to serve the index.html when the routes don't exist on the server.</p> <p>The AppRun-Site dev server provides such capability of serving index.html when the routes don't exist.</p> <p>Next, you will see how to use the dev server and how it renders your pages on the server side.</p>"},{"location":"apprun-site-ssr/","title":"AppRun-Site Server-Side Rendering","text":"<p>The AppRun-Site serv command starts a dev server at http://localhost:8080.</p> <pre><code>npx apprun-site serv\n</code></pre> <p>The AppRun-Site dev server serves index.html when the routes don't exist to support Single Page Apps. It also has the capability of server-side rendering to support pretty links and static site creation.</p>"},{"location":"apprun-site-ssr/#es-module","title":"ES Module","text":"<p>Because the pages are compiled into ES Modules, they can be loaded dynamically. Also, thanks to the AppRun architecture, the dev server can render all the pages on the server the same way in the browser.</p> <p>E.g., when users visit http://.../contact, the dev server finds an ES module from <code>/contact/index.js</code>. The dev server loads the module dynamically and renders it to jsdom. Then, it sends the HTML from jsdom back to the browser.</p> <p>The exact same code, /contact/index.js, can be run on the client-side and the server-side. No special treatment is needed.</p>"},{"location":"apprun-site-ssr/#dynamic-routing","title":"Dynamic Routing","text":"<p>The dev server supports dynamic routing. It searches the URL and finds the corresponding ES module. E.g., when users visit http://.../products/1, the dev server will first try to find the ES module from <code>/products/1/index.js</code>. Of course, /products/1/index.js does not exist, so it will try to find <code>/products/index.js.</code> If <code>/products/index.js</code> exists, it will load the module dynamically and sends 1 as the parameter for rendering.</p> <p>The result is that pretty links are supported on the server side.</p> <p>Finally, although you have a dev server for development, you may not have a node server or use a different web server in production. In this case, you can pre-render your site into a static site. Proceed to the next section to learn how to create a static site.</p>"},{"location":"apprun-site-static/","title":"AppRun-Site - Static Site","text":"<p>The AppRun-Site build command has the option to render your pages into HTML files and create a static website.</p> <pre><code>npx apprun-site build --render\n</code></pre> <p>The build command first scans and compiles your pages in the <code>pages</code> directory and then downloads them into the <code>public</code> directory by leveraging the dev server's server-side rendering.</p> <pre><code>/public             &lt;- compiled site\n  /index.html       &lt;- copied\n  /index.js         &lt;- compiled\n  /main.js          &lt;- compiled\n  /about\n    /index.html     &lt;- *** server-side rendered page ***\n    index.js        &lt;- compiled\n  /contact\n    /index.html     &lt;- *** server-side rendered page ***\n    index.js        &lt;- compiled\n\n/pages              &lt;- sorrce pages\n  /index.html       &lt;- index page\n  /index.md         &lt;- home page\n  /main.tsx         &lt;- start up code\n  /about\n    index.md        &lt;- about page, markdown\n  /contact\n    contact.tsx     &lt;- contact page, AppRun component`\n</code></pre> <p>With all the HTML pages created, you can deploy the static website.</p> <p>In the next section, you will learn the AppRun-Site command line.</p>"},{"location":"apprun-site/","title":"AppRun Site","text":"<p>AppRun-Site let you focus on creating web pages using HTML, markdown, AppRun components, and web components. AppRun-Site will take care of the rest:</p> <ul> <li>It compiles your pages to ES Modules</li> <li>It runs your pages run as Single Page Applications (SPA)</li> <li>It can render your pages using Server-Side Rendering (SSR)</li> <li>It can also generate a static website</li> </ul>"},{"location":"apprun-site/#create-apprun-site","title":"Create AppRun Site","text":"<p>You can initialize a project using the <code>npm create apprun-app</code> command and select the <code>AppRun Site</code> template.</p> <pre><code>npm init apprun-app [my-app]\n</code></pre>"},{"location":"apprun-site/#apprun-site-architecture","title":"AppRun Site Architecture","text":"<p>An AppRun-Site project has the following structure:</p> <pre><code>/pages              &lt;- pages of the website\n  /index.html       &lt;- index page\n  /index.md         &lt;- home page\n  /main.tsx         &lt;- start up code\n  /about\n    index.md        &lt;- about page, markdown\n  /contact\n    contact.tsx     &lt;- contact page, AppRun component\n</code></pre> <p>Then, you can use:</p> <ul> <li>npm start or npm run dev to start the dev server and watch your code changes.</li> </ul> <p>The application will run at http://localhost:8080.</p>"},{"location":"apprun-site/#add-pages","title":"Add Pages","text":"<p>You can add AppRun components, class or functional (tsx/jsx files), markdown, or html files to the <code>pages</code> directory.</p> <p>Example of an AppRun class component page: <pre><code>import { app, Component } from 'apprun';\nexport default class ContactComponent extends Component {\nstate = '...';\nview = state =&gt; &lt;div&gt;\n&lt;h2&gt;{state}&lt;/h2&gt;\n&lt;p&gt;This is a class Component&lt;/p&gt;\n&lt;/div&gt;;\n}\n</code></pre></p>"},{"location":"apprun-site/#example-of-an-apprun-functional-component-page","title":"Example of an AppRun functional component page:","text":"<pre><code>import app from 'apprun';\nexport default () =&gt; &lt;&gt;\n&lt;h2&gt;...&lt;/h2&gt;\n&lt;p&gt;This is a functional Component&lt;/p&gt;\n&lt;/&gt;\n</code></pre>"},{"location":"apprun-site/#example-of-a-markdown-page","title":"Example of a markdown page:","text":"<pre><code># Hello Web Component\nThis is a markdown page with a web component to display a comic from XKCD\n&lt;ws-comic&gt;&lt;/ws-comic&gt;\n</code></pre>"},{"location":"apprun-site/#example-of-an-html-page","title":"Example of an html page:","text":"<pre><code>&lt;h2&gt;Page&lt;/h2&gt;\n&lt;div&gt;This is an HTML page&lt;/div&gt;\n</code></pre> <p>All the pages will be compiled into the ES modules in the <code>public</code> directory when you build the site.</p> <p>Next, you will learn how to build your site.</p>"},{"location":"architecture/","title":"AppRun Architecture","text":""},{"location":"architecture/#architecture-overview","title":"Architecture Overview","text":"<p>Application logic is broken down into three separate parts in the AppRun architecture.</p> <ul> <li>State (a.k.a. Model) \u2014 the state of your application</li> <li>View \u2014 a function to display the state</li> <li>Update \u2014 a collection of event handlers to update the state</li> </ul> <p>Use a Counter as an example.</p> <p><pre><code>const state = 0;\n\nconst view = state =&gt; &lt;div&gt;\n&lt;h1&gt;{state}&lt;/h1&gt;\n&lt;button onclick={()=&gt;app.run('-1')}&gt;-1&lt;/button&gt;\n&lt;button onclick={()=&gt;app.run('+1')}&gt;+1&lt;/button&gt;\n&lt;/div&gt;;\n\nconst update = {\n'+1': state =&gt; state + 1,\n'-1': state =&gt; state - 1\n};\n\napp.start(document.body, state, view, update);\n</code></pre> </p>"},{"location":"architecture/#state","title":"State","text":"<p>The state can be any data structure, a number, an array, or an object that reflects the state of the application. In the _ Counter_ example, it is a number.</p> <pre><code>const state = 0;\n</code></pre> <p>Note</p> <p>You define the initial state. AppRun manages the state. Therefore the initial state is an immutable constant.</p>"},{"location":"architecture/#view","title":"View","text":"<p>The view generates Virtual DOM based on the state. Finally, AppRun calculates the differences against the web page element and renders the changes.</p> <pre><code>const view = state =&gt; &lt;div&gt;\n&lt;h1&gt;${state}&lt;/h1&gt;\n&lt;button $onclick=\"-1\"&gt;-1&lt;/button&gt;\n&lt;button $onclick=\"+1\"&gt;+1&lt;/button&gt;\n&lt;/div&gt;;\n</code></pre> <p>Note</p> <p>AppRun allows you to choose your favorite virtual DOM technology in the view function. The example above uses JSX. You can also use lit-html, uhtml, and etc.</p>"},{"location":"architecture/#update","title":"Update","text":"<p>The update is a collection of named event handlers or a dictionary of event handlers. Each event handler creates a new state from the current state. <pre><code>const update = {\n'+1': state =&gt; state + 1,\n'-1': state =&gt; state - 1\n}\n</code></pre></p> <p>Note</p> <p>There are a few other ways to define event handlers.</p> <p>When the three parts, the state, view, and update are provided to AppRun to start an application, AppRun registers the event handlers defined in the update and waits for AppRun events.</p> <pre><code>app.start(document.body, state, view, update);\n</code></pre> <p>Next, let's review some of the benefits of AppRun Architecture.</p>"},{"location":"architecture/#avoid-spaghetti-code","title":"Avoid Spaghetti Code","text":"<p>AppRun solves two challenging problems commonly found in application development:</p> <p>Let's make the Counter a bitter complicated to show how many times each button clicked.</p> <p><pre><code>// initial state object\nconst state = {\ncount: 0,\ncount_plus: 0,\ncount_minus: 0\n}\n\n// one view function to render the state, its' a pure function\nconst view = ({ count, count_plus, count_minus }) =&gt; html`\n  &lt;h1&gt;${count}&lt;/h1&gt;\n  &lt;button onclick=\"app.run('minus')\"&gt;- (${count_minus})&lt;/button&gt;\n  &lt;button onclick=\"app.run('plus')\"&gt;+ (${count_plus})&lt;/button&gt;\n`\n\n// collection of state updates, state is immutable\nconst minus = (state) =&gt; ({\n...state,\ncount: state.count - 1,\ncount_minus: state.count_minus + 1\n});\n\nconst plus = (state) =&gt; ({\n...state,\ncount: state.count + 1,\ncount_plus: state.count_plus + 1\n});\n\napp.start(document.body, state, view, { plus, minus });\n</code></pre> </p> <p>The code below uses jQuery. jQuery is a library that provides the convenience to access and manipulate the DOM. It does not give any architectural guidance. jQuery code is similar to the vanilla JavaScript code that can go wild. A jQuery Example</p> <pre><code>$(function () {\n\n// global state\nlet count = 0\nlet count_plus = 0\nlet count_minus = 0\n\nfunction plus() {\n// state update\ncount ++\ncount_plus ++\n\n// rendering\n$('#total').html(count)\n$('#plus').html(`+ (${count_plus})`)\n}\n\nfunction minus() {\n// state update\ncount --\ncount_minus ++\n\n// rendering\n$('#total').html(count)\n$('#minus').html(`- (${count_minus})`)\n}\n\n$('#plus').on('click', plus)\n$('#minus').on('click', minus)\n\n})\n</code></pre> <p>You can see from the above code that</p> <ul> <li>The state is shared globally. The two event handlers plus and minus both update the state directly.</li> <li>The two event handlers also render the DOM in different pieces.</li> </ul> <p>Therefore, the jQuery code has two problems:</p> <ul> <li>Direct State Update</li> <li>Rendering Fragments</li> </ul> <p>In much more complicated real applications, the logic could be long and tangled even more.</p> <p>How can we solve the problems using AppRun?</p>"},{"location":"architecture/#apprun-code","title":"AppRun Code","text":"<p>AppRun includes state management, an event system, and Virtual-DOM rendering. Following the Hollywood Principle (Don't call us. We call you), we provide code pieces to AppRun and wait for AppRun to call them.</p> <p>During an AppRun event lifecycle:</p> <ul> <li>AppRun let you update the state when needed</li> <li>AppRun let you create a virtual DOM out of the state when needed</li> <li>AppRun renders the virtual DOM when needed.</li> </ul> <p>When using AppRun to update the state, AppRun gives the current state. Then, we create a new state based on the current state.</p> <pre><code>const minus = (state) =&gt; ({ ...state,\ncount: state.count - 1,\ncount_minus: state.count_minus + 1\n});\n\nconst plus = (state) =&gt; ({ ...state,\ncount: state.count + 1,\ncount_plus: state.count_plus + 1\n});\n</code></pre> <p>Because there is no reference to a shared global object, it is very easy to unit-test the logic. Also, we can focus on the parts of the state that are needed to update and ignore the rest of the state using the spread operator.</p> <p>We only write a view function that creates a virtual DOM. AppRun renders the DOM using the diffing algorithm. It only updates the DOM that is needed to change. Therefore, although we have only one view function for all events, AppRun takes care of the differential rendering accordingly.</p> <pre><code>const view = ({ count, count_plus, count_minus }) =&gt; html`\n  &lt;h1&gt;${count}&lt;/h1&gt;\n  &lt;button onclick=\"app.run('minus')\"&gt;- (${count_minus})&lt;/button&gt;\n  &lt;button onclick=\"app.run('plus')\"&gt;+ (${count_plus})&lt;/button&gt;`\n</code></pre> <p>The view function always returns the same result as long as the state is the same. It also does not change the state or anything outside the function, which means it has no side effects. Therefore, the view function is a pure function. There are many benefits of using the pure__ function, including but not limited to unit testing.</p> <p>Finally, We have a _ counter _ application shown below by putting the state, _view, and update together.</p> <p><pre><code>// initial state object\nconst state = {\ncount: 0,\ncount_plus: 0,\ncount_minus: 0\n}\n\n// one view function to render the state, its' a pure function\nconst view = ({ count, count_plus, count_minus }) =&gt; html`\n  &lt;h1&gt;${count}&lt;/h1&gt;\n  &lt;button onclick=\"app.run('minus')\"&gt;- (${count_minus})&lt;/button&gt;\n  &lt;button onclick=\"app.run('plus')\"&gt;+ (${count_plus})&lt;/button&gt;\n`\n\n// collection of state updates, state is immutable\nconst minus = (state) =&gt; ({\n...state,\ncount: state.count - 1,\ncount_minus: state.count_minus + 1\n});\n\nconst plus = (state) =&gt; ({\n...state,\ncount: state.count + 1,\ncount_plus: state.count_plus + 1\n});\n\napp.start(document.body, state, view, { plus, minus });\n</code></pre> </p> <p>You can see that with the help of AppRun state management and DOM differential rendering, we no longer have the Direct State Update with Rendering Fragments problems.</p>"},{"location":"architecture/#apprun-benefits","title":"AppRun Benefits","text":"<p>No matter how complex the application is, we will always have three parts, the state, view, and update. We don't mix the state update with DOM rendering. Because the three parts are decoupled, our codebase is so much easier to understand, test, and maintain.</p>"},{"location":"architecture/#ceremony-vs-essence","title":"Ceremony vs. Essence","text":"<p>There was the 'Ceremony vs. Essence' discussion that happened about ten years ago. At that time, Ruby was on the rise. So people compared Ruby with C#.</p> <p>The fundamental idea of the Ceremony vs. Essence idea appears to be that, all other things being equal, programming languages should attempt to allow programmers to clearly express the essence of their programs without being caught up in excessive ceremony provided by the programming language. -- From this post.</p> <p>Let's take a look at some of today's frontend technologies from the Ceremony vs. Essence point of view. We will use a simple button-click counting application as an example.</p> <p><pre><code>const add = count =&gt; count + 1;\n\nconst view = count =&gt; &lt;button $onclick={add}&gt;\nClicks: {count}\n&lt;/button&gt;;\n\nconst rendered = count =&gt; console.log(count);\n\napp.start(document.body, 0, view, null, { rendered });\nconsole.log('mounted!');\n</code></pre> </p>"},{"location":"architecture/#the-essence","title":"The Essence","text":"<p>The essence of the application is to display a button that adds the count by one and shows the count. Also, it will log some messages in the console to mimic effects after the rendering cycle.</p> <p>The concept is as simple as below.</p> <pre><code>&lt;button onclick=\"count+1\"&gt;\nClicks: {count}\n&lt;/button&gt;\n\nconsole.log(count); // upon very click\nconsole.log('mounted!'); // upon mounted\n</code></pre> <p>We will compare the 95-character essence code above with a few front-end frameworks, such as AppRun, Svelte, React Hooks, and the Vue Composition API.</p> <p>A framework defines a skeleton where the application defines its features to fill out the skeleton. -- you can find this quote from googling.</p> <p>We need to write code to plugin the essence code into the frontend frameworks, which is the ceremony. We don't want them. Less of them is better.</p>"},{"location":"architecture/#the-ceremony","title":"The Ceremony","text":""},{"location":"architecture/#apprun","title":"AppRun","text":"<p>Application logic is broken down into three separate parts in the AppRun architecture.</p> <p><pre><code>const add = count =&gt; count + 1;\n\nconst view = count =&gt; &lt;button $onclick={add}&gt;\nClicks: {count}\n&lt;/button&gt;;\n\nconst rendered = count =&gt; console.log(count);\n\napp.start(document.body, 0, view, null, { rendered });\nconsole.log('mounted!');\n</code></pre> </p> <p>In the example above,</p> <ol> <li>The application's state is a number that has a default value of 0.</li> <li>The add function is the event handler to update the state.</li> <li>The view function displays the state.</li> <li>The rendered function runs after the DOM is rendered.</li> <li>The app.start function ties them all together to the document.body element.</li> </ol> <p>Now, we identify and cross out the ceremonies.</p> <p></p> <p>With AppRun, the ceremony is mainly required by the JavaScript syntax, like the module import and the arrow functions. Overall, it has 226 characters, which means 58% of the code are ceremonies.</p>"},{"location":"architecture/#svelte","title":"Svelte","text":"<p>Svelte uses a single file for a component. The file consists of a script section for the code and the UI template. It requires a compiler to turn it into runnable JavaScript code.</p> <pre><code>&lt;script&gt;\nimport { onMount } from 'svelte'\n\nlet count = 0;\nconst add = () =&gt; count + 1;\n\n$: console.log(count)\n\nonMount(() =&gt; console.log('mounted!')\n&lt;/script&gt;\n\n&lt;button on:click={add}&gt;\nClicks: {count}\n&lt;/button&gt;\n</code></pre> <p>Behind the scene, the svelte compiler creates the component class boilerplate. Then, the compiler extracts the script block, wires up the reactivity ($:), and adds the rendering template into the boilerplate. The boilerplate does not exist in our codebase. Therefore, the svelte application has very few ceremonies.</p> <p></p> <p>Svelte code ceremony is also mainly the JavaScript syntax requirements. Only the script tags are required by the Svelte compiler, which is worth trading with what the compiler saves.</p> <p>It has 217 characters, which means 56% of the code is ceremony.</p>"},{"location":"architecture/#react-hooks","title":"React Hooks","text":"<p>The React code is a slightly modified version of the React Hooks Docs](https://reactjs.org/docs/hooks-overview.html).</p> <pre><code>import React, { useState, useEffect } from 'react';\n\nfunction Example() {\nconst [count, setCount] = useState(0);\n\nconst add = () =&gt; setCount(count + 1)\n\nuseEffect(() =&gt; {\nconsole.log(count);\n});\n\nreturn (\n&lt;button onClick={add}&gt;\nClicks: {count}\n&lt;/button&gt;\n);\n}\n</code></pre> <p>The React code has more ceremonies than the AppRun code and Svelte code above. It has 272 characters and a 65% ceremony.</p> <p></p> <p>The setCount, _useState, and useEffect functions are the code that deals with the React framework itself. They don't help us to express the essence of the application. They are framework ceremonies.</p>"},{"location":"architecture/#vue-composition-api","title":"Vue Composition API","text":"<p>The Vue code is a slightly modified version of the Vue Composition API Docs.</p> <p><pre><code>&lt;template&gt;\n&lt;button @click=\"add\"&gt;\nClicks: {{ count }}\n&lt;/button&gt;\n&lt;/template&gt;\n\nimport { ref, watchEffect, onMounted } from 'vue'\n\nexport default {\nsetup() {\nconst count = ref(0)\nfunction add() {\ncount.value++\n}\n\nwatchEffect(() =&gt; console.log(count.value))\n\nonMounted(() =&gt; console.log('mounted!'))\n\nreturn {\ncount,\nadd\n}\n}\n}\n</code></pre> The Vue code has 355 characters and a 73% ceremony.</p> <p></p> <p>The ref, watchEffect, onMounted, setup, _count.value, and returning an object of count, and add are all required by the Vue framework. Sometimes, they may make writing code more difficult.</p>"},{"location":"architecture/#expression-comparison","title":"Expression Comparison","text":"<p>We are not stopping at only comparing the character counts or how many extra boilerplates are forced on you by the frameworks. We also compare how you express the business logic. For example, let's see how we express Increase the Counter as an example again.</p> <pre><code>// AppRun\nconst add = counter =&gt; counter + 1;\n\n//Svelte\nlet count = 0;\nconst add = () =&gt; counter + 1;\n\n// React\nconst [count, setCount] = useState(0);\nconst add = () =&gt; setCount(count + 1);\n\n// Vue\nconst count = ref(0);\nconst add = () =&gt; count.value++;\n</code></pre> <p>Both the AppRun code and the Svelte code express the essence well and have less ceremony. So AppRun and Svelte are easy to understand. React Hooks and Vue Composition API are cool. However, they both add a lot more ceremonies to our codebase.</p> <p>Remember, the ceremony has no business values but just challenges to understand and maintain.</p> <p>In addition, AppRun has a few other benefits</p> <ul> <li>AppRun is lightweight that can run in browsers directly without a compiler.</li> <li>AppRun uses pure functions when it is possible.</li> <li>AppRun app codebase can easily be strongly typed if you wish.</li> </ul> <p>I hope you enjoy it. If you haven't clicked the 'Try the Code' buttons to run the AppRun code above, please give it a try.</p>"},{"location":"cli-in-console/","title":"AppRun Dev Tools","text":"<p>We have been using the command-line interface (CLI) in the terminal window and the command prompt. Have you thought of a CLI in the console of the browser's developer tool?</p> <p></p>"},{"location":"cli-in-console/#how-does-it-work","title":"How does it work?","text":"<p>In the console of the browser's developer tool (F12), you can type the command.</p> <pre><code>_apprun `&lt;command&gt; [options]`\n</code></pre> <p>Just like many other CLI, the help command lists all available commands. For example, you can see three commands in the screenshotcomponents, events, and log.</p>"},{"location":"cli-in-console/#why-do-we-need-a-cli-in-the-console","title":"Why do we need a CLI in the console?","text":"<p>CLI in the console is convenient for watching runtime data. For example, during application development, we often need to debug and check the application's internal data. Using the console.log function is the easiest yet most compelling way to display the data because the console lets us drill down into the nested array and object structure.</p> <p></p> <p>With a CLI in the console, The app codebase stays clear of console.log. The CLI provides a non-destructive way of watching the runtime data. We can include the CLI script in the development environment and remove it from the production environment.</p>"},{"location":"cli-in-console/#how-is-it-made","title":"How is it made?","text":"<p>The CLI uses JavaScript tagged templates.</p> <p>We create the _apprun function in the window object.</p> <pre><code>window['_apprun'] = (strings) =&gt; { }\n</code></pre> <p>The _apprun function is called when we type the AppRun commands in the console. The command and the command parameters are passed into the _apprun function as the function parameter strings, which we can parse and then invoke the command functions.</p> <p><pre><code>window['_apprun'] = (strings) =&gt; {\nconst [cmd, ...p] = strings[0].split(' ').filter(c =&gt; !!c);\nconst command = window[`_apprun-${cmd}`];\nif (command) command[1](...p);\nelse window['_apprun-help'][1]();\n}\n</code></pre> It has extensive architecture. We create the AppRun commands in the window object. The AppRun command is a tuple that includes the description of the command and the implementation function of the command. E.g., the help command looks like this:</p> <p><pre><code>window['_apprun-help'] = ['', () =&gt; {\nObject.keys(window).forEach(cmd =&gt; {\nif (cmd.startsWith('_apprun-')) {\ncmd === '_apprun-help' ?\nconsole.log('AppRun Commands:') :\nconsole.log(`* ${cmd.substring(8)}: ${window[cmd][0]}`);\n}\n});\n}];\n</code></pre> The help command searches for the tuples stored in the window object and prints the description of other AppRun commands.</p> <p>That's all the infrastructure code we need to create CLI commands in the console. Let's see an example.</p>"},{"location":"cli-in-console/#live-demo","title":"Live Demo","text":"<p>The AppRun Dev Tools is one of the developer tools included in the AppRun library. You can visit the AppRun RealWorld Example App https://gothinkster.github.io/apprun-realworld-example-app to see the CLI in action.</p> <ul> <li>The components command logs the DOM elements that have AppRun components</li> <li>The events command logs the event subscription of the app</li> <li>The log command logs the runtime events publication of the app</li> <li>The create-event-tests command creates unit tests for the app</li> <li>The create-state-tests command creates Jest snapshot tests for the app</li> </ul>"},{"location":"cli-in-console/#conclusion","title":"Conclusion","text":"<p>Developers like CLI. Dev Tools helps get runtime events and messages hard for the traditional CLI in the terminal. The AppRun Dev Tools can watch the components and events, and can generate tests. Thus, it increases the development productivity for debugging and testing.</p>"},{"location":"component/","title":"Component","text":"<p>The component is a technique to decompose the large system into smaller, manageable, and reusable pieces. The component is the basic building block. Usually, a component is an autonomous and reusable module that encapsulates a set of data and functions.</p> <p>An AppRun component is a mini-application with elm architecture, which means inside a component, there are state, view, and update. In addition, components provide a local scope.</p>"},{"location":"component/#render-the-component","title":"Render the Component","text":"<p>To use the components, you can render them into an element.</p> <p><pre><code>const element = document.getElementById('my-app');\napp.render(element, &lt;Counter /&gt;);\n</code></pre> When rendering the component, AppRun creates a component instance and renders it to the element.</p>"},{"location":"component/#mount-and-start","title":"Mount and Start","text":"<p>Or you can create the component using the constructor and mount the component instance to an element or to an element ID. When the component is mounted to an element ID, It will render the element only when it exists.</p> <pre><code>const element = document.getElementById('my-app');\nnew Counter().mount(element);\n</code></pre> <p>You can also pass the initial state into the component's constructor directly:</p> <pre><code>new Counter(100).mount(element);\n</code></pre> <p>When the component is mounted, by default, it won't display until the events come. It is useful in the single-page application (SPA) scenario where you can mount all components at once. Each component is activated by the routing events.</p> <p>If you need the component to display the initial state, you can use the start function.</p> <pre><code>new Counter().start(document.body); // mount and display\n</code></pre> <p>You can render, mount, or start the component to document.body.</p> <pre><code>//\napp.render(document.body, &lt;Counter /&gt;);\n//\nnew Counter().mount(document.body);\n//\nnew Counter().start(document.body);\n</code></pre>"},{"location":"component/#child-component","title":"Child Component","text":"<p>Components can have child components.</p> <pre><code>class Child extends Component {\nstate = {}\nview = state =&gt; &lt;div&gt;&lt;/div&gt;\nupdate = {}\n}\n\nclass Parent extends Component {\nstate = {}\nview = state =&gt; &lt;div&gt;\n&lt;Child /&gt;\n&lt;/div&gt;\nupdate = {}\n}\n</code></pre> <p>You are not forced into the nested component structure. Sometimes, mounting components are more flexible. Please read this post, Redux vs. The React Context API vs. AppRun.</p>"},{"location":"component/#component-events","title":"Component Events","text":"<p>A Component provides a local scope for events. The update registers the local events in the component. The this.run function fires local events that can only be picked up inside the component.</p> <p>You can prefix the event name with #, / or @ to make it global.</p> <pre><code>class Counter extends Component {\nupdate = {\n'+1': state=&gt;state+1, // local event\n'#+1': state=&gt;state+1, // global event\n}\n}\n</code></pre> <p>The app.run fires the global events that can be picked up by all components.</p> <p>In addition, to use the update for defining event handlers, you can also use the @on decorator or the $on directive.</p>"},{"location":"component/#event-handler-decorator","title":"Event Handler Decorator","text":"<p>In the component class, we can use TypeScript to compile the @on decorators to create the event handlers without using the update object.</p> <pre><code>import app, { Component, on } from 'apprun';\nclass Counter extends Component {\nstate = 0;\nview = state =&gt; &lt;&gt;\n&lt;h1&gt;{state}&lt;/h1&gt;\n&lt;button onclick={()=&gt;this.run('-1')}&gt;-1&lt;/button&gt;\n&lt;button onclick={()=&gt;this.run('+1')}&gt;+1&lt;/button&gt;\n&lt;/&gt;;\n\n@on('-1')\ndecrease = state =&gt; state - 1;\n\n@on('+1')\nincrease = state =&gt; state + 1;\n}\n</code></pre>"},{"location":"component/#event-directive","title":"Event Directive","text":"<p>We can also use the directive to simplify event handling.</p> <pre><code>import {app, Component} from 'apprun';\nclass Counter extends Component {\nstate = 0;\nview = state =&gt; &lt;div&gt;\n&lt;h1&gt;{state}&lt;/h1&gt;\n&lt;button $onclick={state=&gt;state-1}&gt;-1&lt;/button&gt;\n&lt;button $onclick={state=&gt;state+1}&gt;+1&lt;/button&gt;\n&lt;/div&gt;;\n}\n</code></pre>"},{"location":"component/#life-cycle-functions","title":"Life Cycle Functions","text":"<p>Life Cycle Functions are callback functions that AppRun calls during the component life cycle. They are mounted, rendered, and unload.</p> <pre><code>import { app, Component } from 'apprun';\n\nclass MyApp extends Component {\nstate = {};\nview = state =&gt; &lt;div&gt;&lt;/div&gt;;\nupdate = {};\n\n//life cycle functions\nmounted = (props, children, state) =&gt; state;\nrendered = state =&gt; {};\nunload = state =&gt; {};\n}\n\napp.render(document.body, &lt;MyApp /&gt;);\n</code></pre>"},{"location":"component/#mounted","title":"mounted","text":"<p>The mounted function is called after the component instance is mounted to a DOM element. The mounted function can be used to set the initialize state. <pre><code>mounted: (props: any, children: any[], state: T) =&gt; T | void;\n</code></pre></p> <p>Note: the mounted function is only called in the child component.</p> <pre><code>class Child extends Component {\nstate = {} // you can define the initial state\nview = state =&gt; &lt;div&gt;&lt;/div&gt;\nupdate = {}\nmounted = (props, children) =&gt; { ...state, ...props } // this will be called, you can merge props into the state\n}\n\nclass Parent extends Component {\nstate = {} // you can define the initial state\nview = state =&gt; &lt;div&gt;\n&lt;Child /&gt;\n&lt;/div&gt;\nupdate = {}\nmounted = () =&gt; { } // this will NOT be called when component is created using the constructor\n}\nnew Parent().start(document.body);\n</code></pre>"},{"location":"component/#rendered","title":"rendered","text":"<p>The rendered function is called after AppRun renders the result of the view function. The rendered function can be used to modify the DOM element using 3rd party libraries. <pre><code>rendered: (state: T, props?: any[]) =&gt; void;\n</code></pre></p>"},{"location":"component/#unload","title":"unload","text":"<p>The _unload function is called when the DOM element that the component is mounted to is removed or reused by other components. For example, the _unload function can be used to clean the resources created by the 3rd party libraries.</p> <pre><code>unload: (state: T) =&gt; void;\n</code></pre> <p>You can see, the component life cycle functions are useful for integrating 3rd party libraries.</p>"},{"location":"component/#web-components","title":"Web Components","text":"<p>You can convert AppRun components into web components/custom elements. AppRun components become the custom elements that also can handle AppRun events.</p> <p><pre><code>&lt;html&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"&gt;\n  &lt;title&gt;Counter as web component&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;my-app id='counter'&gt;&lt;/my-app&gt;\n  &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/custom-elements/1.1.2/custom-elements.min.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"https://unpkg.com/apprun/dist/apprun-html.js\"&gt;&lt;/script&gt;\n  &lt;script&gt;\nclass Counter extends Component {\nconstructor() {\nsuper();\nthis.state = 0;\nthis.view = state =&gt; `&lt;div&gt;\n          &lt;h1&gt;${state}&lt;/h1&gt;\n          &lt;button onclick='counter.run(\"-1\")'&gt;-1&lt;/button&gt;\n          &lt;button onclick='counter.run(\"+1\")'&gt;+1&lt;/button&gt;\n          &lt;/div&gt;`;\nthis.update = {\n'+1': state =&gt; state + 1,\n'-1': state =&gt; state - 1\n};\n}\n}\napp.webComponent('my-app', Counter);\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </p>"},{"location":"component/#html-child-components","title":"HTML Child Components","text":"<p>Unlike JSX, you can embed component classes into JSX; when using HTML string components, you will need to make a web component/custom element. Then you can embed the components.</p> <pre><code>import app from 'apprun';\nimport MyComponent from './MyComponent';\n\napp.webComponent('my-component', MyComponent);\n\nconst view = state =&gt; {\nreturn `&lt;div&gt;\n    &lt;my-component /&gt;\n  &lt;/div&gt;`;\n};\napp.start('my-app', state, view);\n</code></pre>"},{"location":"create-apprun-app/","title":"Create AppRun App","text":"<p>The npm create apprun-app command line tool creates a new AppRun project. It can scaffold a new project with build tools and a development server.</p> <p>To create a project, run:</p> <pre><code>npx create-apprun-app my-app\ncd my-app\nnpm start\n</code></pre> <p>You can select one of the following project templates:</p> <pre><code>? Select a template \u203a - Use arrow-keys. Return to submit.\n    HTML/JS\n    HTML/JS - Web Component\n    Blank App\n    Signle Page App\n\u276f   AppRun Site (default)\n</code></pre> <p>You can also select a build tool:</p> <pre><code>? Select a compiler \u203a - Use arrow-keys. Return to submit.\n    esbuild\n    webpack\n\u276f   vite\n</code></pre> <p>Then, you can choose to add Jest and git repo:</p> <pre><code>? Add Jest? \u2026 No / Yes\n? Add git repo? \u203a No / Yes\n</code></pre> <p>Finally, it creates a new project for you:</p> <pre><code>Project created in:  ....../my-app\nPlease go to the project directory and run:\n\n        npm start\n\nAnd then, you can visit the project at: http://localhost:8080\n</code></pre> <p>You can read more about the project templates in the following sections.</p> <ul> <li>Single Page App</li> <li>AppRun Site</li> </ul>"},{"location":"dev-server/","title":"AppRun Dev Server Supports ESM","text":""},{"location":"dev-server/#introduction","title":"Introduction","text":"<p>We use JavaScript modules (ESM) extensively while coding nowadays. But we still cannot deploy the module-based code yet. It is because the browsers don't know how to handle global modules.  E.g., When developing applications using AppRun, we need a globe module of apprun.</p> <pre><code>import app from 'apprun'\n</code></pre> <p>The browsers don't know how to import apprun. Therefore, We still need to use JavaScript bundlers such as webpack, rollup, or parcel to bundle the modules.</p> <p>But at least now, we can use the modules to speed up the development process. Recently, the Snowpack team introduced the concept of Unbundled Development, which is to leverage modules for speeding up the development process.</p> <p>In the past, I was thinking of building a tool to convert the global modules to the modules links on unpkg after compilation.</p> <p>The npm package CDN, unpkg.com supports delivering modules for along time. We can load apprun as a module from unpkg.</p> <pre><code>import app from 'https://unpkg.com/apprun?module'\n</code></pre> <p>Now, it seems that a development server is a different and better idea. So, I forked the live-server and made a development server for AppRun.</p> <p>This post is to introduce the AppRun development server, called apprun-dev-server.</p>"},{"location":"dev-server/#apprun-dev-server","title":"apprun-dev-server","text":"<p>This is a static web server for developing JavaScript/TypeScript using ES modules following the concept of Unbundled Development.</p> <ul> <li>It serves the ES Modules from unpkg.com.</li> <li>Based on live-server, so it reloads the page automatically</li> <li>Also, it detects AppRun and can replace the module/Component while keeping the application state.</li> </ul> <p></p> <p>The best part of the apprun-dev-server is that it does NOT require any code in our components to handle the hot module replacement. Instead, it retains the component state; replaces the module; and then puts the state back. All done automatically.</p> <p>If you want to refresh the state, you can reload the page in the browser by pressing F5 (on Windows) or Command+R (on Mac).</p>"},{"location":"dev-server/#how-to-use","title":"How to Use","text":"<p>You export Component as the default module export.</p> <pre><code>import { app, Component } from 'apprun';\n\nexport default class AboutComponent extends Component {\nstate = 'About';\nview = state =&gt; &lt;div&gt;\n&lt;h1&gt;{state}&lt;/h1&gt;\n&lt;/div&gt;;\nupdate = {\n'#About': state =&gt; state,\n};\n}\n</code></pre> <p>Then, you use the Component in the main file.</p> <pre><code>import About from './About';\n\nnew About().start('my-app');\n</code></pre> <p>Then, you use a module-type script tag in HTML.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"&gt;\n  &lt;title&gt;AppRun SPA&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;script type=\"module\" src=\"/dist/main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Turn on the compiler, TypeScript, or Babel in watch mode. And then, start the apprun-dev-server using npx.</p> <pre><code>npx apprun-dev-server\n</code></pre> <p>Apprun-dev-server monitors the file changes. If the changed JavaScript files (*.js) file have global modules. Apprun-dev-server replaces the global module's references to unpkg. In the server console, if you see the file names that have some dots '......' in front, they are the files modified.</p> <p>Apprun-dev-server injects JavaScript code snippets in the index.html just like live-server. Also, Apprun-dev-server adds logic to detect AppRun and replace AppRun components.</p> <p>You can download an example app to give it a try.</p> <pre><code>npx degit yysun/apprun-esm-server my-app\n</code></pre>"},{"location":"dev-server/#configuration","title":"Configuration","text":"<p>Create a apprun-dev-server.config.js in your project:</p> <pre><code>module.exports = {\nport: 8181, // Set the server port. Defaults to 8080.\nhost: \"0.0.0.0\", // Set the address to bind to. Defaults to 0.0.0.0 or process.env.IP.\nroot: \"public\", // Set root directory that's being served. Defaults to cwd.\nopen: false, // When false, it won't load your browser by default.\nignore: '', // comma-separated string for paths to ignore\nfile: \"index.html\", // When set, serve this file (server root relative) for every 404 (useful for single-page applications)\nwait: 1000, // Waits for all changes, before reloading. Defaults to 0 sec.\nmount: [], // Mount a directory to a route.\nlogLevel: 2, //\n}\n</code></pre>"},{"location":"dev-server/#use-with-esbuild","title":"Use with esbuild","text":"<p>The apprun-dev-server is installed when creating a project by using the <code>npm init apprun-app</code> command and selecting the `esbuild`` option.</p> <pre><code>npm init apprun-app [my-app]\n</code></pre> <p>Give it a try and send pull requests.</p> <p>https://github.com/yysun/apprun-dev-server</p>"},{"location":"directive/","title":"Directives","text":"<p>AppRun directives are syntax sugars that help simplify the code. They are custom attributes in JSX that have names starting with $. AppRun two out-of-the-box directives: $on and $bind.</p>"},{"location":"directive/#on","title":"$on...","text":"<p>The $on directive simplifies the code to convert the DOM events to AppRun events.</p>"},{"location":"directive/#publish-events","title":"Publish Events","text":"<p><pre><code>class Counter extends Component {\nstate = 0;\nview = state =&gt; &lt;&gt;\n&lt;h1&gt;{state}&lt;/h1&gt;\n&lt;button $onclick='-1'&gt;-1&lt;/button&gt;\n&lt;button $onclick='+1'&gt;+1&lt;/button&gt;\n&lt;/&gt;;\nupdate = {\n'+1': state =&gt; state + 1,\n'-1': state =&gt; state - 1\n};\n}\nnew Counter().start(document.body);\n</code></pre> </p>"},{"location":"directive/#invoke-functions","title":"Invoke Functions","text":"<p>The $on directive can also invoke functions.</p> <p><pre><code>class Counter extends Component {\nstate = 0;\nview = state =&gt; &lt;div&gt;\n&lt;h1&gt;{state}&lt;/h1&gt;\n&lt;button $onclick={state=&gt;state-1}&gt;-1&lt;/button&gt;\n&lt;button $onclick={state=&gt;state+1}&gt;+1&lt;/button&gt;\n&lt;/div&gt;;\n}\nnew Counter().start(document.body);\n</code></pre> </p>"},{"location":"directive/#bind","title":"$bind","text":"<p>The $bind directive synchronizes the HTML input value to the state. See the $bind example below.</p> <p><pre><code>const state = '';\nconst view = state =&gt; &lt;div&gt;\n&lt;h1&gt;Hello {state}&lt;/h1&gt;\n&lt;input autofocus $bind /&gt;\n&lt;/div&gt;;\napp.start(document.body, state, view);\n</code></pre> </p> <p>Or, you can bind to the properties of the state.</p> <p><pre><code>const state = {\na: 1,\nb: 2,\nget c() {\nreturn this.a + this.b;\n}\n};\nconst view = ({a, b, c}) =&gt; &lt;&gt;\n&lt;input type=\"number\" $bind=\"a\" /&gt;\n&lt;input type=\"number\" $bind=\"b\" /&gt;\n&lt;p&gt;{a} + {b} = { c }&lt;/p&gt;\n&lt;/&gt;;\napp.start(document.body, state, view);\n</code></pre> </p>"},{"location":"directive/#custom-directive","title":"Custom directive","text":"<p>When AppRun is processing the JSX code, it publishes the $ event when it finds the custom attributes like $X. Thus, you can subscribe to the $ event to provide your directives.</p> <pre><code>app.on('$', ({key, props}) =&gt; {\nif (key === '$animation') {\nconst value = props[key];\nif (typeof value === 'string') {\nprops.class = \\`animated \\${value}\\`;\n    }\n  }\n});\n</code></pre>"},{"location":"directive/#animation-directive","title":"Animation directive","text":"<p>We can create the $animation directive to attach the animation classes from the animation library, animation.css. See the $animation example below.</p> <p><pre><code>// Animation Directive Using animate.css\napp.on('$', ({key, props}) =&gt; {\nif (key === '$animation') {\nconst value = props[key];\nif (typeof value === 'string') {\nprops.class = `animated ${value}`;\n}\n}\n});\n\nconst state = {\nanimation: true\n}\n\nconst start_animation = state =&gt; ({ animation: true })\nconst stop_animation = state =&gt; ({ animation: false })\n\nconst view = state =&gt; &lt;&gt;\n&lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css\"&gt;&lt;/link&gt;\n&lt;img $animation={state.animation &amp;&amp; 'bounce infinite'} src='../assets/logo.png' /&gt;\n&lt;div $animation='bounceInRight'&gt;\n&lt;button disabled={state.animation} $onclick={start_animation}&gt;start&lt;/button&gt;\n&lt;button disabled={!state.animation} $onclick={stop_animation}&gt;stop&lt;/button&gt;\n&lt;/div&gt;\n&lt;/&gt;\n\napp.start(document.body, state, view);\n</code></pre> </p>"},{"location":"directive/#form-validation","title":"Form Validation","text":"<p>HTML5 Constraint Validation API simplifies client-side validation. We can use basic validation by choosing the type attribute of input elements, such as email and URL. Or we can use the pattern attribute for validation using regular expression. Also, we can use the required, maxlength, min, and max attributes.</p> <p>We can create the $validation directive to display the validation results by setting and removing the class.</p> <p><pre><code>const validate = (e) =&gt; {\nconst element = e.target;\nelement.checkValidity();\nconsole.log(element.validity.valid);\nif (element.validity.valid) {\nelement.classList.remove('is-invalid');\n} else {\nelement.classList.add('is-invalid');\n}\n}\n\napp.on('$', ({ key, props }) =&gt; {\nif (key === '$validate') {\nconst event = props[key];\nprops['oninput'] = validate;\n}\n});\n\n\nconst signIn = (state, e) =&gt; {\ne.preventDefault();\nalert('form submitted')\n}\n\nconst view = ({name}) =&gt; &lt;&gt;\n&lt;style&gt;{`.is-invalid { border: 2px solid red; color: red }`}&lt;/style&gt;\n&lt;form autocomplete=\"off\" $onsubmit=\"signIn\"&gt;\n&lt;p&gt;\n&lt;label for=\"name\" autocomplete=\"off\"&gt;Enter an name (letters only): &lt;/label&gt;\n&lt;input $validate type=\"text\" name=\"name\" required pattern=\"[A-Za-z]+\"/&gt;\n&lt;/p&gt;\n&lt;p&gt;\n&lt;label for=\"email\" autocomplete=\"off\"&gt;Enter a email: &lt;/label&gt;\n&lt;input $validate type=\"email\" name=\"email\" required /&gt;\n&lt;/p&gt;\n&lt;p&gt;\n&lt;label for=\"url\" autocomplete=\"off\"&gt;Enter an URL: &lt;/label&gt;\n&lt;input $validate type=\"url\" name=\"url\" required /&gt;\n&lt;/p&gt;\n&lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n&lt;div&gt;{name}&lt;/div&gt;\n&lt;/&gt;;\n\napp.start(document.body, {}, view, {signIn});\n</code></pre> </p>"},{"location":"event-pubsub/","title":"Event Pub-Sub","text":"<p>Event publication and subscription, also known as event emitter, is a commonly used pattern in JavaScript programming.</p> <ul> <li>Publishing an event means raising an event for some other code to handle. Publishing an event is also referred to as firing an event or triggering an event.</li> <li>Subscribing an event means registering an event handler function to the event. The event handler function executes when the correspondent event</li> </ul> <p>At the core, AppRun is an event pub-sub system.</p>"},{"location":"event-pubsub/#event-life-cycle","title":"Event Life Cycle","text":"<p>When an AppRun event is published, the following steps take place:</p> <ol> <li>AppRun dispatches the events to the event handlers defined in the update along with the current state.</li> <li>The event handlers create a new state based on the current state.</li> <li>AppRun passes the new state to the view function.</li> <li>The view function creates HTML or a Virtual DOM.</li> <li>AppRun renders the HTML/Virtual DOM to the screen</li> <li>AppRun calls the optional rendered function to complete the AppRun event life cycle.</li> </ol> <p></p> <p>AppRun Event Life Cycle connects the state, view, and update (event handlers) together. Take a look at the Counter example again.</p> <p><pre><code>const state = 0;\nconst view = state =&gt; {\nreturn `&lt;div&gt;\n    &lt;h1&gt;${state}&lt;/h1&gt;\n    &lt;button onclick='app.run(\"-1\")'&gt;-1&lt;/button&gt;\n    &lt;button onclick='app.run(\"+1\")'&gt;+1&lt;/button&gt;\n  &lt;/div&gt;`;\n};\nconst update = {\n'+1': state =&gt; state + 1,\n'-1': state =&gt; state - 1\n};\napp.start(document.body, state, view, update);\n</code></pre> </p> <p>When one of the buttons is clicked, it publishes AppRun event +1 or -1. The event handlers increase or decrease the state and return a new state. The view function creates the virtual DOM using the new state. Finally, AppRun renders the virtual DOM.</p>"},{"location":"event-pubsub/#event-scope","title":"Event Scope","text":"<p>In AppRun global application mode, events are global events, which means that events are published and handled globally by all modules.</p> <p>In AppRun components, events are limited within the component's local scope. Local events are only available inside the components.</p> <p>Note</p> <p>app.run publishes global events this.run publishes local events</p>"},{"location":"event-pubsub/#event-directives","title":"Event Directives","text":"<p>In addition to using app.run and this.run for publishing events</p> <p>AppRun Directives provides syntax sugar to simplify event publishing.</p>"},{"location":"event-pubsub/#jsx-directives","title":"JSX Directives","text":"<p>The directives are special HTML attributes with names starting with $, such as $onclick. They are extensions to the JSX syntax to simplify the JSX or add extra features.</p> <p>We can use $onclick to simplify the syntax of publishing AppRun events from</p> <pre><code>&lt;button onclick={()=&gt;app.run('+1')}&gt;+1&lt;/button&gt;\n</code></pre> <p>to We use tuples for passing event parameters.</p> <pre><code>&lt;button $onclick={['add', +1]}&gt;+1&lt;/button&gt;\n</code></pre> <p>Also, the $onclick directive can call the event directly.</p> <p><pre><code>const add = count =&gt; count + 1;\nconst view = count =&gt; &lt;button $onclick={add}&gt;\nClicks: {count}\n&lt;/button&gt;;\napp.start(document.body, 0, view);\n</code></pre> </p> <p>You can see, because there are no events in this case, we don't need the update object anymore.</p>"},{"location":"event-pubsub/#lit-html-directive","title":"lit-html Directive","text":"<p>lit-html is the DOM rendering technology that lets us write HTML templates using string literals.</p> <p>Following the idea of using the JSX event directive what can we do similar thing with lit-html?</p> <p>The good news is that lit-html also has the directive concept to bring the event directive to lit-html. So the directive for lit-html is called run.</p> <p>The example below shows how to use the run directive to trigger AppRun events. Also, similar to the JSX event directives, the run directive can call the event lifecycle directly.</p> <p><pre><code>const add = (state, delta) =&gt; state + delta;\nconst view = state =&gt; {\nreturn html`&lt;div&gt;\n    &lt;h1&gt;${state}&lt;/h1&gt;\n      &lt;button @click=${run('add', -1)}&gt;-1&lt;/button&gt;\n      &lt;button @click=${run('add', +1)}&gt;+1&lt;/button&gt;\n    &lt;/div&gt;`;\n};\napp.start(document.body, 0, view, {add});\n</code></pre> </p> <p>The run directive will:</p> <ul> <li>Call the add function</li> <li>Call the view function</li> <li>Render the HTML element (document.body)</li> </ul>"},{"location":"event-pubsub/#asynchronous-events","title":"Asynchronous Events","text":"<p>In the service API-oriented applications, the state is created asynchronous operations. e.g., getting remote data from the server.</p> <p>It is easy to handle asynchronous operations in the AppRun event handlers. We only need to add the async keyword in front of the event handler and call the functions that return a Promise object with the await keyword.</p> <p><pre><code>const state = {};\nconst view = state =&gt; &lt;&gt;\n&lt;div&gt;&lt;button $onclick=\"fetchComic\"&gt;fetch ...&lt;/button&gt;&lt;/div&gt;\n{state.loading &amp;&amp; &lt;div&gt;loading ... &lt;/div&gt;}\n{state.comic &amp;&amp; &lt;img src={state.comic.url}/&gt;}\n&lt;/&gt;;\nconst update = {\n'loading': (state, loading) =&gt; ({...state, loading }),\n'fetchComic': async _ =&gt; {\napp.run('loading', true);\nconst response = await fetch('https://xkcd-imgs.herokuapp.com/');\nconst comic = await response.json();\nreturn {comic};\n}\n};\napp.start(document.body, state, view, update);\n</code></pre> </p>"},{"location":"event-pubsub/#use-events-for-everything","title":"Use Events for Everything","text":"<p>Web programming is event-driven. All we have to do is to convert DOM events to AppRun events to trigger the AppRun event life cycle.</p> <pre><code>DOM events =&gt; AppRun Events =&gt; (current state) =&gt; Update =&gt; (new state) =&gt; View =&gt; (HTML/Virtual DOM) =&gt; Render Web Page\n</code></pre> <p>Events are not only for handling user interactions. They are used for everything in AppRun.</p> <ul> <li>Routing is through events.</li> <li>Directives are through events.</li> </ul>"},{"location":"event-pubsub/#event-typing","title":"Event Typing","text":"<p>Events can be strongly typed using TypeScript Discriminated Unions. If you are interested, please read this post: strong-typing.</p> <p></p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide describes how to get up and running with AppRun in minutes.</p> <p>You can choose one of the following options:</p> <ol> <li>Use AppRun in the browser without any installation</li> <li>Use the npm create apprun-app to create a new AppRun project</li> <li>Create an AppRun Site for SSR and static site generation</li> </ol>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>AppRun is distributed on npm. To get it, run:</p> <pre><code>npm install apprun\n</code></pre> <p>You can use AppRun directly from the unpkg.com CDN:</p> <pre><code>&lt;script src=\"https://unpkg.com/apprun/dist/apprun-html.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\nconst view = state =&gt; `&lt;div&gt;${state}&lt;/div&gt;`;\napp.start(document.body, 'hello AppRun', view);\n&lt;/script&gt;\n</code></pre> <p>Or, use the ESM version: <pre><code>&lt;script type=\"module\"&gt;\nimport { app } from 'https://unpkg.com/apprun/dist/apprun-html.esm.js';\nconst view = state =&gt; `&lt;div&gt;${state}&lt;/div&gt;`;\napp.start(document.body, 'hello AppRun ESM', view);\n&lt;/script&gt;\n</code></pre></p>"},{"location":"notebooks/","title":"Notebooks","text":"<p>A notebook interface (also called a computational notebook) is a virtual notebook environment used for literate programming -- wikipedia</p> <p>Notebooks have a series of cells containing text, code, and visualizations.</p>"},{"location":"notebooks/#observable","title":"Observable","text":"<p>Observable is a website for online JavaScript notebooks.</p> <p>You can use AppRun on the Observable site by following the steps:</p> <ol> <li>Import app, html from @yysun/apprun</li> <li>Create the state, view, and update</li> <li>Create a div</li> <li>Start an app on the div</li> </ol> <p></p> <p>Visit https://observablehq.com/@yysun?tab=notebooks for more examples.</p>"},{"location":"notebooks/#net-interactive-notebooks","title":".NET Interactive Notebooks","text":"<p>With the .NET Interactive Notebooks extension for Visual Studio Code installed, we can run the .NET Interactive notebooks in Visual Studio Code. The .NET Interactive notebooks support C#, F#, HTML, JavaScript, Power Shell, and even SQL.</p> <p>You use AppRun in the .NET Interactive notebooks by following the steps:</p> <ol> <li>Import AppRun</li> <li>Create a div</li> <li>Create the state, view, and update</li> <li>Start an app on the div</li> </ol> <p>Download the sample notebook.</p> <p></p>"},{"location":"react/","title":"Use AppRun with React","text":"<p>React is a popular JavaScript library for building user interfaces. Using AppRun and React in conjunction is one of the best ways to build a web app.</p> <p>You can use AppRun with React in one of the two ways.</p> <ul> <li>Use AppRun components in React apps</li> <li>Use React Virtual DOM in AppRun apps</li> </ul>"},{"location":"react/#use-apprun-components","title":"Use AppRun Components","text":"<p>It only takes one line of code to use AppRun components in React.</p> <p>Let's use the code from the React Hooks Doc as an example.</p> <pre><code>import React, { useState } from 'react';\n\nfunction Example() {\n// Declare a new state variable, which we'll call \"count\"\nconst [count, setCount] = useState(0);\n\nreturn (\n&lt;div&gt;\n&lt;p&gt;You clicked {count} times&lt;/p&gt;\n&lt;button onClick={() =&gt; setCount(count + 1)}&gt;\nClick me\n&lt;/button&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> <p>The same app using the AppRun looks like below.</p> <p><pre><code>class MyComponent extends Component {\nstate = 0;\nview = count =&gt; &lt;div&gt;\n&lt;p&gt;You clicked {count} times&lt;/p&gt;\n&lt;button onclick={()=&gt;this.run('add')}&gt;\nClick me\n&lt;/button&gt;\n&lt;/div&gt;;\nupdate  = {\nadd: state =&gt; state + 1\n};\n}\nnew MyComponent().start(document.body);\n</code></pre> </p> <p>To use the AppRun component in React is very easy. All you need to do is converting the AppRun component to a React component by calling the toReact function.</p> <pre><code>import { Component } from 'apprun/esm/component';\nimport toReact from 'apprun/react';\n\nclass MyComponent extends Component {\nstate = 0;\nview = count =&gt; &lt;div&gt;\n&lt;p&gt;You clicked {count} times&lt;/p&gt;\n&lt;button onClick={()=&gt;this.run('add')}&gt;\nClick me\n&lt;/button&gt;\n&lt;/div&gt;;\nupdate  = {\nadd: state =&gt; state + 1\n};\n}\n\nconst App = toReact(MyComponent);\nexport default App;\n</code></pre> <p>Note</p> <p>The React VDOM uses JSX. AppRun VDOM also uses JSX. They are similar. However, React VDOM does not have directives. So you cannot use the AppRun $onclick directive. Instead, you need to use the React onClick attribute.</p> <p>Now, with just one line conversion to React component, we successfully used AppRun in React apps. Thus, we have the elm-inspired AppRun architecture in the React apps.</p> <p>You can visit https://github.com/yysun-apprun to see an example React project created by the Create React App Cli that uses AppRun components.</p>"},{"location":"react/#use-react-vdom","title":"Use React VDOM","text":"<p>On the other hand, since we can use any Virtual DOM (VDOM) technology in AppRun apps, including the one from React, lets' use the React VDOM in AppRun apps.</p> <p>It also just needs one line of code to replace the app.render function with the ReactDOM.render function.</p> <pre><code>app.render = (el, vdom) =&gt; ReactDOM.render(vdom, el);\n</code></pre> <p>Below is the AppRun app that uses React VDOM.</p> <pre><code>import app from 'apprun';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\napp.render = (el, vdom) =&gt; ReactDOM.render(vdom, el);\n\nclass MyComponent extends Component {\nstate = 0;\nview = count =&gt; &lt;div&gt;\n&lt;p&gt;You clicked {count} times&lt;/p&gt;\n&lt;button onClick={()=&gt;this.run('add')}&gt;\nClick me\n&lt;/button&gt;\n&lt;/div&gt;;\nupdate  = {\nadd: state =&gt; state + 1\n};\n}\nnew MyComponent().start(document.body);\n</code></pre> <p>Again, you must remember to use the React onClick attribute instead of the AppRun $onclick directive.</p>"},{"location":"react/#conclusion","title":"Conclusion","text":"<p>If you prefer to use React as the main framework, you can use AppRun to get the elm-inspired architecture. If you choose to use AppRun, you can also use the React Virtual DOM for rendering. You get the best of both worlds.</p>"},{"location":"reactivity/","title":"Reactivity in AppRun","text":""},{"location":"reactivity/#introduction","title":"Introduction","text":"<p>Reactivity has been a hot buzzword for modern JavaScript UI frameworks in the past few years. Angular, Vue, and Svelte all have reactivity built-in. They are famous and popular because of their reactivity features.</p> <p>Reactivity means that the changed application state will automatically reflect in the DOM.</p> <p>Don't be confuse the reactivity with another buzz word, reactive programming. Reactive programming is programming with asynchronous data streams. I will have another post to explain reactive programming.</p> <p>Reactivity is related to the data binding concept. Data binding is the process that establishes a connection between the application state and the application UI. There are two major types of data binding: one-way bing and two-binding.</p> <ul> <li> <p>One-way binding means that changes in the application state cause changes to the application UI.</p> </li> <li> <p>Two-way binding means that either application state or application UI changes (for example, with input elements) automatically update the other.</p> </li> </ul> <p>The reactivity also applies to the state object properties. E.g., if there is a person object with the properties of first-name, last-name, and full-name, we want the full-name property to be reactive to the other two name properties.</p> <p>With the reactivity concept clarified, let's see how we can have reactivity in AppRun.</p>"},{"location":"reactivity/#one-way","title":"One-Way","text":"<p>Many frameworks use the concept of \"variable assignments trigger UI updates.\" E.g., Vue wires up the application state objects with a change detection mechanism to become a view model or Proxy. Then you can modify the view model to trigger the UI update. Svelte has a compiler to inject change detection around your application state object. You can also modify the state to trigger the UI update.</p> <p>Unlike other frameworks, AppRun uses the events to trigger UI updates following the event-driven web programming model naturally. During an AppRun event lifecycle:</p> <ul> <li>AppRun gives you the current state for you to create a new state</li> <li>AppRun calls your view function to create a virtual</li> <li>AppRun renders the virtual DOM if it is not null.</li> </ul> <p>You can feel the Hollywood Principle (Don't call us. We call you.) here, which usually means things are loosely coupled. We provide code pieces. The framework calls them when needed.</p> <p>In the example below, the AppRun $onclick directive calls the event handler, then calls the view function, and then renders the virtual DOM.</p> <p><pre><code>const view = state =&gt; &lt;div&gt;\n&lt;h1&gt;{state}&lt;/h1&gt;\n&lt;button $onclick={state =&gt; state - 1}&gt;+1&lt;/button&gt;\n&lt;button $onclick={state =&gt; state + 1}&gt;+1&lt;/button&gt;\n&lt;/div&gt;;\n\napp.start(document.body, 0, view)\n</code></pre> </p>"},{"location":"reactivity/#two-way-binding","title":"Two-Way Binding","text":"<p>AppRun $bind directive can update the state properties automatically when used with the input elements and the textarea element. It looks similar to Angular's ngModel, Vue' v-model, and Svelte's bind:value syntax. However, Angular, Vue, and Svelte have invented their own proprietary template language/syntax that you need to learn. AppRun uses the JSX that React also uses.</p> <p><pre><code>const view = state =&gt; &lt;&gt;\n&lt;div&gt;{state.text}&lt;/div&gt;\n&lt;input $bind=\"text\" placeholder=\"type something here ...\"/&gt;\n&lt;/&gt;\napp.start(document.body, {}, view)\n</code></pre> </p>"},{"location":"reactivity/#reactive-state","title":"Reactive State","text":"<p>The state properties' reactivity is not a problem that the UI frameworks are to solve. But if the UI frameworks wrap or change the original state objects, they have to solve the reactivity problems. E.g., Vue uses the computed object. Svelte uses the reactive-declarations, the famous $: sign.</p>"},{"location":"reactivity/#property-getter","title":"Property Getter","text":"<p>Like in languages like Java and C#, JavaScript has object property getter, which we can use to compute the property values dynamically.</p> <pre><code>const state = ({\na: 1,\nb: 2,\nget c() {\nreturn this.a + this.b;\n}\n})\n</code></pre> <p>Binding to the state object properties is straightforward.</p> <p><pre><code>// Reactivity - getter\nconst state = {\na: 1,\nb: 2,\nget c() {\nreturn this.a + this.b;\n}\n};\nconst view = ({a, b, c}) =&gt; &lt;&gt;\n&lt;input type=\"number\" $bind=\"a\" /&gt;\n&lt;input type=\"number\" $bind=\"b\" /&gt;\n&lt;p&gt;{a} + {b} = { c }&lt;/p&gt;\n&lt;/&gt;;\napp.start(document.body, state, view);\n</code></pre> </p>"},{"location":"reactivity/#es2015-proxy","title":"ES2015 Proxy","text":"<p>The Proxy is used to define custom behavior for fundamental operations (e.g., property lookup, assignment, enumeration, function invocation, etc.).</p> <p>Proxies enable you to intercept and customize operations performed on objects (such as getting properties). They are a metaprogramming feature. - from Metaprogramming with proxies</p> <p>To create a Proxy, we create a handler first. Then, we combine the object proxied with the handler.</p> <pre><code>const handler = ({\nget: (target, name) =&gt; {\nconst text = target.text || '';\nswitch (name) {\ncase 'text': return target.text;\ncase 'characters': return text.replace(/\\s/g, '').length;\ncase 'words': return !text ? 0 : text.split(/\\s/).length;\ncase 'lines': return text.split('\\n').length;\ndefault: return null\n}\n}\n})\n\nconst state = new Proxy(\n{ text: \"let's count\" },\nhandler\n)\n</code></pre> <p>Proxy has almost no barrier to use. Anywhere accepts objects can use Proxy. For example, AppRun can take a state with Proxy.</p> <p><pre><code>// Reactivity - Proxy\nconst handler = {\nget: (target, name) =&gt; {\nconst text = target.text || '';\nswitch (name) {\ncase 'text': return target.text;\ncase 'characters': return text.replace(/\\s/g, '').length;\ncase 'words': return !text ? 0 : text.split(/\\s/).length;\ncase 'lines': return text.split('\\n').length;\ndefault: return null\n}\n}\n};\nconst state = new Proxy(\n{ text: \"let's count\" },\nhandler\n);\nconst view = state =&gt; &lt;div&gt;\n&lt;textarea rows=\"10\" cols=\"50\" $bind=\"text\"&gt;&lt;/textarea&gt;\n&lt;div&gt;chars: {state.characters} words: {state.words} lines: {state.lines}&lt;/div&gt;\n&lt;pre&gt;{state.text}&lt;/pre&gt;\n&lt;/div&gt;;\napp.start(document.body, state, view);\n</code></pre> </p> <p>I like Proxy because it takes the property value calculation logic out of the state objects. As a result, the proxy handler is much easier to test and maintain. On the other hand, the state objects stay lean. I want the state to act like the data transfer object (DTO) in traditional multi-layered application architecture, where the DTO is an object that carries data between logical and physical layers.</p>"},{"location":"reactivity/#conclusion","title":"Conclusion","text":"<p>AppRun has full reactivity support that provides us the one-way and two-way data binding and the reactive state. Thus, we only need to use the native JavaScript/TypeScript features. Furthermore, AppRun does not require you to learn a new language or a new templating syntax.</p>"},{"location":"resources/","title":"Books and Resources","text":""},{"location":"resources/#book-about-apprun","title":"Book About AppRun","text":"<p>AppRun book published by Apress.</p> <p></p> <p>Order from Amazon</p>"},{"location":"resources/#blogs-and-demos","title":"Blogs and Demos","text":"<ul> <li>https://dev.to/@yysun</li> <li>https://glitch.com/@yysun</li> <li>https://observablehq.com/@yysun</li> <li>https://apprun.js.org/#play</li> </ul>"},{"location":"resources/#posts","title":"Posts","text":"<ul> <li> <p>All the Ways to Make a Web Component - May 2021 Update</p> </li> <li> <p>A Real-World Comparison of Front-End Frameworks with Benchmarks 2019 Update (2019)</p> </li> <li> <p>A Real-World Comparison of Front-End Frameworks with Benchmarks 2018 Update (2018)</p> </li> <li> <p>A Real-World Comparison of Front-End Frameworks with Benchmarks (2017)</p> </li> </ul>"},{"location":"resources/#performance-benchmark","title":"Performance Benchmark","text":"<p>AppRun has also joined the js-framework-benchmark project. You can see its performance results compared to other frameworks and libraries.</p>"},{"location":"routing/","title":"Routing","text":"<p>Routing in AppRun is event-driven. Therefore, handling routing using events is straightforward.</p>"},{"location":"routing/#routing-event","title":"Routing Event","text":"<p>AppRun router detects the hash changes in the URL (by listening to the window's onpopstate event) and publishes the AppRun events using the hash as the event name. Components subscribe to the routing events.</p> <p>E.g., when the URL in the browser address bar becomes http://..../#counter, it triggers the #counter event. The Counter component reacts to the #counter and renders itself to the screen.</p> <p>That's it. There is no other code for routing.</p>"},{"location":"routing/#unhandled-routes","title":"Unhandled Routes","text":"<p>When the AppRun router triggers an AppRun event with no listener for the route, the router will automatically generate a ROUTER_404_EVENT AppRun event giving the application a chance to degrade gracefully by, perhaps, displaying a 404 page. To bind to this event, here are a few examples of things you can do:</p> <pre><code>import app, { Component, ROUTER_404_EVENT } from 'apprun';\n\n// Generate an error message when there's no handler for a URL.\napp.on(ROUTER_404_EVENT, (url, ..._rest) =&gt; console.error('No event handler for', url));\n\n// Alternatively, create a component that will display a message.\nclass NoRouteComponent extends Component {\nstate = {};\n\nview = (state) =&gt; {\nreturn &lt;&gt;&lt;h1&gt;PAGE NOT FOUND! WE SUCK!&lt;/h1&gt;&lt;/&gt;\n}\n\n// Handle the \"no route found\" events with this component\nupdate = {\n[ROUTER_404_EVENT]: state =&gt; state\n}\n}\n\nnew NoRouteComponent().mount( on some element );\n</code></pre>"},{"location":"routing/#pretty-links","title":"Pretty Links","text":"<p>If you would prefer to use pretty links (i.e., non-hash links) and have HTML5 browser history, then you can implement a new router yourself or use the pretty router from the apprun-router package. This router also handles unknown routes via the ROUTER_404_EVENT and has a few other goodies to make life easier.</p>"},{"location":"routing/#replacing-default-router","title":"Replacing Default Router","text":"<p>Replacing AppRun's default router couldn't be easier. Just overwrite app.route, and you're off to the races. You'll also want to bind to the popstate events and trigger the first URL event (via the DOMContentLoaded event handler in the code example below):</p> <pre><code>// A simplistic but not great router.\nfunction newRouter(url: string) {\napp.run(url);\napp.run(ROUTER_EVENT, url);\n}\n\n// Kick off the first URL event when the DOM is loaded.\ndocument.addEventListener(\"DOMContentLoaded\", () =&gt; {\nwindow.onpopstate = app[\"route\"](location.pathname, true);\nnewRouter(location.pathname);\n});\n\napp[\"route\"] = newRouter;\n</code></pre>"},{"location":"showcase/","title":"Showcase","text":"<p>This page shows a few public applications built with AppRun.</p>"},{"location":"showcase/#conduit","title":"Conduit","text":"<ul> <li>Project: https://github.com/gothinkster/apprun-realworld-example-app</li> </ul> conduit conduit          An interactive learning project from Thinkster. Code &amp; design licensed         under MIT."},{"location":"showcase/#hacker-news-pwa","title":"Hacker-News PWA","text":"<ul> <li>Project: https://github.com/yysun/apprun-hn</li> </ul> AppRun - HN"},{"location":"showcase/#todomvc","title":"TodoMVC","text":"<ul> <li>Author: https://github.com/samsondav</li> <li>Project: https://github.com/samsondav/todomvc-apprun</li> </ul> <p>Double-click to edit a todo</p> <p>Created by Sam Davies</p> <p>Powered by AppRunJS</p> <p>Part of TodoMVC</p> <p></p>"},{"location":"spa/","title":"Single Page Apps","text":""},{"location":"spa/#create-project","title":"Create Project","text":"<p>You can initialize a project using the <code>npm create apprun-app</code> command and select the <code>Single Page App</code> template.</p> <pre><code>npm create apprun-app [my-app]\n</code></pre>"},{"location":"spa/#spa-architecture","title":"SPA Architecture","text":"<p>AppRun SPA usually includes an HTML file, the main program that renders the screen layout, and page components that render the pages.</p> <pre><code>.\n\u251c\u2500 dist/\n\u251c\u2500 src/\n\u2502  \u251c\u2500 About.tsx\n\u2502  \u251c\u2500 Contact.tsx\n\u2502  \u251c\u2500 Home.tsx\n\u2502  \u251c\u2500 Layour.tsx\n\u2502  \u2514\u2500 main.tsx\n\u2514\u2500 index.html\n</code></pre> <p>Example of the <code>index.html</code> file:</p> <pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"&gt;\n  &lt;title&gt;AppRun SPA&lt;/title&gt;\n&lt;body&gt;\n  &lt;div id=\"main\"&gt;&lt;/div&gt;\n  &lt;script src=\"dist/main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Example of the <code>main.tsx</code> file:</p> <pre><code>import Home from './Home';\nimport About from './About';\nimport Contact from './Contact';\nimport Layout from './Layout';\n\nnew Layout().start(document.getElementById('main'));\nconst element = document.getElementById('my-app');\nnew Home().start(element);\nnew About().mount(element);\nnew Contact().mount(element);\n</code></pre> <p></p> <p>AppRun SPA uses the events to route user interaction to the components. Treating routing like other web events is the smart idea of AppRun. All web events are unified under the event pub-sub pattern. Routing does not require special treatment.</p>"},{"location":"spa/#dynamic-component-loading","title":"Dynamic Component Loading","text":"<p>AppRun components are modularized using the ECMAScript module standard. We can import the modules statically and dynamically. We can also use the native module from modern browsers.</p> <pre><code>import app from 'apprun';\nimport Layout from './Layout';\n\nnew Layout().start(document.getElementById('main'));\n\napp.on('#,#home', async () =&gt; {\nconst module = await import('./home');\nnew module.default().mount(element);\n});\n\napp.on('#about', async () =&gt; {\nconst module = await import('./about');\nnew module.default().mount(element);\n});\n\napp.on('#contact', async () =&gt; {\nconst module = await import('./contact');\nnew module.default().mount(element);\n})\n</code></pre>"},{"location":"ssr/","title":"Server-Side Rendering","text":"<p>AppRun is a front-end library for developing SPA. It also supports rendering the SPAs on the server-side, just like other frameworks. Furthermore, it also allows us to make existing traditional server-side rendered applications into SPAs. Thus, AppRun can make many existing applications built using the server-side model-view-control (MVC) architecture become SPAs quickly.</p>"},{"location":"ssr/#spa-to-ssr","title":"SPA to SSR","text":"<p>AppRun is isomorphic/universal. AppRun components can render on the client-side and on the server-side using the AppRun server-side view engine.</p> <p>Included in the SSR AppRun application example, there are:</p> <ul> <li>The express.js server application (server.ts),</li> <li>The site layout (components/layout.tsx),</li> <li>The AppRun components (components/*.tsx)</li> <li>The client-side application (/public/spa.js).</li> </ul> <p>You can run the application on @glitch, https://apprun-ssr.glitch.me.</p>"},{"location":"ssr/#ssr-to-spa","title":"SSR to SPA","text":"<p>Please read this post, Making ASP.NET Core MVC Apps into Single Page Apps using AppRun</p> <p></p>"},{"location":"state-management/","title":"State Management","text":"<p>The State, one of three main parts of the AppRun architecture, plays an essential role in the AppRun event lifecycle. It is the equivalent of the Model of Elm architecture. Elm defines the Model as the application state. Modal and State are two names of the same thing. Therefore, they are interchangeable in the AppRun architecture. Most of the time, we use the term State in AppRun.</p> <p>The State is the application state at any given time of your application. The State is the data flow between Update and View. It acts as the data transfer object (DTO) in traditional multilayered application architecture, where the DTO is an object that carries data between logical and physical layers.</p> <p>The benefit of using events and DTO like the state is that there are no dependencies between the view and update (event handlers). Thus, it makes the AppRun applications easier to develop, test, and maintain. You can get more information about unit testing later.</p>"},{"location":"state-management/#initial-state","title":"Initial State","text":"<p>We only need to define the initial state. The initial state is an immutable constant. AppRun manages the state through the event lifecycle.</p> <p></p>"},{"location":"state-management/#asynchronous-state","title":"Asynchronous State","text":"<p>We can define the initial state as a function. And even an asynchronous function to initialize the state.</p> <p><pre><code>// Init State as an Async Function\nconst state = async () =&gt; {\nconst response = await fetch('https://xkcd-imgs.herokuapp.com/');\nconst comic = await response.json();\nreturn { comic };\n};\nconst view = state =&gt; &lt;&gt;\n{ state.comic &amp;&amp; &lt;img src={ state.comic.url } /&gt;}\n&lt;/&gt;;\napp.start(document.body, state, view);\n</code></pre> </p>"},{"location":"state-management/#state-history","title":"State History","text":"<p>The state can be stored in state history by AppRun. Once the state history is enabled, we can travel through the history back and forth to get the previous and next state. See the sample below.</p> <p><pre><code>const state = [];\n\nconst Counter = ({num, idx}) =&gt; (\n&lt;div&gt;\n&lt;h1&gt;{num}&lt;/h1&gt;\n&lt;button onclick={() =&gt; app.run(\"-1\", idx)}&gt;-1&lt;/button&gt;\n&lt;button onclick={() =&gt; app.run(\"+1\", idx)}&gt;+1&lt;/button&gt;\n&lt;button onclick={() =&gt; app.run(\"remove-counter\", idx)}&gt;x&lt;/button&gt;\n&lt;/div&gt;\n);\n\nconst CounterList = ({counters}) =&gt; counters.map((num, idx) =&gt;\n&lt;Counter num={num} idx={idx} /&gt;\n);\n\nconst view = (state) =&gt; {\nreturn (\n&lt;div&gt;\n&lt;div&gt;\n&lt;button onclick={() =&gt; app.run(\"history-prev\")}&gt; &amp;lt;&amp;lt; &lt;/button&gt;\n&lt;button onclick={() =&gt; app.run(\"history-next\")}&gt; &amp;gt;&amp;gt; &lt;/button&gt;\n&lt;button onclick={() =&gt; app.run(\"add-counter\")}&gt;add counter&lt;/button&gt;\n&lt;button onclick={() =&gt; app.run(\"remove-counter\", state.length-1)}\ndisabled={state.length &lt;= 0}&gt;remove counter&lt;/button&gt;\n&lt;/div&gt;\n&lt;br/&gt;\n&lt;CounterList counters={state} /&gt;\n&lt;/div&gt;);\n};\n\nconst update = {\n'add-counter': (state) =&gt; [...state, 0],\n'remove-counter': (state, idx) =&gt; [\n...state.slice(0, idx),\n...state.slice(idx + 1)\n],\n'+1': (state, idx) =&gt; [\n...state.slice(0, idx),\nstate[idx] + 1,\n...state.slice(idx + 1)\n],\n'-1': (state, idx) =&gt; [\n...state.slice(0, idx),\nstate[idx] - 1,\n...state.slice(idx + 1)\n]\n};\n\napp.start(document.body, state, view, update, {history: true});\n</code></pre> </p> <p>Although it is effortless to enable the AppRun state history, the caveat must be immutable. Because the AppRun state history stores the references to the states, if we have modified the state directly, each state stored in the state history refers to the same state, which is always the value of the last change. Thus, the time travel back and forward will not work. Therefore, the fundamental concept of using state history is to make the state immutable.</p>"},{"location":"strong-typing/","title":"Strong Typing","text":"<p>From the AppRun architecture and AppRun event life cycle, we can see two places that require strong typing: state and event names.</p> <ul> <li>The initial state and the state passed between the view function and event handlers</li> <li>The event names for publishing and subscribing to Apprun events</li> </ul> <p></p>"},{"location":"strong-typing/#strong-typing-of-state","title":"Strong Typing of\u00a0State","text":"<p>The state is used in the view function and in the update(event handlers). We can make the state strong typed in the view function and in the update.</p>"},{"location":"strong-typing/#typed-view","title":"Typed View","text":"<p>First, we can make the state used in the view strongly typed by importing the View type from AppRun and applying it to the view function.</p> <pre><code>import { app, View } from 'apprun';\nconst view: View&lt;number&gt; =&gt; state =&gt; &lt;div&gt;...&lt;/div&gt;\n</code></pre> <p>The View type imported from AppRun is a generic type. It makes the view function into a generic function, which let us define the type of its parameters. E.g., we define the view function to be View, TypeScript recognizes the state parameter of the view function is a number."},{"location":"strong-typing/#typed-update","title":"Typed Update","text":"<p>Next, let's import the Update type from AppRun and apply it to the update object.</p> <pre><code>import { app, View, Update } from 'apprun';\nconst update: Update&lt;number&gt; = { ... }\n</code></pre> <p>The Update type imported from AppRun is also generic. It makes the event handlers in the update object into generic functions. TypeScript recognizes the state parameter of the event handler functions as are number.</p> <p></p>"},{"location":"strong-typing/#typed-application","title":"Typed Application","text":"<p>Finally, let's make the application strongly typed. The app.start is a generic function already. If we give the app.start function a type, E.g., number, it means the state of the application is number, the view of the application is View and the update of the application is Update. <pre><code>app.start&lt;number&gt;( ... )\n</code></pre> <p>If the type of state does not match the types assigned to the app.start function, TypeScript catches the type error.</p> <p></p> <p>If the type of the view function does not match the types assigned to the app.start function, TypeScript catches the type error.</p> <p></p> <p>If the type of the update object does not match the type assigned to the app.start function, TypeScript catches the type error.</p> <p></p> <p>So far, e have made the strongly typed state to the view function, the event handlers in the update object, and the application. Next, we will move to make strongly typed events.</p>"},{"location":"strong-typing/#strong-typing-of-events","title":"Strong Typing of\u00a0Events","text":"<p>AppRun update object is a named collection or dictionary of the event handlers. The event names are strings, such as +1 and -1. They are not typed, not checked by the compiler, and not IDE friendly. Instead, we can use the TypeScript enum to define the event names.</p>"},{"location":"strong-typing/#enum-of-event-names","title":"Enum of Event\u00a0Names","text":"<p>We define the Events enum and use it in the view functions and the update object.</p> <pre><code>enum Events { inc = '+1', dec = '-1' }\n</code></pre> <p></p> <p>You can see when we type 'Events.', Visual Studio code provides the intelliSense to help us typing. However, you can also see that the string +0 is still allowed in the update object. It is because the object index can only be a number or string. Or as long as a number or string is used, the compiler is happy and has no more type checking.</p>"},{"location":"strong-typing/#update-tuple","title":"Update Tuple","text":"<p>The update can be an array of tuples for defining AppRun event handlers.</p> <p></p> <p>The event handler tuple has two fields: the event name and the event handler function.</p> <p>We can use two advanced TypeScript types the tuple: union type and string literal type, to create so call discriminated union. For more information about union type, string literal type, and discriminated union, please refer to the TypeScript handbook.</p>"},{"location":"strong-typing/#discriminated-union-typed-event-names","title":"Discriminated Union Typed Event\u00a0Names","text":"<p>First, we define a union type called Events, which is made out of two string literal types, -1 and +1.</p> <pre><code>type Events = '-1' | '+1';\n</code></pre> <p>Then, we use the Events type as the second generic of the Update type imported from AppRun and apply it to the update tuple.</p> <pre><code>const update: Update&lt;number, Events&gt; = [ ... ]\n</code></pre> <p>The event names are strongly typed. TypeScript can even provide code auto-completion (IntelliSense) to hint at the event names.</p> <p></p> <p>If the event name is not one of the strings defined in the Events type, TypeScript catches the error.</p> <p></p>"},{"location":"strong-typing/#typed-events-in-view","title":"Typed Events in\u00a0View","text":"<p>To make the event names in the view function strongly type, we need to make the event names of the application strongly type first. We can add the Events type to the app.start_ the generic function.</p> <pre><code>app.start&lt;number, Events&gt;(...)\n</code></pre> <p>It makes the application only can trigger the events that are defined in the Events type. Because we have made the event names strongly typed TypeScript provides intelliSense to the event names of the application.</p> <p></p> <p>TypeScript also catches the event name errors in the view function.</p> <p></p> <p>So far, we have accomplished strong typing for the AppRun global application. Next, we will implement strong typing for AppRun Components.</p>"},{"location":"strong-typing/#strong-typing-of-component","title":"Strong Typing of Component","text":"<p>AppRun Component is like a scoped AppRun application. It also has three parts: state, view, and update.</p> <p>AppRun Component is a generic class. We create our components by extending the AppRun Component class. We can add the state type and events type to the Component class, as well as to the view function, and update the tuple to make the component strongly typed so that TypeScript can provide IntelliSense and type validation while we are coding.</p> <p></p>"},{"location":"strong-typing/#typed-event-decorator","title":"Typed Event Decorator","text":"<p>The AppRun @on decorator makes a function in the component class to be an event handler. The @on decorator is also generic. When we add the event type to the @on the decorator, TypeScript recognizes and enforces the event names to be the event type.</p> <p></p>"},{"location":"strong-typing/#typed-on-directive","title":"Typed $on Directive","text":"<p>The AppRun directive is a syntax sugar for JSX. The $on directive is helpful for publishing DOM events to AppRun events. The $on directive can be strongly typed.</p> <p></p>"},{"location":"strong-typing/#conclusion","title":"Conclusion","text":"<p>Thanks to TypeScript, we can make AppRun application strong-typed.</p>"},{"location":"svg/","title":"SVG","text":""},{"location":"svg/#create-svg","title":"Create SVG","text":"<p>You can create SVG using JSX or lit-HTML. For example, below is a reimplementation of a snabbdom example by Jon Kleiser (@jkleiser).</p>"},{"location":"svg/#svg-use-jsx","title":"SVG use JSX","text":"<p><pre><code>const style=`\nsvg {\n  display: block;\n  margin-bottom: 10px;\n  border: 1px solid gray;\n}\ng#carousel {\n  -webkit-transition: -webkit-transform 1s ease;\n  transition: transform 1s ease;\n}\npolygon {\n  stroke: #808000;\n  transition: fill 0.5s linear;\n}\npolygon#yellow {\n  fill: rgba(255,255,0,0.4);\n}\npolygon#yellow:hover, polygon#yellow:active {\n  fill: yellow;\n}\npolygon#green {\n  fill: rgba(0,128,0,0.4);\n}\npolygon#green:hover, polygon#green:active {\n  fill: green;\n}\npolygon#magenta {\n  fill: rgba(255,0,255,0.4);\n}\npolygon#magenta:hover, polygon#magenta:active {\n  fill: magenta;\n}\npolygon#red {\n  fill: rgba(255,0,0,0.4);\n}\npolygon#red:hover, polygon#red:active {\n  fill: red;\n}\npolygon#cyan {\n  fill: rgba(0,255,255,0.4);\n}\npolygon#cyan:hover, polygon#cyan:active {\n  fill: cyan;\n}\npolygon#blue {\n  fill: rgba(0,0,255,0.4);\n}\npolygon#blue:hover, polygon#blue:active {\n  fill: blue;\n}\n`\nconst triangles = [\n{id: \"yellow\", rot: 0},\n{id: \"green\", rot: 60},\n{id: \"magenta\", rot: 120},\n{id: \"red\", rot: 180},\n{id: \"cyan\", rot: 240},\n{id: \"blue\", rot: 300}\n];\n\nclass SvgComponent extends Component {\nstate = 0;\n\nview = state =&gt; {\nconst transform = \"rotate(\" + state + \"deg)\";\nreturn &lt;div className=\"view\"&gt;\n&lt;style&gt;{style}&lt;/style&gt;\n&lt;svg width=\"380\" height=\"380\" viewBox=\"-190,-190,380,380\"&gt;\n&lt;g id=\"carousel\" style={{transform}}&gt;\n{triangles.map(t =&gt;\n&lt;polygon id={t.id}\npoints=\"-50,-88 0,-175 50,-88\"\ntransform={`rotate(${t.rot})`}\nstroke-width=\"3\" /&gt;\n)}\n&lt;/g&gt;\n&lt;/svg&gt;\n&lt;button $onclick=\"rot+60\"&gt;Rotate Clockwise&lt;/button&gt;\n&lt;button $onclick=\"rot-60\"&gt;Rotate Anticlockwise&lt;/button&gt;\n&lt;button $onclick=\"reset\"&gt;Reset&lt;/button&gt;\n&lt;/div&gt;\n};\n\nupdate = {\n\"rot+60\": state =&gt; state + 60,\n\"rot-60\": state =&gt; state - 60,\n\"reset\": state =&gt; 0,\n};\n}\nnew SvgComponent().start(document.body);\n</code></pre> </p>"},{"location":"svg/#svg-use-lit-html","title":"SVG use lit-HTML","text":"<p><pre><code>const style=`\nsvg {\n  display: block;\n  margin-bottom: 10px;\n  border: 1px solid gray;\n}\ng#carousel {\n  -webkit-transition: -webkit-transform 1s ease;\n  transition: transform 1s ease;\n}\npolygon {\n  stroke: #808000;\n  transition: fill 0.5s linear;\n}\npolygon#yellow {\n  fill: rgba(255,255,0,0.4);\n}\npolygon#yellow:hover, polygon#yellow:active {\n  fill: yellow;\n}\npolygon#green {\n  fill: rgba(0,128,0,0.4);\n}\npolygon#green:hover, polygon#green:active {\n  fill: green;\n}\npolygon#magenta {\n  fill: rgba(255,0,255,0.4);\n}\npolygon#magenta:hover, polygon#magenta:active {\n  fill: magenta;\n}\npolygon#red {\n  fill: rgba(255,0,0,0.4);\n}\npolygon#red:hover, polygon#red:active {\n  fill: red;\n}\npolygon#cyan {\n  fill: rgba(0,255,255,0.4);\n}\npolygon#cyan:hover, polygon#cyan:active {\n  fill: cyan;\n}\npolygon#blue {\n  fill: rgba(0,0,255,0.4);\n}\npolygon#blue:hover, polygon#blue:active {\n  fill: blue;\n}\n`\nconst triangles = [\n{id: \"yellow\", rot: 0},\n{id: \"green\", rot: 60},\n{id: \"magenta\", rot: 120},\n{id: \"red\", rot: 180},\n{id: \"cyan\", rot: 240},\n{id: \"blue\", rot: 300}\n];\n\nclass SvgComponent extends Component {\nstate = 0;\n\nview = state =&gt; {\nconst items = triangles.map(t =&gt;\nsvg`&lt;polygon id=\"${t.id}\"\n        points=\"-50,-88 0,-175 50,-88\"\n        transform=\"rotate(${t.rot})\"\n        stroke-width=\"3\" /&gt;`\n);\nreturn html`&lt;div class=\"view\"&gt;\n      &lt;style&gt;${style}&lt;/style&gt;\n      &lt;svg width=\"380\" height=\"380\" viewBox=\"-190,-190,380,380\"&gt;\n        &lt;g id=\"carousel\" style=\"transform: rotate(${state}deg);\"&gt;\n${items}\n        &lt;/g&gt;\n      &lt;/svg&gt;\n      &lt;button @click=${run(\"@rot+60\")}&gt;Rotate Clockwise&lt;/button&gt;\n      &lt;button @click=${run(\"@rot-60\")}&gt;Rotate Anticlockwise&lt;/button&gt;\n      &lt;button @click=${run(\"@reset\")}&gt;Reset&lt;/button&gt;\n    &lt;/div&gt;`;\n};\n\nupdate = {\n\"@rot+60\": state =&gt; state + 60,\n\"@rot-60\": state =&gt; state - 60,\n\"@reset\": () =&gt; 0,\n};\n}\nnew SvgComponent().start(document.body);\n</code></pre> </p>"},{"location":"svg/#svg-xlinkhref","title":"SVG - xlink:href","text":"<p>You can use xlinkHref to define the xlink:href attribute of SVG.</p> <p><pre><code>// SVG - xlink\nconst view = () =&gt; &lt;svg viewBox=\"0 0 150 20\"&gt;\n&lt;a xlinkHref=\"https://apprun.js.org/\"&gt;\n&lt;text x=\"10\" y=\"10\" font-size=\"5\"&gt;Click Here&lt;/text&gt;&lt;/a&gt;\n&lt;/svg&gt;\n\napp.start(document.body, {}, view);\n</code></pre> </p>"},{"location":"svg/#svg-event-handlers","title":"SVG Event Handlers","text":"<p>You can handle the onclick event of SVG elements. Or use the $onclick directive</p> <p><pre><code>// SVG - $onclick\nconst view = state =&gt; &lt;&gt;\n&lt;div&gt;click the buttons:&lt;/div&gt;\n&lt;svg viewBox=\"0 0 520 520\" xmlns=\"http://www.w3.org/2000/svg\"&gt;\n&lt;rect x=\"10\" y=\"10\" width=\"90\" height=\"20\" fill=\"#aaa\"\n$onclick=\"test\" id=\"$onclick\"/&gt;\n&lt;rect x=\"110\" y=\"10\" width=\"90\" height=\"20\" fill=\"#bbb\"\nonclick=\"app.run('test', event)\" id=\"onclick\"/&gt;\n&lt;/svg&gt;\n&lt;/&gt;\n\nconst update = {\ntest: (state, evt) =&gt; alert(\"You have used: \" + evt.target.id)\n}\napp.start(document.body, '', view, update);\n</code></pre> </p>"},{"location":"svg/#svg-animation","title":"SVG Animation","text":"<p>You can use the animate element to add animation to SVG.</p> <p><pre><code>// SVG - animation\nconst view = () =&gt; &lt;&gt;\n&lt;svg height=\"60\" width=\"160\"&gt;\n&lt;rect width=\"100%\" height=\"100%\" rx=\"10\" ry=\"10\" fill=\"lightgrey\" /&gt;\n&lt;circle cx=\"30\" cy=\"30\" r=\"20\" fill='lime'&gt;\n&lt;animate\nattributeType=\"XML\"\nattributeName=\"fill\"\nvalues=\"lime;lightgrey;lime;lightgrey\"\ndur=\"0.5s\"\nrepeatCount=\"indefinite\"/&gt;\n&lt;/circle&gt;\n&lt;circle cx=\"80\" cy=\"30\" r=\"20\" fill='yellow' fill-opacity='0.2'/&gt;\n&lt;circle cx=\"130\" cy=\"30\" r=\"20\" fill='orangered' fill-opacity='0.2' /&gt;\n&lt;/svg&gt;\n&lt;/&gt;;\napp.start(document.body, {}, view);\n</code></pre> </p>"},{"location":"tutorial/","title":"Quick Start Tutorial","text":""},{"location":"tutorial/#create-your-first-app","title":"Create Your First App","text":"<p>AppRun Application logic is broken down into three separate parts in the AppRun architecture.</p> <ul> <li>State (a.k.a. Model) \u2014 the state of your application</li> <li>View \u2014 a function to display the state</li> <li>Update \u2014 a collection of event handlers to update the state</li> </ul> <p>Let's use the Counter app as an example and code it directly in the HTML file.</p> <p><pre><code>&lt;html&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"&gt;\n  &lt;title&gt;Counter&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;script src=\"https://unpkg.com/apprun/dist/apprun-html.js\"&gt;&lt;/script&gt;\n  &lt;script&gt;\nconst state = 0;\nconst view = state =&gt; {\nreturn html`&lt;div&gt;\n        &lt;h1&gt;${state}&lt;/h1&gt;\n        &lt;button onclick='app.run(\"-1\")'&gt;-1&lt;/button&gt;\n        &lt;button onclick='app.run(\"+1\")'&gt;+1&lt;/button&gt;\n      &lt;/div&gt;`;\n};\nconst update = {\n'+1': state =&gt; state + 1,\n'-1': state =&gt; state - 1\n};\napp.start(document.body, state, view, update);\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </p> <p>It is easy to have simple code in the HTML file. However, most of the time, we use external script files for complex app logic.</p> <pre><code>&lt;html&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"&gt;\n  &lt;title&gt;Counter&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;script src=\"https://unpkg.com/apprun/dist/apprun-html.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"app.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Next, we will create an AppRun component in the app.js file.</p>"},{"location":"tutorial/#create-your-first-component","title":"Create Your First Component","text":"<p>AppRun components are mini-applications with the state, view, and update architecture.</p> <p>It is straightforward to re-create the Counter app as a component.</p> <p><pre><code>//app.js\nclass Counter extends Component {\nstate = 0;\nview = state =&gt; {\nreturn html`&lt;div&gt;\n      &lt;h1&gt;${state}&lt;/h1&gt;\n      &lt;button @click=${()=&gt;this.run(\"-1\")}&gt;-1&lt;/button&gt;\n      &lt;button @click=${()=&gt;this.run(\"+1\")}&gt;+1&lt;/button&gt;\n    &lt;/div&gt;`;\n};\nupdate = {\n'+1': state =&gt; state + 1,\n'-1': state =&gt; state - 1\n};\n}\nnew Counter().start(document.body);\n</code></pre> </p> <p>Note</p> <p>Components have local event events. We use this.run instead of app.run to publish local events.</p>"},{"location":"tutorial/#create-a-web-component","title":"Create a Web Component","text":"<p>AppRun components can be defined as web components/custom elements and used in HTML. All we need to do is to give the AppRun component a custom-element name using the app.webComponent function.</p> <p><pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\"utf-8\"&gt;\n&lt;title&gt;Counter&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;my-counter&gt;&lt;/my-counter&gt;\n&lt;script src=\"https://unpkg.com/apprun/dist/apprun-html.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\nclass Counter extends Component {\nstate = 0;\nview = state =&gt; {\nreturn html`&lt;div&gt;\n          &lt;h1&gt;${state}&lt;/h1&gt;\n          &lt;button @click=${()=&gt;this.run(\"-1\")}&gt;-1&lt;/button&gt;\n          &lt;button @click=${()=&gt;this.run(\"+1\")}&gt;+1&lt;/button&gt;\n        &lt;/div&gt;`;\n};\nupdate = {\n'+1': state =&gt; state + 1,\n'-1': state =&gt; state - 1\n};\n}\napp.webComponent('my-counter', Counter);\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </p>"},{"location":"tutorial/#create-a-single-page-app","title":"Create a Single-Page App","text":"<p>We can easily make a single-page page (SPA) using AppRun components. Each page is a component that can be activated by anchor links like #Home, #contact, and #about.</p> <p><pre><code>class Home extends Component {\nview = () =&gt; &lt;div&gt;Home&lt;/div&gt;;\nupdate = {'#, #home': state =&gt; state };\n}\n\nclass Contact extends Component {\nview = () =&gt; &lt;div&gt;Contact&lt;/div&gt;;\nupdate = {'#contact': state =&gt; state };\n}\n\nclass About extends Component {\nview = () =&gt; &lt;div&gt;About&lt;/div&gt;;\nupdate = {'#about': state =&gt; state };\n}\n\nconst App = () =&gt; &lt;&gt;\n&lt;div id=\"menus\"&gt;\n&lt;a href=\"#home\"&gt;Home&lt;/a&gt;{' | '}\n&lt;a href=\"#contact\"&gt;Contact&lt;/a&gt;{' | '}\n&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/div&gt;\n&lt;div id=\"pages\"&gt;&lt;/div&gt;\n&lt;/&gt;\n\napp.render(document.body, &lt;App /&gt;);\n[About, Contact, Home].map(C =&gt; new C().start('pages'));\n</code></pre> </p> <p></p> <p>Note</p> <p>We have just created a simple SPA using components. In a real-world scenario, usually, create pages as modules and bundle them together or load them dynamically.</p> <p>Next, you will learn how to</p> <ul> <li>Use the npm create apprun-app to create a new AppRun project</li> <li>Create an AppRun Site for SSR and static site generation</li> </ul>"},{"location":"unit-testing/","title":"Unit Testing","text":"<p>AppRun architecture is unit test-oriented. The three architectural parts state, view, and update (event handlers) are decoupled. They are straightforward to test.</p> <p>AppRun development environment includes the Jest framework. The convention to run the tests is to use the npm script: <pre><code>npm run jest\n</code></pre> We can also run the Jest testing interactive mode using the npm script: <pre><code>npm test\n</code></pre> Jest watches file changes and runs the test files only related to changed files. Jest also executes the tests in parallel. Therefore, it is very fast to execute the tests. The interactive way for us to define which tests to be executed during the watch mode.</p>"},{"location":"unit-testing/#types-of-testing","title":"Types of Testing","text":"<p>There are two types of unit tests in the AppRun application.</p> <ol> <li>Test the events-states - publishing the events and asserting the states.</li> <li>Test the state-vdom - set the states and assert the VDOM output of the view function.</li> </ol>"},{"location":"unit-testing/#create-tests-using-cli","title":"Create Tests using CLI","text":"<p>Creating unit tests could be tedious, but you can use the AppRun Dev Tools to generate the tests.</p> <p>First, include the CLI scripts in your HTML.</p> <pre><code>&lt;script src=\"https://unpkg.com/apprun@latest/dist/apprun-dev-tools.js\"&gt;&lt;/script&gt;\n</code></pre>"},{"location":"unit-testing/#event-state-tests","title":"Event-State Tests","text":"<p>Use the create-event-tests command to create event-state tests.</p> <p> </p>"},{"location":"unit-testing/#state-vdom-tests","title":"State-VDOM Tests","text":"<p>Use the create-state-tests (start|stop) command to create state-view tests.</p> <p> </p>"},{"location":"unit-testing/#examples","title":"Examples","text":"<p>Please check out the unit tests from the AppRun RealWorld example application.</p> <p>You can find:</p> <ul> <li>How to mock the API calls</li> <li>Event-State Test</li> <li>State-VDOM Test</li> </ul>"},{"location":"view-patterns/","title":"JSX","text":"<p>AppRun uses virtual DOM technology (VDOM). The VDOM is the data representing a DOM structure. AppRun compares the VDOM with the real DOM and updates only the changed elements and element properties. It provides high performance.</p> <p>AppRun allows you to choose your favorite virtual DOM technology to create user interfaces in the view function.</p> <p>We recommend using JSX. Some advanced features only apply to JSX.</p>"},{"location":"view-patterns/#jsx_1","title":"JSX","text":"<p>JSX is a syntax sugar of function calls. Thus, you can compose the functions and apply dynamic and conditional rendering without the run-time cost of parsing the HTML string.</p> <p>You can use the JSX features described below.</p>"},{"location":"view-patterns/#jsx-fragments","title":"JSX fragments","text":"<p>JSX Fragments let you group a list of children without adding extra root node. E.g., you can use &lt;&gt; for declaring fragments. E.g.,</p> <pre><code>const view = &lt;&gt;\n&lt;h1&gt;title 1&lt;/h1&gt;\n&lt;h2&gt;title 2&lt;/h2&gt;\n&lt;/&gt;\n</code></pre>"},{"location":"view-patterns/#function-calls","title":"Function Calls","text":"<p>We can also use the capitalized JSX tag to call JavaScript functions with capitalized function names. The functions are also known as the Pure Function Component.</p> <p>E.g., To render the todo item list, You can call the Todo function in an array.map function.</p> <pre><code>const Todo = ({ todo, idx }) =&gt; &lt;li&gt;{todo.title}&lt;/li&gt;;\nconst view = state =&gt; &lt;ul class=\"todo-list\"&gt; {\nstate.list.map((todo, idx) =&gt; &lt;Todo todo={todo} idx={idx} /&gt;)\n}&lt;/ul&gt;\n</code></pre>"},{"location":"view-patterns/#de-structuring-properties","title":"De-structuring Properties","text":"<p>The call to the Todo function passes two properties todo and idx. In the Todo function, you can retrieve the two properties by de-structuring the parameters.</p> <pre><code>const Todo = ({ todo, idx }) =&gt; &lt;li&gt;{todo.title}&lt;/li&gt;;\n</code></pre>"},{"location":"view-patterns/#set-class","title":"Set Class","text":"<p>Each todo item should have a class \u201cview\u201d that represents that active or complete for a complete status of the todo item. You can use the ternary operator to toggle between two classes.</p> <pre><code>const Todo = ({ todo, idx }) =&gt; &lt;li class={todo.done ? \"completed\" : \"view\"}&gt;\n</code></pre> <p>Please note that AppRun supports using the keyword class in JSX.</p>"},{"location":"view-patterns/#toggle-class","title":"Toggle Class","text":"<p>Sometimes, you need to toggle classes based on the state. You can also use the ternary operator to toggle the class. E.g., toggle the selected class to a menu item.</p> <pre><code>&lt;li&gt;&lt;a class={state.filter === 'All' ? 'selected' : ''} &gt;All&lt;/a&gt;&lt;/li&gt;\n</code></pre>"},{"location":"view-patterns/#show-and-hide-element","title":"Show and Hide Element","text":"<p>To show or hide an element dynamically, you can use the &amp;&amp; operator.</p> <pre><code>const countComplete = state.list.filter(todo =&gt; todo.done).length || 0;\n{ countComplete &amp;&amp; &lt;button&gt;Clear completed&lt;/button&gt;}\n</code></pre>"},{"location":"view-patterns/#ref","title":"ref","text":"<p>ref is a special JSX property, which is a callback function that is called after the view function is executed.</p> <pre><code>const view = &lt;div ref={el=&gt;{...}}&gt;&lt;/div&gt;\n</code></pre> <p>We can use ref function to update the HTML element, e.g., set focus to an input box.</p> <p>ref is a better method to update the element than using the rendered lifecycle function.</p> <p>Please think of using the ref function before you use the rendered function.</p>"},{"location":"view-patterns/#element-embedding","title":"Element embedding","text":"<p>Furthermore, AppRun allows embedding elements directly into JSX.</p> <pre><code>view = state =&gt; {\nconst canvas = document.createElement('canvas');\nreturn &lt;div&gt;{canvas}&lt;/div&gt;\n};\n</code></pre> <p>A few use cases of the Element embedding are:</p> <ul> <li>Create special element, e.g. element has shadow root</li> <li>Create elements using 3rd libraries.</li> <li>Create and cache the element to avoid recreation in every event lifecycle</li> </ul> <p>Just create the HTML element and add it to the AppRun view.</p> <p>Please think of embedding the element before you use the ref function.</p>"},{"location":"view-patterns/#directive","title":"Directive","text":"<p>The directive is the special property that looks like $xxx. When AppRun is processing the JSX code and finds the properties of $xxx, it publishes the $ event. The event parameters contain the directive key, properties, and tag Name of the HTML element and component instance.</p> <pre><code>const view = &lt;div $myDirective&gt;&lt;/div&gt;;\napp.on('$', ({key, props, tag, component}) =&gt; {\nif (key === '$myDirective') {\n}\n}\n</code></pre> <p>We can subscribe to the $ event and create custom directives to modify the properties of the HTML element.</p> <p>See more details about directive in the next section.</p>"},{"location":"architecture-ideas/dapr/","title":"Use AppRun with Dapr","text":"<p>Welcome to the world of AppRun, microservices, CQRS, and Dapr.</p> <ul> <li>Dapr is a portable, serverless, event-driven runtime for building resilient, stateless, and stateful microservices.</li> </ul> <p>We can connect AppRun events to Dapr PubSub through WebSockets to build microservices using CQRS, and Dapr.</p> <p></p> <p>https://github.com/yysun/apprun-dapr/</p>"},{"location":"architecture-ideas/db-websocket/","title":"Database-Driven Applications Using WebSockets","text":""},{"location":"architecture-ideas/db-websocket/#introduction","title":"Introduction","text":"<p>The database is a specific technology for storing, managing, and processing data. In the real-world, web sites, mobile apps, and business applications that serve dynamic content all have a backend database.</p> <p>Started being popular in the web and mobile apps, moving to the business applications, nowadays most of the database-driven applications use a REST API based architecture. The REST API provides flexibility, scalability, and simplicity over other traditional web services architectures.</p> <p></p> <p>However, the primary purpose of the REST API is to decouple the backend and frontend, which assumes backend and frontend know nothing about each other. Even in case we know and own both backend and frontend, such as in many business applications, we still have to develop the backend API endpoints first. And then, we develop the frontend API clients. Developing backend and frontend separately is tedious and error-prone.</p> <p>Also, If we want to publish events from the frontend to be handled in the backend business logic modules, we cannot do it directly. Furthermore, the REST API is not a duplex protocol. Only the frontend can call the API. The backend cannot call the frontend. Therefore sometimes, the REST API has become a barrier between frontend and backend that costs us extra time and effort to overcome.</p> <p>In this post, I will introduce a new application architecture that allows us to send events back and forth between the frontend apps to the backend business logic modules using the WebSocket API and AppRun without REST API.</p> <p>The WebSocket API is a duplex communication channel. It works well with an event-driven framework, such as AppRun.</p>"},{"location":"architecture-ideas/db-websocket/#the-architecture","title":"The Architecture","text":"<p>The new architecture uses the WebSocket API and AppRun event system.</p> <p>AppRun has two important functions: app.run and app.on. app.run fires events. app.on handles events. E.g.:</p> <p>Module A handles the print event:</p> <p><pre><code>import app from 'apprun';\nexport default () =&gt; app.on('print', e =&gt; console.log(e));\n</code></pre> Module B fires the print event:</p> <pre><code>import app from 'apprun';\napp.run('print', {});\n</code></pre> <p>Module B can invoke the function in Module A without knowing Module A. It works when Module A and Module B are both frontend modules. Can the business logic modules behind the webserver also subscribe to the frontend events?</p> <p>Yes, that's the exact idea of the new architecture.</p> <p></p> <p>Let's see how it works.</p>"},{"location":"architecture-ideas/db-websocket/#an-example-application","title":"An Example Application","text":"<p>We will create a database-driven todo application to demonstrate the new architecture. The project has the following files:</p> <p></p> <ul> <li>The database:</li> <li>db/todo.db is a SQLite database</li> <li>The public folder has the frontend code:</li> <li>index.html</li> <li>dist/app.js</li> <li>The server folder has the backend code:</li> <li>db.js: the business logic</li> <li>server.js: the web server using the express and _websocket libraries</li> <li>The src folder has the frontend code:</li> <li>todo.tsx: the AppRun component for managing the todo list</li> <li>main.tsx: the main program</li> </ul>"},{"location":"architecture-ideas/db-websocket/#send-events-to-server-through-websocket","title":"Send Events to Server Through WebSocket","text":"<p>First, we create a WebSocket in the frontend app (main.tsx). Then, We define a special AppRun global event called //ws:, which sends the events to the server.</p> <pre><code>const ws = new WebSocket(`wss://${location.host}`);\napp.on('//ws:', (event, state) =&gt; {\nconst msg = { event, state };\nws.send(JSON.stringify(msg));\n});\n</code></pre>"},{"location":"architecture-ideas/db-websocket/#receiving-events-from-frontend","title":"Receiving Events from Frontend","text":"<p>We create the WebSockets on the webserver side (index.js). We listen to the WebSockets messages and convert them to AppRun events. AppRun runs on the webserver. Just like Module A and Module B example above, the AppRun events will be handled in the business logic module (db.js).</p> <pre><code>const apprun = require('apprun').app;\nrequire('./db');\n\nconst path = require('path');\nconst express = require('express');\nconst { createServer } = require('http');\nconst webSocket = require('ws');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, '../public')));\n\nconst server = createServer(app);\nconst wss = new webSocket.Server({ server });\n\nwss.on('connection', function(ws) {\nws.on('message', function (data) {\ntry {\nconst json = JSON.parse(data);\nconsole.log('==&gt;', json);\napprun.run(json.event, json, ws);\n} catch (e) {\nws.send(e.toString());\nconsole.error(e);\n}\n});\n});\n</code></pre> <p>Notice the webserver also adds the WebSocket reference, ws as the event parameter for the business logic module.</p>"},{"location":"architecture-ideas/db-websocket/#handle-events-in-business-logic-module","title":"Handle Events in Business Logic Module","text":"<p>We handle AppRun events in the business logic module (db.js) to complete the CRUD operations against the database.</p> <pre><code>const app = require('apprun').app;\nconst sqlite3 = require('sqlite3').verbose();\nconst dbFile = \"db/todo.db\";\n\napp.on('@get-all-todo', (json, ws) =&gt; {\nconst sql = 'select * from todo';\ndb.all(sql, function (err, rows) {\njson.state = rows || [];\nws.send(JSON.stringify(json));\n});\n});\n\napp.on('@get-todo', (json, ws) =&gt; {\n});\n\napp.on('@create-todo', (json, ws) =&gt; {\n});\n\napp.on('@update-todo', (json, ws) =&gt; {\n});\n\napp.on('@delete-todo', (json, ws) =&gt; {\n});\n\napp.on('@delete-all-todo', (json, ws) =&gt; {\n});\n</code></pre> <p>Once completed the database operations, we use the WebSocket reference, ws, to send events back.</p>"},{"location":"architecture-ideas/db-websocket/#receiving-events-from-backend","title":"Receiving Events from Backend","text":"<p>Receiving events from the backend in the frontend app (main.tsx) is straightforward.</p> <pre><code>const ws = new WebSocket(`wss://${location.host}`);\nws.onmessage = function (msg) {\nconst {event, state} = JSON.parse(msg.data);\napp.run(event, state);\n}\n</code></pre> <p>You can see now we have 9 lines of client-side code in main.tsx and 11 lines of server-side code in index.js for transferring AppRun events between frontend and backend through WebSockets.</p> <p>We also have a business logic module that operates the database using AppRun events.</p> <p>They are ready to serve the frontend application.</p>"},{"location":"architecture-ideas/db-websocket/#the-frontend-application","title":"The Frontend Application","text":"<p>The frontend Todo application is a typical AppRun application that has the Elm inspired architecture (todo.tsx). Listed below is the simplified code except.</p> <pre><code>import app, { Component } from 'apprun';\n\nconst state = {\nfilter: 0,\ntodos: []\n}\n\nconst add = () =&gt; {\napp.run('//ws:', '@create-todo', {\ntitle: document.getElementById('new_todo').value,\ndone: 0\n})\n};\n\nconst toggle = (_, todo) =&gt; { app.run('//ws:', '@update-todo', { ... }) };\n\nconst remove = (_, todo) =&gt; { app.run('//ws:', '@delete-todo', todo) };\n\nconst clear = () =&gt; { app.run('//ws:', '@delete-all-todo') };\n\nconst search = (state, filter) =&gt; ({ ...state, filter });\n\nconst view = (state) =&gt; {...}\n\nconst update = {\n'@get-all-todo': (state, todos) =&gt; ({ ...state, todos }),\n\n'@create-todo': (state, todo) =&gt; ({ ... }),\n\n'@update-todo': (state, todo) =&gt; { ... },\n\n'@delete-todo': (state, todo) =&gt; { ... },\n\n'@delete-all-todo': state =&gt; ({ ...state, todos: [] })\n}\n\nexport default new Component(state, view, update);\n</code></pre> <p>You can see we have state, view, and update to form an AppRun component.</p> <p>The local functions handle local events, such as add, toggle, remove, clear, and search. These functions fire the global event //ws: to the WebSocket.</p> <p>The update object contains the event handlers for the events fired from the backend.</p> <p>That's all the implementation plan. For details, please take a look at the live demo and the source code if you like.</p>"},{"location":"architecture-ideas/db-websocket/#run-the-demo","title":"Run the Demo","text":"<p>Live Demo:</p> <p>https://glitch.com/~apprun-websockets-sqlite</p> <p>Source Code:</p> <p>https://github.com/yysun/apprun-websockets-sqlite</p>"},{"location":"architecture-ideas/db-websocket/#conclusion","title":"Conclusion","text":"<p>The todo application has demonstrated the architecture of using events through WebSockets. The web server has no REST API endpoints. The frontend has only event handlings and has no REST API calls.</p> <p>The architecture is useful for database-driven applications, especially business applications.</p> <p>Furthermore, AppRun events are not limited to frontend and WebSockets.  We can use AppRun events with the Web Workers API explained in the AppRun Book. We can also use AppRun in the Electron Apps, Firebase, Cloud Pub-Sub, and more ...</p> <p>Feel the power of event pub-sub pattern and learn more about building applications with AppRun.</p>"},{"location":"architecture-ideas/firebase-app/","title":"Serverless App Using Firebase and AppRun","text":""},{"location":"architecture-ideas/firebase-app/#introduction","title":"Introduction","text":"<p>I have been writing about the application architecture without REST, which includes the underlying architecture using WebSockets and the database-driven architecture. In this post, I will continue the journey to make a serverless application architecture using Firebase and AppRun.</p> <p>You will see how easy it is to use AppRun's event system with the Firebase stack to develop applications that have the full business logic process capabilities, such as authentication, authorization, request logging, and real-time database, and without REST layer.</p> <p>Finally, we can make the application a serverless deployment to Firebase.</p>"},{"location":"architecture-ideas/firebase-app/#the-architecture","title":"The Architecture","text":"<p>The example application uses the following technologies:</p> <ul> <li>Firebase Cloud Firestore as the backend database</li> <li>Firebase Cloud Functions for business logic process</li> <li>Firebase Hosting to host the frontend</li> <li>Firebase Authentication</li> </ul> <p>Firebase is Google's mobile platform that helps you quickly develop high-quality apps and grow your business.</p> <p>I will focus on the architecture instead of step-by-step instructions. If you are not familiar with the Firebase suite of products, please search google for the tutorials.</p> <p>The architecture can be summarized in the diagram below.</p> <p></p> Figure 1. Architecture Diagram <p>Let's get into the details.</p>"},{"location":"architecture-ideas/firebase-app/#event-pub-sub-using-firestore","title":"Event Pub-Sub Using FireStore","text":"<p>The center of the architecture is the Firebase Cloud Firestore. Firestore is a real-time database that keeps your data in-sync across client apps. When one client saves the data, FireStore pushes the data to all other clients.</p> <p>In the AppRun applications, we use app.on to publish events. If we save the events to FireStore, the events can be handled by other applications. It is the step (1) shown in Figure 1 above.</p> <p>Firestore also triggers Cloud Functions.</p>"},{"location":"architecture-ideas/firebase-app/#business-logic-process-using-cloud-functions","title":"Business Logic Process Using Cloud Functions","text":"<p>Cloud Functions is Google Cloud's serverless compute platform. It runs on the server, not in the client apps. Therefore it is the best technology for business logic processing, authentication, and authorization. Functions are serverless. Functions run on Google's server, so we don't need to provision, manage, or upgrade the server.</p> <p>The Functions are event-driven (the magic word, I love). Firestore can trigger Functions upon data updates. When we save the events into FireStore, FireStore triggers the Function to handle the events automatically. It is the step (2) in Figure 1.</p>"},{"location":"architecture-ideas/firebase-app/#real-time-data-sync-using-firestore","title":"Real-Time Data Sync Using FireStore.","text":"<p>During the Functions event handling, it writes the updated data back to FireStore (step (3) in Figure 1). FireStore pushes the update to the frontend applications (step (4) in Figure 1). The frontend application listens to FireStore changes and publishes AppRun events for the frontend logic process to run.</p> <p>Now, the event handling cycle is completed. Let's see it in action with an example.</p>"},{"location":"architecture-ideas/firebase-app/#example","title":"Example","text":"<p>The example is a ToDo application.</p> <p></p> Figure 2. ToDo Application"},{"location":"architecture-ideas/firebase-app/#save-events-to-firestore","title":"Save Events to FireStore","text":"<p>As usual, in the AppRun applications, we convert the DOM events into AppRun events. E.g., When users click the add button, we publish the //: event.</p> <pre><code>// in JSX\n&lt;button $onclick={[add]}&gt;Add&lt;/button&gt;\n\nconst add = () =&gt; {\napp.run('//:', '@create-todo', {\ntitle: (document.getElementById('new_todo').value,\ndone: 0\n})\n}\n</code></pre> <p>The //: event handler saves the event into FireStore.</p> <pre><code>const db = firebase.firestore();\napp.on('//:', (event, data = {}) =&gt; {\ndb.collection(`events`).add({ uid, event, data })\n});\n</code></pre> <p>There is a top-level collection, called events in FireStore. We save the user id (obtained using Firebase anonymous authentication), event name (@create-todo), and event parameters (the new to-do item).</p> <p>FireStore triggers our Function, which is monitoring the events collection.</p>"},{"location":"architecture-ideas/firebase-app/#handle-events-in-functions","title":"Handle Events in Functions","text":"<pre><code>exports.updateTodo = functions.firestore.document('events/{Id}')\n.onWrite((change, context) =&gt; {\nconst dat = change.after.data() as any;\nconst { uid, event, data } = dat;\nconst db = admin.firestore();\nconst todos = db.collection('/users/' + uid + '/todos');\nswitch (event) {\ncase '@create-todo': return todos.add(data);\ncase '@update-todo': ...\ncase '@delete-todo': ...\ncase '@delete-all-todo': ...\ndefault: return;\n}\n});\n</code></pre> <p>The Function destructs the user id, event name, and event parameters and handles it accordingly, e.g., it adds a new Todo item data into FireStore upon the '@create-todo' event. And so on so forth.</p> <p>FireStore then pushes the data change to the frontend.</p>"},{"location":"architecture-ideas/firebase-app/#real-time-data-in-frontend","title":"Real-Time Data in Frontend","text":"<p>In the frontend, we subscribe to the onSnapshot of FireStore and publish the AppRun event, '@show-all'.</p> <pre><code>const db = firebase.firestore();\ndb.collection(`users/${uid}/todos`).onSnapshot(snapshot =&gt; {\napp.run('@show-all',\nsnapshot.docs.map(d =&gt; ({ id: d.id, ...d.data() })))\n});\n</code></pre> <p>Now, we are back to our AppRun application world, in which you can see the three familiar parts: state, view, and update.</p> <pre><code>import app, { Component } from 'apprun';\n\nconst state = {\nfilter: 0,\ntodos: []\n}\n\nconst add = () =&gt; {\napp.run('//:', '@create-todo', {\ntitle: (document.getElementById('new_todo').value,\ndone: 0\n})\n};\nconst toggle = (_, todo) =&gt; { app.run('//:', '@update-todo', { ...todo, done: !todo.done }) };\nconst remove = (_, todo) =&gt; { app.run('//:', '@delete-todo', todo) };\nconst clear = () =&gt; { app.run('//:', '@delete-all-todo') };\n\nconst view = ({todos}) =&gt; {...}\n\nconst update = {\n'@show-all': (state, todos) =&gt; ({ ...state, todos })\n}\n</code></pre> <p>The Firebase ToDo application shares the same architecture as in the Database-Driven Application Post. They are only different in events. The Firebase ToDo application saves the events to FireStore. The Database-Driven Application sends and receives the events through the WebSockets.</p> <p>If you are new to AppRun, read the AppRun Book or visit AppRun Docs.</p>"},{"location":"architecture-ideas/firebase-app/#live-demo-and-source-code","title":"Live Demo and Source Code","text":"<p>You can play with the live demo at https://apprun-demo.firebaseapp.com.</p> <p>Source Code: https://github.com/yysun/apprun-firebase</p>"},{"location":"architecture-ideas/firebase-app/#conclusion","title":"Conclusion","text":"<p>The AppRun event pub-sub pattern looks so simple (just app.run and app.on), yet so powerful. It is not only useful inside the frontend app. It shines more in crossing process boundaries, such as in the cases of WebSockets, Web Workers, Electron Apps, Firebase of course, and more ...</p>"},{"location":"architecture-ideas/rust-app/","title":"Rust WebAssembly and AppRun","text":""},{"location":"architecture-ideas/rust-app/#introduction","title":"Introduction","text":"<p>WebAssembly has many different definitions on the Internet. I like the one from MDN the most, which says WebAssembly is a new binary assembly-like language that can run in the modern web browsers at near-native speed. There are many tools to compile code written in C/C++, Rust, Go, C#, etc. to be WebAssembly. It tells us that we can create high-performance code, but not using JavaScript/TypeScript</p> <p>I decided to play with Rust. Rust is another hot buzzword. It is a relatively new programming language focused on performance and safety, especially safe concurrency. -- Wikipedia</p> <p>This post describes how to create a WebAssembly package using Rust and use it in the AppRun applications from a JavaScript/TypeScript developer point of view. You will see the minimum steps of adding and using WebAssembly into your JavaScript/TypeScript project.</p>"},{"location":"architecture-ideas/rust-app/#setup","title":"Setup","text":"<p>First, you will need the Rust toolchain, including rustup, rustc, and cargo for compiling Rust code, and wasm-pack for building, testing and publishing Rust-generated WebAssembly.</p>"},{"location":"architecture-ideas/rust-app/#install-rust","title":"Install Rust","text":"<p>To install Rust on Mac/Linux, run the following command in the terminal. <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> On Windows, I enabled the Windows Subsystem for Linux and used Rust in the Linux terminal.</p>"},{"location":"architecture-ideas/rust-app/#install-wasm-pack","title":"Install wasm-pack","text":"<p>Once installed Rust, run the following command in the terminal. <pre><code>cargo install wasm-pack\n</code></pre> Believe it or not, that's all you need to create WebAssembly. Let's go back to the JavaScript/TypeScript world.</p> <ul> <li>If you start from scratch, follow the next section to create an AppRun project.</li> <li>If you already have an existing project, jump to the section of Create WebAssembly Project.</li> </ul>"},{"location":"architecture-ideas/rust-app/#create-apprun-project","title":"Create AppRun Project","text":"<p>Run the commands to create an AppRun project:</p> <pre><code>mkdir your-app-name\ncd your-app-name\nnpx apprun -i\n</code></pre> <p>Wait a few minutes for installing the npm packages, and then run the npm command:</p> <pre><code>npm start\n</code></pre> <p>You will see a hello world application running.</p> <p></p> AppRun Hello World <p>Next, we will add WebAssembly to this project.</p>"},{"location":"architecture-ideas/rust-app/#create-webassembly-project","title":"Create WebAssembly Project","text":"<p>Let's create a Rust project by running the following command:</p> <pre><code>cargo new wasm --lib\n</code></pre> <p>The command creates a folder called wasm and two files under the folder your-app-name/wasm: Cargo.toml and src/lib.rs.</p> <p>It is a regular Rust project, not a WebAssembly yet. You will need to add wasm-bindgen as the dependency to make it target WebAssembly. Open Cargo.toml and add the following sections.</p> <pre><code>[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\nwasm-bindgen = \"0.2.60\"\njs-sys = \"0.3.37\"\n</code></pre> <p>wasm-bindgen is a Rust library that facilitates high-level interactions between wasm modules and JavaScript. js-sys is the waw bindings to JS global APIs for projects using wasm-bindgen.</p> <p>Now, you can use wasm-pack to build a WebAssembly.</p> <pre><code>cd wasm\nwasm-pack build\n</code></pre>"},{"location":"architecture-ideas/rust-app/#use-webpack","title":"Use WebPack","text":"<p>Since the AppRun project is a WebPack project, we can use the wasm-pack-plugin to unify the build process that creates the WebAssembly and JavaScript code at the same time. Go ahead to add the package:</p> <pre><code>npm i @wasm-tool/wasm-pack-plugin -D\n</code></pre> <p>And add the wasm-pack-plugin into the webpack.config.js.</p> <pre><code>const WasmPackPlugin = require(\"@wasm-tool/wasm-pack-plugin\");\nmodule.exports = {\n...\nplugins: [\nnew WasmPackPlugin({\ncrateDirectory: path.resolve(__dirname, \".\")\n}),\n]\n...\n}\n</code></pre> <p>Also, because the wasm-pack-plugin generates the dynamic import module, you need to modify tsconfig.json file to set the module to be esnext.</p> <pre><code>{\n\"compilerOptions\": {\n...\n\"module\": \"esnext\",\n...\n}\n}\n</code></pre> <p>Finally, the npm scripts: npm start and npm run build will build the TypeScript code as well the Rust code.</p> <p>Let's write some Rust code.</p>"},{"location":"architecture-ideas/rust-app/#webassembly-and-apprun","title":"WebAssembly and AppRun","text":"<p>We will demonstrate two interactions between the WebAssembly and the AppRun application.</p> <ul> <li>Call the WebAssembly from the AppRun application</li> <li>Call the AppRun application from the WebAssembly</li> </ul>"},{"location":"architecture-ideas/rust-app/#call-webassembly","title":"Call WebAssembly","text":"<p>First, we create a Rust function in the wasm/src/lib.rs file.</p> <pre><code>use wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\npub fn add(a: i32, b: i32) -&gt; i32 {\na + b\n}\n</code></pre> <p>This function adds two numbers. We can make a counter application from it. Here is the counter application in AppRun.</p> <pre><code>import app from 'apprun';\n\nlet wasm;\nimport('../wasm/pkg').then(module =&gt; wasm = module);\n\nconst state = {\ntitle: 'Hello world - AppRun !',\ncount: 0\n}\n\nconst add = (state, num) =&gt; ({\n...state,\ncount: wasm.add(state.count, num)\n});\n\nconst view = ({ title, count }) =&gt; &lt;&gt;\n&lt;h1&gt;{title}&lt;/h1&gt;\n&lt;h1&gt;{count}&lt;/h1&gt;\n&lt;button $onclick={[add, -1]}&gt;-1&lt;/button&gt;\n&lt;button $onclick={[add, +1]}&gt;+1&lt;/button&gt;\n&lt;/&gt;;\n\napp.start(document.body, state, view);\n</code></pre> <p>You can see from the code above:</p> <ul> <li>Wasm-pack has created a JavaScript module that we can import dynamically.</li> <li>We can call the WebAssembly function just like a regular JavaScript function from a module.</li> </ul> <p>Running the application, we have a counter that uses the WebAssembly function.</p> <p></p> Counter with WASM <p>Next, let's see how does the WebAssembly function call AppRun functions.</p>"},{"location":"architecture-ideas/rust-app/#call-the-apprun","title":"Call the AppRun","text":"<p>Open wasm/src/lib.rs file and add the following functions.</p> <pre><code>#[wasm_bindgen]\nextern \"C\" {\n#[wasm_bindgen(js_namespace = app)]\nfn run(event: &amp;str, p: &amp;str);\n}\n\n#[wasm_bindgen(start)]\npub fn start() {\nrun(\"@hello\", \"hello world from rust\");\n}\n</code></pre> <ul> <li>The first function named run binds to the AppRun app.run function.</li> <li>The second function named start runs automatically when the WebAssembly is loaded.</li> <li>The start function calls the run function to send a '@hello' event to AppRun.</li> </ul> <p>Back to AppRun code, we will handle the '@hello' event.</p> <pre><code>import app from 'apprun';\n\nlet wasm;\nimport('../wasm/pkg').then(module =&gt; wasm = module);\n\nconst state = {...}\n\nconst add = (state, num) =&gt; ({...});\n\nconst view = ({ title, count }) =&gt; &lt;&gt;...&lt;/&gt;;\n\nconst update = {\n'@hello': (state, title) =&gt; ({...state, title})\n}\n\napp.start(document.body, state, view, update);\n</code></pre> <p>Now, when the application starts, it displays the messages sent from the WebAssembly.</p> <p></p> Message from wasm <p>We have successfully made two-way interactions between the WebAssembly and the AppRun application.</p>"},{"location":"architecture-ideas/rust-app/#souce-code","title":"Souce Code","text":"<p>You can run the live demo: https://yysun.github.io/apprun-rust.</p> <p>Or visit the source.</p> <p>{% github yysun/apprun-rust %}</p> <p>You also can use this project as an AppRun application template. Run the command to create your application.</p> <pre><code>npx degit yysun/apprun-rust my-app\n</code></pre>"},{"location":"architecture-ideas/rust-app/#conclusion","title":"Conclusion","text":"<p>This post should give you a quick start to use Rust/WebAssembly in the AppRun applications. The demo project shows the two technologies interact with each other very well. You can use the demo project as a template.</p> <p>We have now opened the door to a new world. There is much more potential to explore.</p>"},{"location":"architecture-ideas/state-machine/","title":"Use State Machine in AppRun Applications","text":""},{"location":"architecture-ideas/state-machine/#introduction","title":"Introduction","text":"<p>The state machine is the tool that developers must have in their toolbox.</p> <p>If you are new to the state machine, check out the reference section below.</p> <p>How can a state machine help?</p> <p>Typically, when building applications, we follow what's known as the event-driven \u2014 where an event happens in the application, we update the application state and render the state to the screen.</p> <p>Events can happen anytime during user interactions and system interactions, while the application can be in any state. Therefore, before we start to handle the events, we first have to determine the current state and then handle the event accordingly. Sometimes it can be challenging.</p> <p>The state machine provides a state-event-state mapping. Thus, before we start to handle the events, we know the current state and the future state, so that we only need to focus on the limited state-event scope.</p> <p>The specific state machine we are going to use is the Mealy machine. It has an initial state and then transitions to new states based on events and its current state.</p> <p>We are going to build a calculator application as an example. You will learn from this post:</p> <ul> <li>Model a state machine declaratively,</li> <li>Make the state machine type-safe</li> <li>Add the state machine to the AppRun application</li> </ul>"},{"location":"architecture-ideas/state-machine/#model-a-calculator","title":"Model a Calculator","text":""},{"location":"architecture-ideas/state-machine/#state-and-event","title":"State and Event","text":"<p>The calculator application looks like this:</p> <p><pre><code>const find_transition = (state_machine, state, event) =&gt; {\nconst current_state = state_machine[state];\nif (!current_state) throw new Error(`No state: ${current_state} found in state machine`);\nconst event_tuple = current_state.find(s =&gt; s[0] === event);\nreturn event_tuple ? {\nnext_state: event_tuple[1],\ntransition: event_tuple[2]\n} : {}\n};\n\nconst state = {\n_state: 'START',\ndisplay: '0',\narg1: 0,\narg2: 0,\nop: '',\nstack: []\n};\n\nconst view = ({ _state, op, arg1, arg2, display, stack }) =&gt; &lt;&gt;\n&lt;style&gt; {`\n    .calculator { width: 200px; }\n    .buttons {\n      display: grid;\n      grid-template-columns: repeat(4, 1fr);\n      grid-gap: 2px;\n    }\n    button { padding: 10px; width:100%; }\n    button:nth-of-type(1) {\n      grid-column: span 2;\n    }\n    button:nth-of-type(16) {\n      grid-column: span 2;\n    }\n  `}\n&lt;/style&gt;\n&lt;div class=\"calculator\"&gt;\n&lt;h1&gt;{display}&lt;/h1&gt;\n&lt;div class=\"buttons\" $onclick={button_click}&gt;\n&lt;button&gt;CE&lt;/button&gt;\n&lt;button&gt;+/-&lt;/button&gt;\n&lt;button&gt;/&lt;/button&gt;\n&lt;button&gt;7&lt;/button&gt;\n&lt;button&gt;8&lt;/button&gt;\n&lt;button&gt;9&lt;/button&gt;\n&lt;button&gt;*&lt;/button&gt;\n&lt;button&gt;4&lt;/button&gt;\n&lt;button&gt;5&lt;/button&gt;\n&lt;button&gt;6&lt;/button&gt;\n&lt;button&gt;-&lt;/button&gt;\n&lt;button&gt;1&lt;/button&gt;\n&lt;button&gt;2&lt;/button&gt;\n&lt;button&gt;3&lt;/button&gt;\n&lt;button&gt;+&lt;/button&gt;\n&lt;button&gt;0&lt;/button&gt;\n&lt;button&gt;.&lt;/button&gt;\n&lt;button&gt;=&lt;/button&gt;\n&lt;/div&gt;\n&lt;small&gt;\n{stack.length &gt; 0 &amp;&amp; `${stack[0][0]} ${stack[0][1]} `}\n{_state.startsWith(\"FIRST_\") &amp;&amp; `${display}`}\n{_state === \"OP\" &amp;&amp; `${arg1} ${op}`}\n{_state.startsWith(\"SECOND_\") &amp;&amp; `${arg1} ${op} ${display}`}\n{_state === \"EQ\" &amp;&amp; `${arg1} ${op} ${arg2} = ${display}`}\n&lt;/small&gt;\n&lt;/div&gt;\n&lt;/&gt;;\n\nconst button_click = (state, e) =&gt; {\n\nconst priority = {\n'*': 2,\n'/': 2,\n'+': 1,\n'-': 1\n}\n\nconst getEvent = c =&gt; {\nswitch (c) {\ncase '+/-':\nreturn '+/-';\ncase 'CE':\nreturn 'CE';\ncase '.':\nreturn 'DOT';\ncase '=':\nreturn 'EQ';\ndefault:\nreturn /\\d/.test(c) ? 'NUM' : 'OP';\n}\n};\n\nconst key = e.target?.textContent || e;\nconst event = getEvent(key);\n\nlet { _state, op, arg1, arg2, display, stack } = state;\n\nconst clear = () =&gt; {\ndisplay = '0';\narg1 = arg2 = 0;\nop = '';\nstack.length = 0;\n}\n\nconst negative = () =&gt; {\ndisplay = display.startsWith('-') ? display.substring(1) : '-' + display;\n};\n\nconst calc = () =&gt; {\ndisplay = eval(`${arg1}${op}${arg2}`).toString();\n};\n\nconst op1 = () =&gt; {\nop = key;\narg1 = parseFloat(display);\n};\n\nconst op2 = () =&gt; {\nif (priority[key] === priority[op]) {\narg2 = parseFloat(display);\ncalc();\nop = key;\narg1 = parseFloat(display);\n} else if (priority[key] &lt; priority[op]) {\narg2 = parseFloat(display);\ncalc();\narg1 = parseFloat(display);\nop = key;\nif (stack.length) {\nconst f = stack.pop();\narg1 = eval(`${f[0]}${f[1]}${display}`);\ndisplay = arg1.toString();\n}\n} else {\nstack.push([arg1, op]);\narg1 = parseFloat(display);\nop = key;\n}\n\n};\n\nconst eq0 = () =&gt; {\narg1 = parseFloat(display);\ncalc();\n};\n\nconst eq2 = () =&gt; {\narg2 = parseFloat(display);\ncalc();\nif (stack.length) {\narg2 = parseFloat(display);\nconst f = stack.pop();\ndisplay = eval(`${f[0]}${f[1]}${display}`).toString();\narg1 = f[0];\nop = f[1];\n}\n};\n\nconst state_machine = {\nSTART: [\n['NUM', 'FIRST_ARG', () =&gt; display = key],\n['DOT', 'FIRST_ARG_FLOAT', () =&gt; display = '0.']\n],\n\nFIRST_ARG: [\n['+/-', 'FIRST_ARG', negative],\n['NUM', 'FIRST_ARG', () =&gt; display += key],\n['DOT', 'FIRST_ARG_FLOAT', () =&gt; display += key],\n['OP', 'OP', op1],\n['CE', 'START', clear]\n],\n\nFIRST_ARG_FLOAT: [\n['+/-', 'FIRST_ARG_FLOAT', negative],\n['NUM', 'FIRST_ARG_FLOAT', () =&gt; display += key],\n['OP', 'OP', op1],\n['CE', 'START', clear]\n],\n\nOP: [\n['NUM', 'SECOND_ARG', () =&gt; display = key],\n['DOT', 'SECOND_ARG', () =&gt; display = '0.'],\n['OP', 'OP', () =&gt; op = key],\n['CE', 'START', clear]\n],\n\nSECOND_ARG: [\n['+/-', 'SECOND_ARG', negative],\n['NUM', 'SECOND_ARG', () =&gt; display += key],\n['DOT', 'SECOND_ARG_FLOAT', () =&gt; display += key],\n['EQ', 'EQ', eq2],\n['OP', 'OP', op2],\n['CE', 'OP', () =&gt; display = '0']\n],\n\nSECOND_ARG_FLOAT: [\n['+/-', 'SECOND_ARG_FLOAT', negative],\n['NUM', 'SECOND_ARG_FLOAT', () =&gt; display += key],\n['EQ', 'EQ', eq2],\n['OP', 'OP', op2],\n['CE', 'OP', () =&gt; display = '0']\n],\n\nEQ: [\n['+/-', 'FIRST_ARG', negative],\n['NUM', 'FIRST_ARG', () =&gt; display = key],\n['DOT', 'FIRST_ARG_FLOAT', () =&gt; display = '0.'],\n['EQ', 'EQ', eq0],\n['OP', 'OP', op1],\n['CE', 'START', clear]\n]\n};\n\nconst { next_state, transition } = find_transition(state_machine, _state, event);\n_state = next_state || _state;\ntransition &amp;&amp; transition();\n\nreturn { _state, op, arg1, arg2, display, stack };\n}\napp.start(document.body, state, view);\n</code></pre> </p> <p>Click the 'Try the Code' button; you will see the source code.</p> <p>The calculator has a grid of buttons that users can click at any time. It also displays:</p> <ul> <li>The numbers that the user typed and the calculation result on top of the grid.</li> <li>The calculation formula includes the first argument, the operator, and the second argument, and the calculation result below the gird.</li> </ul> <p>Let's model the initial state of the calculator.</p> <pre><code>const state = {\ndisplay: '0',\narg1: 0,\narg2: 0,\nop: '',\n};\n</code></pre> <p>We handle the buttons' click events in the event handler, button___click. Because of the HTML event bubbling, we only need one event handler for all the buttons.</p> <pre><code>const view =\n&lt;div class=\"buttons\" $onclick={button_click}&gt;\n......\n&lt;/div&gt;\n\nconst button_click = (state, e) =&gt; {\n}\n\napp.start(document.body, state, view);\n</code></pre> <p>That's all we need to do to create an AppRun application, an initial state, a view, and event handlers.</p> <p>Next, we will add the state machine implementation.</p>"},{"location":"architecture-ideas/state-machine/#state-machine","title":"State Machine","text":"<p>We follow and extend the calculator state machine from David's post. The post also provides a diagram helpful to understand the state machine.</p> <p>We first define the states and events of the state machine using TypeScript Discriminated Unions.</p> <pre><code>type Events = 'NUM' | 'OP' | 'DOT' | 'CE' | 'EQ' | '+/-';\n\ntype States =\n'START' |\n'FIRST_ARG' |\n'FIRST_ARG_FLOAT' |\n'OP' |\n'SECOND_ARG' |\n'SECOND_ARG_FLOAT' |\n'EQ';\n</code></pre> <p>We then define the state machine. It is a collection of all the states. Each state has a list of available events and transitions in an array. The transition is the function to update the state.</p> <pre><code>const state_machine = {\nSTART: [\n['NUM', 'FIRST_ARG', () =&gt; display = key],\n['DOT', 'FIRST_ARG_FLOAT', () =&gt; display = '0.']\n],\nFIRST_ARG: [\n['+/-', 'FIRST_ARG', negative],\n['NUM', 'FIRST_ARG', () =&gt; display += key],\n['DOT', 'FIRST_ARG_FLOAT', () =&gt; display += key],\n['OP', 'OP', op1],\n['CE', 'START', clear]\n],\n...\n}\n</code></pre> <p>For example, when the current state is START, and the NUM event comes, the new state should be 'FIRST_ARG (waiting for 1st argument)'. The display property of the state should be the user's input.</p> <p>Another example, when the current state is FIRST_ARG, and the +/- event comes, the display property should toggle between positive and negative.</p> <p>So on and so forth. It is straightforward to create the state machine object according to the diagram.</p> <p>Next, we make the state machine type-safe by adding more types.</p> <pre><code>export type Transition = () =&gt; void;\nexport type EventStateTransition&lt;E, S&gt; = [E, S, Transition];\nexport type StateMachine&lt;S extends string, E&gt; = {\n[key in S]: EventStateTransition&lt;E, S&gt;[];\n};\n</code></pre> <ul> <li>The Tansition is a function to update the application state.</li> <li>The EventStateTransition is a TypeScript Tuple. It describes which event leads to which new state.</li> <li>The StateMachine is an object that uses the _States as the index key.</li> </ul> <p>Now, the state machine is type-safe. The TypeScript compiler only allows you to use the states and events defined in States and Events.</p> <pre><code>const state_machine: StateMachine&lt;States, Events&gt; = {\nSTART0: [ // Error on START0\n['NUM0', 'FIRST_ARG', () =&gt; {}], // Error on NUM0\n['DOT', 'FIRST_ARG_FLOAT0', () =&gt; {}] // Error on FIRST_ARG_FLOAT0\n],\n}\n</code></pre> <p>Also, the compiler makes sure all States have their relevant entries in the state machine.</p> <p><pre><code>const state_machine: StateMachine&lt;States, Events&gt; = {\nSTART: [],\nFIRST_ARG: [],\nFIRST_ARG_FLOAT: [],\nOP:[], SECOND_ARG:[],\nSECOND_ARG_FLOAT:[],\n//EQ:[] // Error on missing EQ state, if we commented it out\n}\n</code></pre> You can see the state machine is just a simple data structure.</p>"},{"location":"architecture-ideas/state-machine/#add-state-machine-state","title":"Add State-Machine State","text":"<p>We add a new property for tracking the state-machine state, called _state, into the initial state.</p> <pre><code>const state = {\n_state: 'START' as States,\ndisplay: '0',\narg1: 0,\narg2: 0,\nop: '',\n};\nexport type State = typeof state;\n</code></pre>"},{"location":"architecture-ideas/state-machine/#convert-ui-events","title":"Convert UI Events","text":"<p>All button clicks use the button___click event handler. We convert UI events into different state-machine events.</p> <pre><code>export const button_click = (state: State, e: any) =&gt; {\n\nconst getEvent = (c: string): Events =&gt; {\nswitch (c) {\ncase '+/-':\nreturn '+/-';\ncase 'CE':\nreturn 'CE';\ncase '.':\nreturn 'DOT';\ncase '=':\nreturn 'EQ';\ndefault:\nreturn /\\d/.test(c) ? 'NUM' : 'OP';\n}\n};\n\nconst key = e.target?.textContent || e;\nconst event = getEvent(key);\n\n\n}\n</code></pre>"},{"location":"architecture-ideas/state-machine/#use-state-machine","title":"Use State Machine","text":"<p>Now that we know the current state-machine state from the _state property of the application state. We also know which state-machine event we are in. We now can use the state___machine to find the matching transition.</p> <p>Finding transitions from the state___machine is straightforward.</p> <pre><code>const find_transition = &lt;S extends string, E&gt;(\nstate_machine: StateMachine&lt;S, E&gt;,\nstate: S,\nevent: E\n): { next_state?: S, transition?: Transition } =&gt; {\nconst current_state = state_machine[state];\nif (!current_state) throw new Error(`No state: ${current_state} found in state machine`);\nconst event_tuple = current_state.find(s =&gt; s[0] === event);\nreturn event_tuple ? {\nnext_state: event_tuple[1],\ntransition: event_tuple[2]\n} : {}\n};\n</code></pre> <p>If we found the transition, we run the transition function. It updates the destructed application state properties, such as op, arg1, arg2, and display accordingly. We then update the application state to be the next state.</p> <pre><code>const button_click = (state, e) =&gt; {\nlet { _state, op, arg1, arg2, display } = state;\nconst event = getEvent(s);\nconst state_machine = {\n};\n\nconst { next_state, transition } = find_transition(state_machine, _state, event);\ntransition &amp;&amp; transition();\n_state = next_state || _state;\n\nreturn { _state, op, arg1, arg2, display };\n}\n</code></pre> <p>If no transition found, nothing will happen.</p> <p>Finally, we return a new state from the event handler; AppRun will render the screen accordingly.</p> <p>Now, we have successfully created the calculator application. You can see the calculator in TypeScript below.</p> <p>Source</p> state machine <pre><code>export type Transition&lt;T = any&gt; = (state?: T) =&gt; void;\nexport type EventStateTransition&lt;E, S&gt; = [E, S, Transition];\nexport type StateMachine&lt;S extends string, E&gt; = {\n[key in S]: EventStateTransition&lt;E, S&gt;[];\n};\n\nexport const find_transition = &lt;S extends string, E&gt;(\nstate_machine: StateMachine&lt;S, E&gt;,\nstate: S,\nevent: E\n): { next_state?: S, transition?: Transition } =&gt; {\nconst current_state = state_machine[state];\nif (!current_state) throw new Error(`No state: ${current_state} found in state machine`);\nconst event_tuple = current_state.find(s =&gt; s[0] === event);\nreturn event_tuple ? {\nnext_state: event_tuple[1],\ntransition: event_tuple[2]\n} : {}\n};\n</code></pre> calculator app <pre><code>import app, { Component } from '../../src/apprun';\nimport { StateMachine, find_transition } from './state-machine';\n\ntype Events = 'NUM' | 'OP' | 'DOT' | 'CE' | 'EQ' | '+/-';\n\ntype States = 'START' | 'FIRST_ARG' | 'FIRST_ARG_FLOAT' | 'OP' | 'SECOND_ARG' | 'SECOND_ARG_FLOAT' | 'EQ';\n\nconst state = {\n_state: 'START' as States,\ndisplay: '0',\narg1: 0,\narg2: 0,\nop: '',\nstack: []\n};\nexport type State = typeof state;\n\nconst view = ({ _state, op, arg1, arg2, display, stack }: State) =&gt; &lt;&gt;\n&lt;style&gt; {`\n    .calculator { width: 200px; }\n    .buttons {\n      display: grid;\n      grid-template-columns: repeat(4, 1fr);\n      grid-gap: 2px;\n    }\n    button { padding: 10px; width:100%; }\n    button:nth-of-type(1) {\n      grid-column: span 2;\n    }\n    button:nth-of-type(16) {\n      grid-column: span 2;\n    }\n  `}\n&lt;/style&gt;\n&lt;div class=\"calculator\"&gt;\n&lt;h1&gt;{display}&lt;/h1&gt;\n&lt;div class=\"buttons\" $onclick={button_click}&gt;\n&lt;button&gt;CE&lt;/button&gt;\n&lt;button&gt;+/-&lt;/button&gt;\n&lt;button&gt;/&lt;/button&gt;\n&lt;button&gt;7&lt;/button&gt;\n&lt;button&gt;8&lt;/button&gt;\n&lt;button&gt;9&lt;/button&gt;\n&lt;button&gt;*&lt;/button&gt;\n&lt;button&gt;4&lt;/button&gt;\n&lt;button&gt;5&lt;/button&gt;\n&lt;button&gt;6&lt;/button&gt;\n&lt;button&gt;-&lt;/button&gt;\n&lt;button&gt;1&lt;/button&gt;\n&lt;button&gt;2&lt;/button&gt;\n&lt;button&gt;3&lt;/button&gt;\n&lt;button&gt;+&lt;/button&gt;\n&lt;button&gt;0&lt;/button&gt;\n&lt;button&gt;.&lt;/button&gt;\n&lt;button&gt;=&lt;/button&gt;\n&lt;/div&gt;\n&lt;small&gt;\n{stack.length &gt; 0 &amp;&amp; `${stack[0][0]} ${stack[0][1]} `}\n{_state.startsWith(\"FIRST_\") &amp;&amp; `${display}`}\n{_state === \"OP\" &amp;&amp; `${arg1} ${op}`}\n{_state.startsWith(\"SECOND_\") &amp;&amp; `${arg1} ${op} ${display}`}\n{_state === \"EQ\" &amp;&amp; `${arg1} ${op} ${arg2} = ${display}`}\n&lt;/small&gt;\n&lt;/div&gt;\n&lt;/&gt;;\n\nexport const button_click = (state: State, e: any) =&gt; {\n\nconst priority = {\n'*': 2,\n'/': 2,\n'+': 1,\n'-': 1\n}\n\nconst getEvent = (c: string): Events =&gt; {\nswitch (c) {\ncase '+/-':\nreturn '+/-';\ncase 'CE':\nreturn 'CE';\ncase '.':\nreturn 'DOT';\ncase '=':\nreturn 'EQ';\ndefault:\nreturn /\\d/.test(c) ? 'NUM' : 'OP';\n}\n};\n\nconst key = e.target?.textContent || e;\nconst event = getEvent(key);\n\nlet { _state, op, arg1, arg2, display, stack } = state;\n\nconst clear = () =&gt; {\ndisplay = '0';\narg1 = arg2 = 0;\nop = '';\nstack.length = 0;\n}\n\nconst negative = () =&gt; {\ndisplay = display.startsWith('-') ? display.substring(1) : '-' + display;\n};\n\nconst calc = () =&gt; {\ndisplay = eval(`${arg1}${op}${arg2}`).toString();\n};\n\nconst op1 = () =&gt; {\nop = key;\narg1 = parseFloat(display);\n};\n\nconst op2 = () =&gt; {\nif (priority[key] === priority[op]) {\narg2 = parseFloat(display);\ncalc();\nop = key;\narg1 = parseFloat(display);\n} else if (priority[key] &lt; priority[op]) {\narg2 = parseFloat(display);\ncalc();\narg1 = parseFloat(display);\nop = key;\nif (stack.length) {\nconst f = stack.pop();\narg1 = eval(`${f[0]}${f[1]}${display}`);\ndisplay = arg1.toString();\n}\n} else {\nstack.push([arg1, op]);\narg1 = parseFloat(display);\nop = key;\n}\n\n};\n\nconst eq0 = () =&gt; {\narg1 = parseFloat(display);\ncalc();\n};\n\nconst eq2 = () =&gt; {\narg2 = parseFloat(display);\ncalc();\nif (stack.length) {\narg2 = parseFloat(display);\nconst f = stack.pop();\ndisplay = eval(`${f[0]}${f[1]}${display}`).toString();\narg1 = f[0];\nop = f[1];\n}\n};\n\nconst state_machine: StateMachine&lt;States, Events&gt; = {\nSTART: [\n['NUM', 'FIRST_ARG', () =&gt; display = key],\n['DOT', 'FIRST_ARG_FLOAT', () =&gt; display = '0.']\n],\n\nFIRST_ARG: [\n['+/-', 'FIRST_ARG', negative],\n['NUM', 'FIRST_ARG', () =&gt; display += key],\n['DOT', 'FIRST_ARG_FLOAT', () =&gt; display += key],\n['OP', 'OP', op1],\n['CE', 'START', clear]\n],\n\nFIRST_ARG_FLOAT: [\n['+/-', 'FIRST_ARG_FLOAT', negative],\n['NUM', 'FIRST_ARG_FLOAT', () =&gt; display += key],\n['OP', 'OP', op1],\n['CE', 'START', clear]\n],\n\nOP: [\n['NUM', 'SECOND_ARG', () =&gt; display = key],\n['DOT', 'SECOND_ARG', () =&gt; display = '0.'],\n['OP', 'OP', () =&gt; op = key],\n['CE', 'START', clear]\n],\n\nSECOND_ARG: [\n['+/-', 'SECOND_ARG', negative],\n['NUM', 'SECOND_ARG', () =&gt; display += key],\n['DOT', 'SECOND_ARG_FLOAT', () =&gt; display += key],\n['EQ', 'EQ', eq2],\n['OP', 'OP', op2],\n['CE', 'OP', () =&gt; display = '0']\n],\n\nSECOND_ARG_FLOAT: [\n['+/-', 'SECOND_ARG_FLOAT', negative],\n['NUM', 'SECOND_ARG_FLOAT', () =&gt; display += key],\n['EQ', 'EQ', eq2],\n['OP', 'OP', op2],\n['CE', 'OP', () =&gt; display = '0']\n],\n\nEQ: [\n['+/-', 'FIRST_ARG', negative],\n['NUM', 'FIRST_ARG', () =&gt; display = key],\n['DOT', 'FIRST_ARG_FLOAT', () =&gt; display = '0.'],\n['EQ', 'EQ', eq0],\n['OP', 'OP', op1],\n['CE', 'START', clear]\n]\n};\n\nconst { next_state, transition } = find_transition(state_machine, _state, event);\n_state = next_state || _state;\ntransition &amp;&amp; transition();\n\nreturn { _state, op, arg1, arg2, display, stack };\n};\n\nconst update = {\n'#calculator': state =&gt; state\n};\n\nexport default element =&gt; new Component(state, view, update).mount(element);\n</code></pre> calculator specs <pre><code>import { button_click, State } from './calculator';\n\nconst state: State = {\n_state: 'START',\ndisplay: '0',\narg1: 0,\narg2: 0,\nop: '',\nstack: []\n};\n\nconst click = (input: string) =&gt; {\nconst keys = [...input];\nlet s = state;\nkeys.forEach(key =&gt; {\nconst new_state = button_click(s, key);\ns = new_state\n})\nreturn s;\n}\n\ndescribe('calculator', () =&gt; {\n\nit('case 1', () =&gt; {\nconst { _state, display } = click('1');\nexpect(display).toBe('1');\nexpect(_state).toBe('FIRST_ARG');\n})\n\nit('case 2', () =&gt; {\nconst { _state, display } = click('12');\nexpect(display).toBe('12');\nexpect(_state).toBe('FIRST_ARG');\n})\n\nit('case 3', () =&gt; {\nconst { _state, display, arg1, arg2 } = click('1+2=');\nexpect(display).toBe('3');\nexpect(arg1).toBe(1);\nexpect(arg2).toBe(2);\nexpect(_state).toBe('EQ');\n})\n\nit('case 4', () =&gt; {\nconst { _state, display } = click('1/');\nexpect(display).toBe('1');\nexpect(_state).toBe('OP');\n})\n\nit('case 5', () =&gt; {\nconst { _state, display } = click('1/2');\nexpect(display).toBe('2');\nexpect(_state).toBe('SECOND_ARG');\n})\n\nit('case 6', () =&gt; {\nconst { _state, display, op } = click('1//');\nexpect(display).toBe('1');\nexpect(op).toBe('/');\nexpect(_state).toBe('OP');\n})\n\nit('case 7', () =&gt; {\nconst { _state, display, op } = click('1/=');\nexpect(display).toBe('1');\nexpect(op).toBe('/');\nexpect(_state).toBe('OP');\n})\n\nit('case 8', () =&gt; {\nconst { _state, display, op } = click('1/+');\nexpect(display).toBe('1');\nexpect(op).toBe('+');\nexpect(_state).toBe('OP');\n})\n\nit('case 9', () =&gt; {\nconst { _state, display } = click('1/10');\nexpect(display).toBe('10');\nexpect(_state).toBe('SECOND_ARG');\n})\n\nit('case 10', () =&gt; {\nconst { _state, display } = click('1+1.');\nexpect(display).toBe('1.');\nexpect(_state).toBe('SECOND_ARG_FLOAT');\n})\n\nit('case 11', () =&gt; {\nconst { _state, display } = click('0.');\nexpect(display).toBe('0.');\nexpect(_state).toBe('FIRST_ARG_FLOAT');\n})\n\nit('case 12', () =&gt; {\nconst { _state, display } = click('=');\nexpect(display).toBe('0');\nexpect(_state).toBe('START');\n})\n\nit('case 13', () =&gt; {\nconst { _state, display } = click('/');\nexpect(display).toBe('0');\nexpect(_state).toBe('START');\n})\n\nit('case 14', () =&gt; {\nconst { _state, display } = click('1+2=5');\nexpect(display).toBe('5');\nexpect(_state).toBe('FIRST_ARG');\n})\n\nit('case 15', () =&gt; {\nconst { _state, display } = click('1+2=/');\nexpect(display).toBe('3');\nexpect(_state).toBe('OP');\n})\n\nit('case 16', () =&gt; {\nconst { _state, display } = click('1/+=');\nexpect(display).toBe('1');\nexpect(_state).toBe('OP');\n})\n\nit('case 17', () =&gt; {\nconst { _state, display } = click('1+2=*3=');\nexpect(display).toBe('9');\nexpect(_state).toBe('EQ');\n})\n\nit('case 18', () =&gt; {\nconst { _state, display, arg1, arg2 } = click('1+2*3=');\nexpect(display).toBe('7');\nexpect(arg1).toBe(1);\nexpect(arg2).toBe(6);\nexpect(_state).toBe('EQ');\n})\n\nit('case 19', () =&gt; {\nconst { _state, display, arg1, arg2 } = click('1*2+3=');\nexpect(display).toBe('5');\nexpect(arg1).toBe(2);\nexpect(arg2).toBe(3);\nexpect(_state).toBe('EQ');\n})\n\nit('case 20', () =&gt; {\nconst { _state, display } = click('1+2*3*');\nexpect(display).toBe('6');\nexpect(_state).toBe('OP');\n})\n\n});\n</code></pre>"},{"location":"architecture-ideas/state-machine/#conclusion","title":"Conclusion","text":"<p>We have created a declarative and type-safe state machine. The state machine data structure is technology agnostic. You can try to use it in React or other frameworks you like. It can naturally fit into AppRun applications.</p> <p>AppRun is event-driven. Often I feel it is challenging to make events right. Sometimes we define too many events. Sometimes the events come out of order. By using the state machine, I can handle the events within limited state scopes. I have started to think of using more state machines to control the events.</p>"},{"location":"architecture-ideas/state-machine/#references","title":"References","text":"<p>There are many references online about the state machine. I got most of my inspiration from the following posts. I recommend you read the concept explanation of the posts and pay less attention to the implementations because using AppRun; you can do better.</p> <ul> <li> <p>[1] Krasimir Tsonev explains Mealy and Moore in the post: The Rise Of The State Machines</p> </li> <li> <p>[2] Jon Bellah describes the paradigm shift from event-driven to the state machine in this post: A Complete Introduction to State Machines in JavaScript</p> </li> <li> <p>[3] Erik Mogensen explains state machine and introduced the statechart in this post: What is a state machine?</p> </li> </ul> <p>Have fun coding!</p>"}]}