{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to AppRun Docs \u00b6 Welcome to the AppRun user guide! This guide shows you how to get started creating web applications using AppRun . What is AppRun? \u00b6 AppRun is a JavaScript library for building applications. But, you may ask, there are many successful Javascript frameworks and libraries like Angular, React, Vue, and Svelte already; why AppRun? AppRun provides elm-inspired architecture and embraces the event-driven programming pattern, making AppRun different from other frameworks and libraries. AppRun has the following benefits overall. Clean architecture that needs less code * State management and routing included * No proprietary syntax to learn (no hooks) * Use directly in the browser or with a compiler/bundler * Advanced features: JSX, Web Components, Dev Tools, SSR, etc. Is AppRun for me? \u00b6 If you are a beginner developer, you will learn how to build web applications with outstanding architecture quickly. Also, what you learned in AppRun will help you to understand other frameworks and libraries. If you are an experienced developer, you will learn AppRun is a lightweight alternative to other frameworks and libraries. As a result, you will have one more good tool in your toolbox to meet your client's needs. Note Most of the code snippets in this guide are interactive you can edit and see the results. Ready to try it yourself? Head over to Getting Started or explore the AppRun Architecture .","title":"Home"},{"location":"#welcome-to-apprun-docs","text":"Welcome to the AppRun user guide! This guide shows you how to get started creating web applications using AppRun .","title":"Welcome to AppRun Docs"},{"location":"#what-is-apprun","text":"AppRun is a JavaScript library for building applications. But, you may ask, there are many successful Javascript frameworks and libraries like Angular, React, Vue, and Svelte already; why AppRun? AppRun provides elm-inspired architecture and embraces the event-driven programming pattern, making AppRun different from other frameworks and libraries. AppRun has the following benefits overall. Clean architecture that needs less code * State management and routing included * No proprietary syntax to learn (no hooks) * Use directly in the browser or with a compiler/bundler * Advanced features: JSX, Web Components, Dev Tools, SSR, etc.","title":"What is AppRun?"},{"location":"#is-apprun-for-me","text":"If you are a beginner developer, you will learn how to build web applications with outstanding architecture quickly. Also, what you learned in AppRun will help you to understand other frameworks and libraries. If you are an experienced developer, you will learn AppRun is a lightweight alternative to other frameworks and libraries. As a result, you will have one more good tool in your toolbox to meet your client's needs. Note Most of the code snippets in this guide are interactive you can edit and see the results. Ready to try it yourself? Head over to Getting Started or explore the AppRun Architecture .","title":"Is AppRun for me?"},{"location":"3rd-party-libs/","text":"3rd Party Libraries \u00b6 Using jQuery and jQuery plugins is not an anti-pattern. On the contrary, it is welcomed and encouraged. AppRun embraces 3rd libraries and recommends you use them in your AppRun application development. AppRun was designed to support 3rd party libraries in mind. The AppRun VDOM is resilient to allow other libraries to change to DOM. You can embed a DOM element into JSX or use the JSX ref attribute. Embed Element \u00b6 It is straightforward to create a DOM element and modify it using the 3rd party library. The DOM element can be embedded into JSX directly. e.g., the example of using chart.js below. The chart.js example above also demonstrates using the unload function to destroy the Chart object. export default class extends Component { state = { data : { /* ... */ } }; view = state => { const canvas = document . createElement ( 'canvas' ); const ctx = canvas . getContext ( '2d' ); state . chart = new Chart ( ctx , state . data ); return ( < Card header = \"Chart JS\" > { canvas } < /Card> ); }; unload = state => { state . chart ? . destroy (); console . log ( 'chart destroyed' ); } } Ref Attribute \u00b6 The JSX ref attribute is a callback function called when the specific DOM element is rendered. The DOM element can be any element in JSX. e.g., the d3 example below. The d3 example also demonstrates using the mounted function to initialize the state as a Promise . const map = ( element , features ) => { /*...*/ } export default class extends Component { state = {}; view = features => ( < Card header = { < div id = \"map-text\" > D3 Map < /div>}> < svg ref = { el => map ( el , features )} >< /svg> < /Card> ); mounted = () => new Promise (( resolve , reject ) => { d3 . json ( './world-110m.json' , ( error , topo ) => { if ( error ) throw reject ( error ); const features = topojson . feature ( topo , topo . objects . countries ) . features ; resolve ( features ); }); }); } Combing component life cycle events and embedding DOM and the ref attribute provides a convenient way to use 3rd party libraries in the AppRun application. You can find out more from the following examples. Bootstrap Admin Dashboard \u00b6 The bootstrap admin dashboard uses the Bootstrap layout. It also uses jQuery DataTables and FullCalendar and chart.js and D3. CoreUI Admin Template \u00b6 Another example is using the CoreUI for AppRun application .","title":"3rd Party Intergration"},{"location":"3rd-party-libs/#3rd-party-libraries","text":"Using jQuery and jQuery plugins is not an anti-pattern. On the contrary, it is welcomed and encouraged. AppRun embraces 3rd libraries and recommends you use them in your AppRun application development. AppRun was designed to support 3rd party libraries in mind. The AppRun VDOM is resilient to allow other libraries to change to DOM. You can embed a DOM element into JSX or use the JSX ref attribute.","title":"3rd Party Libraries"},{"location":"3rd-party-libs/#embed-element","text":"It is straightforward to create a DOM element and modify it using the 3rd party library. The DOM element can be embedded into JSX directly. e.g., the example of using chart.js below. The chart.js example above also demonstrates using the unload function to destroy the Chart object. export default class extends Component { state = { data : { /* ... */ } }; view = state => { const canvas = document . createElement ( 'canvas' ); const ctx = canvas . getContext ( '2d' ); state . chart = new Chart ( ctx , state . data ); return ( < Card header = \"Chart JS\" > { canvas } < /Card> ); }; unload = state => { state . chart ? . destroy (); console . log ( 'chart destroyed' ); } }","title":"Embed Element"},{"location":"3rd-party-libs/#ref-attribute","text":"The JSX ref attribute is a callback function called when the specific DOM element is rendered. The DOM element can be any element in JSX. e.g., the d3 example below. The d3 example also demonstrates using the mounted function to initialize the state as a Promise . const map = ( element , features ) => { /*...*/ } export default class extends Component { state = {}; view = features => ( < Card header = { < div id = \"map-text\" > D3 Map < /div>}> < svg ref = { el => map ( el , features )} >< /svg> < /Card> ); mounted = () => new Promise (( resolve , reject ) => { d3 . json ( './world-110m.json' , ( error , topo ) => { if ( error ) throw reject ( error ); const features = topojson . feature ( topo , topo . objects . countries ) . features ; resolve ( features ); }); }); } Combing component life cycle events and embedding DOM and the ref attribute provides a convenient way to use 3rd party libraries in the AppRun application. You can find out more from the following examples.","title":"Ref Attribute"},{"location":"3rd-party-libs/#bootstrap-admin-dashboard","text":"The bootstrap admin dashboard uses the Bootstrap layout. It also uses jQuery DataTables and FullCalendar and chart.js and D3.","title":"Bootstrap Admin Dashboard"},{"location":"3rd-party-libs/#coreui-admin-template","text":"Another example is using the CoreUI for AppRun application .","title":"CoreUI Admin Template"},{"location":"about/","text":"Introduction \u00b6 The recently updated AppRun Docs Site has made the code snippets in the documents runnable and editable, making the technical documentation interactive and much more fun to use. The site is built with Material for MkDocs , a beautiful and powerful tool for building technical documentation sites. We extended it by adding a web component built with AppRun to deliver interactive experiences. In this post, I Will explain how it's made. Let's start with reviewing the user experience. User Experience \u00b6 Technical documents usually have code snippets. Often the code has syntax highlighted for easy reading. However, users usually can only see screenshots but not live results of the code. Screenshots have limitations. For example, when describing how to make animation, a static screenshot is not helpful. We need a way to display the live code execution results. See the Results \u00b6 You can visit the AppRun Docs Page to see a live animation. Try the Code \u00b6 Furthermore, users might have been inspired by the code examples and want to try different ideas. Traditionally, they could copy and paste the code to run it in their code editors. It would be nice for users to edit the code right on the doc site and see the results. You can click the \"Try the Code\" button of the AppRun Docs Page . It opens the AppRun Playground with an editor and preview pane to play the code. The user experiences have improved with the capabilities of seeing the code results and trying the code in technical documents. Author Experience \u00b6 Not only is it much more attractive to the readers, but also the authors will feel it is much more enjoyable when writing the documents. Present the Live Code \u00b6 Traditionally, authors copy and paste the code snippets from their testing projects into the markdown documents as code blocks. The limitation is that they can only present the code but not the running code. Sometimes, it would be hard to describe the code behavior. For example, describing a calculator could need a long text, but it could be easier to present the calculator for users to click. You can visit the AppRun Docs Page to see a running calculator. All we need to do is to add a web component, called apprun-play under the code blocks. ```js // code snippets ``` <apprun-play></apprun-play> ``` Control the Presentation \u00b6 You probably have noticed that the page shows only the results but not the source code. It is because we can control whether to show the source code. We can also decide whether to see the \"Try the Code\" button. ```js // code snippets ``` <apprun-play hide_src=\"true\" hide_button=\"true\"></apprun-play> You can visit the AppRun Docs Page to see an example of only displaying the running results. We can present the code snippets, but we can also embed whole applications because the apprun-play web component supports HTML. We can use the embedding external files feature of Material for MkDocs . This way, the markdown document does not include the source code and can remain simple and clean. Automatic Test of the Code When it displays the code result automatically means automatic testing of the code, which tells the author if the code works as expected. Also, while writing, the authors can come up with new ideas. With apprun-play web component, they can edit the code and see the live results. Once it's done, they can copy and paste the code back into the document. Overall, the apprun-play web component is a helpful tool for the document author. How It's Made \u00b6 Web components/custom elements are safe in the markdown documents. We can build web components out of the AppRun Components quickly. The apprun-play web component is an AppRun component that gets the source code from its previous sibling element, a textarea , or a div with highlighted code. Then, the apprun-play web component creates an iframe for the code. You can find the source code here . You can download compiled the apprun-play web component and add it to the configuration file of Material for MkDocs, mkdocs.yml extra_css: - assets/vendor/codemirror/codemirror.css extra_javascript: - assets/vendor/codemirror/codemirror.js - assets/vendor/codemirror/mode/javascript/javascript.js - assets/vendor/codemirror/mode/xml/xml.js - assets/vendor/codemirror/mode/jsx/jsx.js - assets/apprun-play.js That's it. The apprun-play web component is ready for use in all the markdown documents. Finally, the AppRun Docs Site Github project is: https://github.com/apprunjs/apprun-docs/ Please enjoy and send pull requests.","title":"About"},{"location":"about/#introduction","text":"The recently updated AppRun Docs Site has made the code snippets in the documents runnable and editable, making the technical documentation interactive and much more fun to use. The site is built with Material for MkDocs , a beautiful and powerful tool for building technical documentation sites. We extended it by adding a web component built with AppRun to deliver interactive experiences. In this post, I Will explain how it's made. Let's start with reviewing the user experience.","title":"Introduction"},{"location":"about/#user-experience","text":"Technical documents usually have code snippets. Often the code has syntax highlighted for easy reading. However, users usually can only see screenshots but not live results of the code. Screenshots have limitations. For example, when describing how to make animation, a static screenshot is not helpful. We need a way to display the live code execution results.","title":"User Experience"},{"location":"about/#see-the-results","text":"You can visit the AppRun Docs Page to see a live animation.","title":"See the Results"},{"location":"about/#try-the-code","text":"Furthermore, users might have been inspired by the code examples and want to try different ideas. Traditionally, they could copy and paste the code to run it in their code editors. It would be nice for users to edit the code right on the doc site and see the results. You can click the \"Try the Code\" button of the AppRun Docs Page . It opens the AppRun Playground with an editor and preview pane to play the code. The user experiences have improved with the capabilities of seeing the code results and trying the code in technical documents.","title":"Try the Code"},{"location":"about/#author-experience","text":"Not only is it much more attractive to the readers, but also the authors will feel it is much more enjoyable when writing the documents.","title":"Author Experience"},{"location":"about/#present-the-live-code","text":"Traditionally, authors copy and paste the code snippets from their testing projects into the markdown documents as code blocks. The limitation is that they can only present the code but not the running code. Sometimes, it would be hard to describe the code behavior. For example, describing a calculator could need a long text, but it could be easier to present the calculator for users to click. You can visit the AppRun Docs Page to see a running calculator. All we need to do is to add a web component, called apprun-play under the code blocks. ```js // code snippets ``` <apprun-play></apprun-play> ```","title":"Present the Live Code"},{"location":"about/#control-the-presentation","text":"You probably have noticed that the page shows only the results but not the source code. It is because we can control whether to show the source code. We can also decide whether to see the \"Try the Code\" button. ```js // code snippets ``` <apprun-play hide_src=\"true\" hide_button=\"true\"></apprun-play> You can visit the AppRun Docs Page to see an example of only displaying the running results. We can present the code snippets, but we can also embed whole applications because the apprun-play web component supports HTML. We can use the embedding external files feature of Material for MkDocs . This way, the markdown document does not include the source code and can remain simple and clean. Automatic Test of the Code When it displays the code result automatically means automatic testing of the code, which tells the author if the code works as expected. Also, while writing, the authors can come up with new ideas. With apprun-play web component, they can edit the code and see the live results. Once it's done, they can copy and paste the code back into the document. Overall, the apprun-play web component is a helpful tool for the document author.","title":"Control the Presentation"},{"location":"about/#how-its-made","text":"Web components/custom elements are safe in the markdown documents. We can build web components out of the AppRun Components quickly. The apprun-play web component is an AppRun component that gets the source code from its previous sibling element, a textarea , or a div with highlighted code. Then, the apprun-play web component creates an iframe for the code. You can find the source code here . You can download compiled the apprun-play web component and add it to the configuration file of Material for MkDocs, mkdocs.yml extra_css: - assets/vendor/codemirror/codemirror.css extra_javascript: - assets/vendor/codemirror/codemirror.js - assets/vendor/codemirror/mode/javascript/javascript.js - assets/vendor/codemirror/mode/xml/xml.js - assets/vendor/codemirror/mode/jsx/jsx.js - assets/apprun-play.js That's it. The apprun-play web component is ready for use in all the markdown documents. Finally, the AppRun Docs Site Github project is: https://github.com/apprunjs/apprun-docs/ Please enjoy and send pull requests.","title":"How It's Made"},{"location":"apprun-site-build/","text":"AppRun-Site Build \u00b6 The AppRun-Site build command compiles your page to ES Modules with esbuild . npx apprun-site build The build command scans your pages in the pages directory and compiles them into the public directory. /public <- compiled site /index.html <- copied from `pages/index.html` /index.js <- compiled from `pages/index.md` /main.js <- compiled from `pages/main.tsx` and some bootstrap code /about index.js <- compiled from `pages/about/index.md` /contact index.js <- compiled from `pages/contact/index.tsx` /pages <- source pages /index.html <- index page /index.md <- home page /main.tsx <- start up code /about index.md <- about page, markdown /contact contact.tsx <- contact page, AppRun component The compiled js files are ES modules. They are compatible on the client-side and server-side. Next, you will learn about client-side rendering .","title":"Build"},{"location":"apprun-site-build/#apprun-site-build","text":"The AppRun-Site build command compiles your page to ES Modules with esbuild . npx apprun-site build The build command scans your pages in the pages directory and compiles them into the public directory. /public <- compiled site /index.html <- copied from `pages/index.html` /index.js <- compiled from `pages/index.md` /main.js <- compiled from `pages/main.tsx` and some bootstrap code /about index.js <- compiled from `pages/about/index.md` /contact index.js <- compiled from `pages/contact/index.tsx` /pages <- source pages /index.html <- index page /index.md <- home page /main.tsx <- start up code /about index.md <- about page, markdown /contact contact.tsx <- contact page, AppRun component The compiled js files are ES modules. They are compatible on the client-side and server-side. Next, you will learn about client-side rendering .","title":"AppRun-Site Build"},{"location":"apprun-site-cli/","text":"AppRun-Site Command Line \u00b6 The AppRun-site command line has the following commands: Usage: apprun-site [options] [command] Options: -h, --help display help for command Commands: init [options] [targetDir] initialize a new app build [options] [source] build site serv [options] [source] launch development server, watch and no live reload dev [options] [source] launch development server, watch and live reload help [command] display help for command Build Command Options \u00b6 You can use the following command-line options for the build command. Usage: apprun-site build [ options ] [ source ] build site Options: -c, --clean clean the output directory ( default: false ) -w, --watch watch the directory ( default: false ) -r, --render pre-render html pages ( default: false ) -o, --output [ output ] output directory ( default: \"public\" ) -p, --pages [ pages ] pages directory ( default: \"pages\" ) -h, --help display help for command Dev Command Options \u00b6 Usage: apprun-site dev [ options ] [ source ] launch development server, watch and live reload Options: -o, --output [ output ] output directory ( default: \"public\" ) -p, --pages [ pages ] pages directory ( default: \"pages\" ) -n, --no_ssr disable server side rendering ( default: false ) -h, --help display help for command \u279c apprun git: ( master ) \u2717 npx apprun-site@latest serve -h Serv Command Options \u00b6 Usage: apprun-site serv [options] [source] launch development server, watch and no live reload Options: -o, --output [output] output directory (default: \"public\") -p, --pages [pages] pages directory (default: \"pages\") -n, --no_ssr disable server side rendering (default: false) -h, --help display help for command AppRun-Site Config File \u00b6 In addition, you can also customize the AppRun-Site in the apprun-site.yml config file. site_name: AppRun Site site_url: / no-startup: true # don't inject startup code for dynamic routing no-sss: true # don't use server-side-rendering dev-server: port: 8080 static-pages: # additional pages to pre-render for the static site - /products/1 - /products/2 - /products/3 WIP, more options to come.","title":"AppRun-Site CLI"},{"location":"apprun-site-cli/#apprun-site-command-line","text":"The AppRun-site command line has the following commands: Usage: apprun-site [options] [command] Options: -h, --help display help for command Commands: init [options] [targetDir] initialize a new app build [options] [source] build site serv [options] [source] launch development server, watch and no live reload dev [options] [source] launch development server, watch and live reload help [command] display help for command","title":"AppRun-Site Command Line"},{"location":"apprun-site-cli/#build-command-options","text":"You can use the following command-line options for the build command. Usage: apprun-site build [ options ] [ source ] build site Options: -c, --clean clean the output directory ( default: false ) -w, --watch watch the directory ( default: false ) -r, --render pre-render html pages ( default: false ) -o, --output [ output ] output directory ( default: \"public\" ) -p, --pages [ pages ] pages directory ( default: \"pages\" ) -h, --help display help for command","title":"Build Command Options"},{"location":"apprun-site-cli/#dev-command-options","text":"Usage: apprun-site dev [ options ] [ source ] launch development server, watch and live reload Options: -o, --output [ output ] output directory ( default: \"public\" ) -p, --pages [ pages ] pages directory ( default: \"pages\" ) -n, --no_ssr disable server side rendering ( default: false ) -h, --help display help for command \u279c apprun git: ( master ) \u2717 npx apprun-site@latest serve -h","title":"Dev Command Options"},{"location":"apprun-site-cli/#serv-command-options","text":"Usage: apprun-site serv [options] [source] launch development server, watch and no live reload Options: -o, --output [output] output directory (default: \"public\") -p, --pages [pages] pages directory (default: \"pages\") -n, --no_ssr disable server side rendering (default: false) -h, --help display help for command","title":"Serv Command Options"},{"location":"apprun-site-cli/#apprun-site-config-file","text":"In addition, you can also customize the AppRun-Site in the apprun-site.yml config file. site_name: AppRun Site site_url: / no-startup: true # don't inject startup code for dynamic routing no-sss: true # don't use server-side-rendering dev-server: port: 8080 static-pages: # additional pages to pre-render for the static site - /products/1 - /products/2 - /products/3 WIP, more options to come.","title":"AppRun-Site Config File"},{"location":"apprun-site-csr/","text":"AppRun-Site Client-Side Rendering \u00b6 The AppRun-Site build command creates pages as ES modules that can be loaded dynamically. The AppRun-Site build command injects the client-side code into the main.js file for routing and loading the pages. To conclude, AppRun Sites are Single Page Applications (SPA). App Startup \u00b6 If you have a startup code, you can add it to the main.tsx file. The AppRun-Site build command injects calls to the default exported function of the main.tsx file. /pages <- pages of the website /main.tsx <- startup code Example of a markdown page: \u00b6 import app from 'apprun' ; import Layout from '../components/layout' import Comic from '../components/comic' ; export default () => { app . webComponent ( 'ws-comic' , Comic ); // register web component app . render ( document . body , < Layout /> ); // render site layout } No-Code Routing \u00b6 You don't need to write any code to route an URL to a component. When users visit an URL, the client-side code will load, route, and render the page dynamically. E.g., when the URL in the browser address bar becomes http://.../contact, it triggers the /contact event. The Contact component reacts to the /contact and renders itself to the screen. The event handler for the /contact event is also injected. Therefore, there is no need to code for routing. Routing Parameters \u00b6 However, if you want to pass parameters to the component through the URL, you can create your event handler. For example: import { app , Component } from 'apprun' ; export default class extends Component { state = async () => { ... } view = state => < div > ... < /div>; update = { '/products' : async ( state , id ) => { state = await Promise . resolve ( state ); return ({ ... state , id : parseInt ( id ) }) } }; } When the URL in the browser address bar becomes http://.../products/1, it triggers the /products event and passes the 1 as the parameter to your event handler. Pretty Links \u00b6 AppRun-Site injects code by default to support pretty links (a.k.a. non-hash links), e.g., http://.../products/1. You don't need to write any code to support pretty links. However, you will need a webserver to serve the index.html when the routes don't exist on the server. The AppRun-Site dev server provides such capability of serving index.html when the routes don't exist. Next, you will see how to use the dev server and how it renders your pages on the server side .","title":"Client-Side Rendering"},{"location":"apprun-site-csr/#apprun-site-client-side-rendering","text":"The AppRun-Site build command creates pages as ES modules that can be loaded dynamically. The AppRun-Site build command injects the client-side code into the main.js file for routing and loading the pages. To conclude, AppRun Sites are Single Page Applications (SPA).","title":"AppRun-Site Client-Side Rendering"},{"location":"apprun-site-csr/#app-startup","text":"If you have a startup code, you can add it to the main.tsx file. The AppRun-Site build command injects calls to the default exported function of the main.tsx file. /pages <- pages of the website /main.tsx <- startup code","title":"App Startup"},{"location":"apprun-site-csr/#example-of-a-markdown-page","text":"import app from 'apprun' ; import Layout from '../components/layout' import Comic from '../components/comic' ; export default () => { app . webComponent ( 'ws-comic' , Comic ); // register web component app . render ( document . body , < Layout /> ); // render site layout }","title":"Example of a markdown page:"},{"location":"apprun-site-csr/#no-code-routing","text":"You don't need to write any code to route an URL to a component. When users visit an URL, the client-side code will load, route, and render the page dynamically. E.g., when the URL in the browser address bar becomes http://.../contact, it triggers the /contact event. The Contact component reacts to the /contact and renders itself to the screen. The event handler for the /contact event is also injected. Therefore, there is no need to code for routing.","title":"No-Code Routing"},{"location":"apprun-site-csr/#routing-parameters","text":"However, if you want to pass parameters to the component through the URL, you can create your event handler. For example: import { app , Component } from 'apprun' ; export default class extends Component { state = async () => { ... } view = state => < div > ... < /div>; update = { '/products' : async ( state , id ) => { state = await Promise . resolve ( state ); return ({ ... state , id : parseInt ( id ) }) } }; } When the URL in the browser address bar becomes http://.../products/1, it triggers the /products event and passes the 1 as the parameter to your event handler.","title":"Routing Parameters"},{"location":"apprun-site-csr/#pretty-links","text":"AppRun-Site injects code by default to support pretty links (a.k.a. non-hash links), e.g., http://.../products/1. You don't need to write any code to support pretty links. However, you will need a webserver to serve the index.html when the routes don't exist on the server. The AppRun-Site dev server provides such capability of serving index.html when the routes don't exist. Next, you will see how to use the dev server and how it renders your pages on the server side .","title":"Pretty Links"},{"location":"apprun-site-ssr/","text":"AppRun-Site Server-Side Rendering \u00b6 The AppRun-Site serv command starts a dev server at http://localhost:8080 . npx apprun-site serv The AppRun-Site dev server serves index.html when the routes don't exist to support Single Page Apps. It also has the capability of server-side rendering to support pretty links and static site creation. ES Module \u00b6 Because the pages are compiled into ES Modules, they can be loaded dynamically. Also, thanks to the AppRun architecture , the dev server can render all the pages on the server the same way in the browser. E.g., when users visit http://.../contact, the dev server finds an ES module from /contact/index.js . The dev server loads the module dynamically and renders it to jsdom . Then, it sends the HTML from jsdom back to the browser. The exact same code, /contact/index.js, can be run on the client-side and the server-side. No special treatment is needed. Dynamic Routing \u00b6 The dev server supports dynamic routing. It searches the URL and finds the corresponding ES module. E.g., when users visit http://.../products/1, the dev server will first try to find the ES module from /products/1/index.js . Of course, /products/1/index.js does not exist, so it will try to find /products/index.js. If /products/index.js exists, it will load the module dynamically and sends 1 as the parameter for rendering. The result is that pretty links are supported on the server side. Finally, although you have a dev server for development, you may not have a node server or use a different web server in production. In this case, you can pre-render your site into a static site. Proceed to the next section to learn how to create a static site .","title":"Server-Side Rendering"},{"location":"apprun-site-ssr/#apprun-site-server-side-rendering","text":"The AppRun-Site serv command starts a dev server at http://localhost:8080 . npx apprun-site serv The AppRun-Site dev server serves index.html when the routes don't exist to support Single Page Apps. It also has the capability of server-side rendering to support pretty links and static site creation.","title":"AppRun-Site Server-Side Rendering"},{"location":"apprun-site-ssr/#es-module","text":"Because the pages are compiled into ES Modules, they can be loaded dynamically. Also, thanks to the AppRun architecture , the dev server can render all the pages on the server the same way in the browser. E.g., when users visit http://.../contact, the dev server finds an ES module from /contact/index.js . The dev server loads the module dynamically and renders it to jsdom . Then, it sends the HTML from jsdom back to the browser. The exact same code, /contact/index.js, can be run on the client-side and the server-side. No special treatment is needed.","title":"ES Module"},{"location":"apprun-site-ssr/#dynamic-routing","text":"The dev server supports dynamic routing. It searches the URL and finds the corresponding ES module. E.g., when users visit http://.../products/1, the dev server will first try to find the ES module from /products/1/index.js . Of course, /products/1/index.js does not exist, so it will try to find /products/index.js. If /products/index.js exists, it will load the module dynamically and sends 1 as the parameter for rendering. The result is that pretty links are supported on the server side. Finally, although you have a dev server for development, you may not have a node server or use a different web server in production. In this case, you can pre-render your site into a static site. Proceed to the next section to learn how to create a static site .","title":"Dynamic Routing"},{"location":"apprun-site-static/","text":"AppRun-Site - Static Site \u00b6 The AppRun-Site build command has the option to render your pages into HTML files and create a static website. npx apprun-site build --render The build command first scans and compiles your pages in the pages directory and then downloads them into the public directory by leveraging the dev server's server-side rendering. /public <- compiled site /index.html <- copied /index.js <- compiled /main.js <- compiled /about /index.html <- *** server-side rendered page *** index.js <- compiled /contact /index.html <- *** server-side rendered page *** index.js <- compiled /pages <- sorrce pages /index.html <- index page /index.md <- home page /main.tsx <- start up code /about index.md <- about page, markdown /contact contact.tsx <- contact page, AppRun component` With all the HTML pages created, you can deploy the static website. In the next section, you will learn the AppRun-Site command line .","title":"Static Web Site"},{"location":"apprun-site-static/#apprun-site-static-site","text":"The AppRun-Site build command has the option to render your pages into HTML files and create a static website. npx apprun-site build --render The build command first scans and compiles your pages in the pages directory and then downloads them into the public directory by leveraging the dev server's server-side rendering. /public <- compiled site /index.html <- copied /index.js <- compiled /main.js <- compiled /about /index.html <- *** server-side rendered page *** index.js <- compiled /contact /index.html <- *** server-side rendered page *** index.js <- compiled /pages <- sorrce pages /index.html <- index page /index.md <- home page /main.tsx <- start up code /about index.md <- about page, markdown /contact contact.tsx <- contact page, AppRun component` With all the HTML pages created, you can deploy the static website. In the next section, you will learn the AppRun-Site command line .","title":"AppRun-Site - Static Site"},{"location":"apprun-site/","text":"AppRun Site \u00b6 AppRun-Site let you focus on creating web pages are created using HTML, markdown, AppRun components, and web components. AppRun-Site will take care of the rest: It compiles your pages to ES Modules It runs your pages run as Single Page Applications (SPA) It can render your pages using Server-Side Rendering (SSR) It can also generate a static website Create AppRun Site \u00b6 You can initialize a project using the npm create apprun-app command and select the AppRun Site template. npm init apprun-app [ my-app ] AppRun Site Architecture \u00b6 An AppRun-Site project has the following structure: /pages <- pages of the website /index.html <- index page /index.md <- home page /main.tsx <- start up code /about index.md <- about page, markdown /contact contact.tsx <- contact page, AppRun component Then, you can use: npm start or npm run dev to start the dev server and watch your code changes. The application will run at http://localhost:8080 . Add Pages \u00b6 You can add AppRun components, class or functional (tsx/jsx files), markdown, or html files to the pages directory. Example of an AppRun class component page: import { app , Component } from 'apprun' ; export default class ContactComponent extends Component { state = '...' ; view = state => < div > < h2 > { state } < /h2> < p > This is a class Component < /p> < /div>; } Example of an AppRun functional component page: \u00b6 import app from 'apprun' ; export default () => <> < h2 > ... < /h2> < p > This is a functional Component < /p> < /> Example of a markdown page: \u00b6 # Hello Web Component This is a markdown page with a web component to display a comic from XKCD <ws-comic></ws-comic> Example of an html page: \u00b6 < h2 > Page </ h2 > < div > This is an HTML page </ div > All the pages will be compiled into the ES modules in the public directory when you build the site. Next, you will learn how to build your site.","title":"Create"},{"location":"apprun-site/#apprun-site","text":"AppRun-Site let you focus on creating web pages are created using HTML, markdown, AppRun components, and web components. AppRun-Site will take care of the rest: It compiles your pages to ES Modules It runs your pages run as Single Page Applications (SPA) It can render your pages using Server-Side Rendering (SSR) It can also generate a static website","title":"AppRun Site"},{"location":"apprun-site/#create-apprun-site","text":"You can initialize a project using the npm create apprun-app command and select the AppRun Site template. npm init apprun-app [ my-app ]","title":"Create AppRun Site"},{"location":"apprun-site/#apprun-site-architecture","text":"An AppRun-Site project has the following structure: /pages <- pages of the website /index.html <- index page /index.md <- home page /main.tsx <- start up code /about index.md <- about page, markdown /contact contact.tsx <- contact page, AppRun component Then, you can use: npm start or npm run dev to start the dev server and watch your code changes. The application will run at http://localhost:8080 .","title":"AppRun Site Architecture"},{"location":"apprun-site/#add-pages","text":"You can add AppRun components, class or functional (tsx/jsx files), markdown, or html files to the pages directory. Example of an AppRun class component page: import { app , Component } from 'apprun' ; export default class ContactComponent extends Component { state = '...' ; view = state => < div > < h2 > { state } < /h2> < p > This is a class Component < /p> < /div>; }","title":"Add Pages"},{"location":"apprun-site/#example-of-an-apprun-functional-component-page","text":"import app from 'apprun' ; export default () => <> < h2 > ... < /h2> < p > This is a functional Component < /p> < />","title":"Example of an AppRun functional component page:"},{"location":"apprun-site/#example-of-a-markdown-page","text":"# Hello Web Component This is a markdown page with a web component to display a comic from XKCD <ws-comic></ws-comic>","title":"Example of a markdown page:"},{"location":"apprun-site/#example-of-an-html-page","text":"< h2 > Page </ h2 > < div > This is an HTML page </ div > All the pages will be compiled into the ES modules in the public directory when you build the site. Next, you will learn how to build your site.","title":"Example of an html page:"},{"location":"architecture/","text":"AppRun Architecture \u00b6 Architecture Overview \u00b6 Application logic is broken down into three separate parts in the AppRun architecture. State (a.k.a. Model) \u2014 the state of your application View \u2014 a function to display the state Update \u2014 a collection of event handlers to update the state Use a Counter as an example. const state = 0 ; const view = state => < div > < h1 > { state } < /h1> < button onclick = {()=> app . run ( '-1' )} >- 1 < /button> < button onclick = {()=> app . run ( '+1' )} >+ 1 < /button> < /div>; const update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; app . start ( document . body , state , view , update ); State \u00b6 The state can be any data structure, a number, an array, or an object that reflects the state of the application. In the _ Counter_ example, it is a number. const state = 0 ; Note You define the initial state. AppRun manages the state. Therefore the initial state is an immutable constant. View \u00b6 The view generates Virtual DOM based on the state. Finally, AppRun calculates the differences against the web page element and renders the changes. const view = state => < div > < h1 > $ { state } < /h1> < button $onclick = \"-1\" >- 1 < /button> < button $onclick = \"+1\" >+ 1 < /button> < /div>; Note AppRun allows you to choose your favorite virtual DOM technology in the view function. The example above uses JSX. You can also use lit-html, uhtml, and etc. Update \u00b6 The update is a collection of named event handlers or a dictionary of event handlers. Each event handler creates a new state from the current state. const update = { '+1' : state => state + 1 , '-1' : state => state - 1 } Note There are a few other ways to define event handlers. When the three parts, the state , view , and update are provided to AppRun to start an application, AppRun registers the event handlers defined in the update and waits for AppRun events. app . start ( document . body , state , view , update ); Next, let's review some of the benefits of AppRun Architecture. Avoid Spaghetti Code \u00b6 AppRun solves two challenging problems commonly found in application development: Let's make the Counter a bitter complicated to show how many times each button clicked. // initial state object const state = { count : 0 , count_plus : 0 , count_minus : 0 } // one view function to render the state, its' a pure function const view = ({ count , count_plus , count_minus }) => html ` <h1> ${ count } </h1> <button onclick=\"app.run('minus')\">- ( ${ count_minus } )</button> <button onclick=\"app.run('plus')\">+ ( ${ count_plus } )</button> ` // collection of state updates, state is immutable const minus = ( state ) => ({ ... state , count : state . count - 1 , count_minus : state . count_minus + 1 }); const plus = ( state ) => ({ ... state , count : state . count + 1 , count_plus : state . count_plus + 1 }); app . start ( document . body , state , view , { plus , minus }); The code below uses jQuery. jQuery is a library that provides the convenience to access and manipulate the DOM. It does not give any architectural guidance. jQuery code is similar to the vanilla JavaScript code that can go wild. A jQuery Example $ ( function () { // global state let count = 0 let count_plus = 0 let count_minus = 0 function plus () { // state update count ++ count_plus ++ // rendering $ ( '#total' ). html ( count ) $ ( '#plus' ). html ( `+ ( ${ count_plus } )` ) } function minus () { // state update count -- count_minus ++ // rendering $ ( '#total' ). html ( count ) $ ( '#minus' ). html ( `- ( ${ count_minus } )` ) } $ ( '#plus' ). on ( 'click' , plus ) $ ( '#minus' ). on ( 'click' , minus ) }) You can see from the above code that The state is shared globally. The two event handlers plus and minus both update the state directly. The two event handlers also render the DOM in different pieces. Therefore, the jQuery code has two problems: Direct State Update Rendering Fragments In much more complicated real applications, the logic could be long and tangled even more. How can we solve the problems using AppRun? AppRun Code \u00b6 AppRun includes state management, an event system, and Virtual-DOM rendering. Following the Hollywood Principle (Don't call us. We call you), we provide code pieces to AppRun and wait for AppRun to call them. During an AppRun event lifecycle: AppRun let you update the state when needed AppRun let you create a virtual DOM out of the state when needed AppRun renders the virtual DOM when needed. When using AppRun to update the state , AppRun gives the current state . Then, we create a new state based on the current state . const minus = ( state ) => ({ ... state , count : state . count - 1 , count_minus : state . count_minus + 1 }); const plus = ( state ) => ({ ... state , count : state . count + 1 , count_plus : state . count_plus + 1 }); Because there is no reference to a shared global object, it is very easy to unit-test the logic. Also, we can focus on the parts of the state that are needed to update and ignore the rest of the state using the spread operator. We only write a view function that creates a virtual DOM. AppRun renders the DOM using the diffing algorithm. It only updates the DOM that is needed to change. Therefore, although we have only one view function for all events, AppRun takes care of the differential rendering accordingly. const view = ({ count , count_plus , count_minus }) => html ` <h1> ${ count } </h1> <button onclick=\"app.run('minus')\">- ( ${ count_minus } )</button> <button onclick=\"app.run('plus')\">+ ( ${ count_plus } )</button>` The view function always returns the same result as long as the state is the same. It also does not change the state or anything outside the function, which means it has no side effects. Therefore, the view function is a pure function . There are many benefits of using the pure__ function , including but not limited to unit testing. Finally, We have a _ counter _ application shown below by putting the state, _view , and update together. // initial state object const state = { count : 0 , count_plus : 0 , count_minus : 0 } // one view function to render the state, its' a pure function const view = ({ count , count_plus , count_minus }) => html ` <h1> ${ count } </h1> <button onclick=\"app.run('minus')\">- ( ${ count_minus } )</button> <button onclick=\"app.run('plus')\">+ ( ${ count_plus } )</button> ` // collection of state updates, state is immutable const minus = ( state ) => ({ ... state , count : state . count - 1 , count_minus : state . count_minus + 1 }); const plus = ( state ) => ({ ... state , count : state . count + 1 , count_plus : state . count_plus + 1 }); app . start ( document . body , state , view , { plus , minus }); You can see that with the help of AppRun state management and DOM differential rendering, we no longer have the Direct State Update with Rendering Fragments problems. AppRun Benefits \u00b6 No matter how complex the application is, we will always have three parts, the state , view , and update . We don't mix the state update with DOM rendering. Because the three parts are decoupled, our codebase is so much easier to understand, test, and maintain. Ceremony vs. Essence \u00b6 There was the 'Ceremony vs. Essence' discussion that happened about ten years ago. At that time, Ruby was on the rise. So people compared Ruby with C# . The fundamental idea of the Ceremony vs. Essence idea appears to be that, all other things being equal, programming languages should attempt to allow programmers to clearly express the essence of their programs without being caught up in excessive ceremony provided by the programming language. -- From this post . Let's take a look at some of today's frontend technologies from the Ceremony vs. Essence point of view. We will use a simple button-click counting application as an example. const add = count => count + 1 ; const view = count => < button $onclick = { add } > Clicks : { count } < /button>; const rendered = count => console . log ( count ); app . start ( document . body , 0 , view , null , { rendered }); console . log ( 'mounted!' ); The Essence \u00b6 The essence of the application is to display a button that adds the count by one and shows the count. Also, it will log some messages in the console to mimic effects after the rendering cycle. The concept is as simple as below. < button onclick = \"count+1\" > Clicks : { count } < /button> console . log ( count ); // upon very click console . log ( 'mounted!' ); // upon mounted We will compare the 95-character essence code above with a few front-end frameworks, such as AppRun, Svelte, React Hooks, and the Vue Composition API. A framework defines a skeleton where the application defines its features to fill out the skeleton. -- you can find this quote from googling. We need to write code to plugin the essence code into the frontend frameworks, which is the ceremony. We don't want them. Less of them is better. The Ceremony \u00b6 AppRun \u00b6 Application logic is broken down into three separate parts in the AppRun architecture. const add = count => count + 1 ; const view = count => < button $onclick = { add } > Clicks : { count } < /button>; const rendered = count => console . log ( count ); app . start ( document . body , 0 , view , null , { rendered }); console . log ( 'mounted!' ); In the example above, The application's state is a number that has a default value of 0. The add function is the event handler to update the state. The view function displays the state. The rendered function runs after the DOM is rendered. The app.start function ties them all together to the document.body element. Now, we identify and cross out the ceremonies. With AppRun, the ceremony is mainly required by the JavaScript syntax, like the module import and the arrow functions. Overall, it has 226 characters, which means 58% of the code are ceremonies. Svelte \u00b6 Svelte uses a single file for a component. The file consists of a script section for the code and the UI template. It requires a compiler to turn it into runnable JavaScript code. < script > import { onMount } from 'svelte' let count = 0 ; const add = () => count + 1 ; $ : console . log ( count ) onMount (() => console . log ( 'mounted!' ) < /script> < button on : click = { add } > Clicks : { count } < /button> Behind the scene, the svelte compiler creates the component class boilerplate. Then, the compiler extracts the script block, wires up the reactivity ($:), and adds the rendering template into the boilerplate. The boilerplate does not exist in our codebase. Therefore, the svelte application has very few ceremonies. Svelte code ceremony is also mainly the JavaScript syntax requirements. Only the script tags are required by the Svelte compiler, which is worth trading with what the compiler saves. It has 217 characters, which means 56% of the code is ceremony. React Hooks \u00b6 The React code is a slightly modified version of the React Hooks Docs]( https://reactjs.org/docs/hooks-overview.html ). import React , { useState , useEffect } from 'react' ; function Example () { const [ count , setCount ] = useState ( 0 ); const add = () => setCount ( count + 1 ) useEffect (() => { console . log ( count ); }); return ( < button onClick = { add } > Clicks : { count } < /button> ); } The React code has more ceremonies than the AppRun code and Svelte code above. It has 272 characters and a 65% ceremony. The setCount, _useState , and useEffect functions are the code that deals with the React framework itself. They don't help us to express the essence of the application. They are framework ceremonies. Vue Composition API \u00b6 The Vue code is a slightly modified version of the Vue Composition API Docs . < template > < button @ click = \"add\" > Clicks : {{ count }} < /button> < /template> import { ref , watchEffect , onMounted } from 'vue' export default { setup () { const count = ref ( 0 ) function add () { count . value ++ } watchEffect (() => console . log ( count . value )) onMounted (() => console . log ( 'mounted!' )) return { count , add } } } The Vue code has 355 characters and a 73% ceremony. The ref , watchEffect , onMounted , setup, _count.value , and returning an object of count , and add are all required by the Vue framework. Sometimes, they may make writing code more difficult. Expression Comparison \u00b6 We are not stopping at only comparing the character counts or how many extra boilerplates are forced on you by the frameworks. We also compare how you express the business logic. For example, let's see how we express Increase the Counter as an example again. // AppRun const add = counter => counter + 1 ; //Svelte let count = 0 ; const add = () => counter + 1 ; // React const [ count , setCount ] = useState ( 0 ); const add = () => setCount ( count + 1 ); // Vue const count = ref ( 0 ); const add = () => count . value ++ ; Both the AppRun code and the Svelte code express the essence well and have less ceremony. So AppRun and Svelte are easy to understand. React Hooks and Vue Composition API are cool. However, they both add a lot more ceremonies to our codebase. Remember, the ceremony has no business values but just challenges to understand and maintain. In addition, AppRun has a few other benefits AppRun is lightweight that can run in browsers directly without a compiler. AppRun uses pure functions when it is possible. AppRun app codebase can easily be strongly typed if you wish. I hope you enjoy it. If you haven't clicked the 'Try the Code' buttons to run the AppRun code above, please give it a try.","title":"Overview"},{"location":"architecture/#apprun-architecture","text":"","title":"AppRun Architecture"},{"location":"architecture/#architecture-overview","text":"Application logic is broken down into three separate parts in the AppRun architecture. State (a.k.a. Model) \u2014 the state of your application View \u2014 a function to display the state Update \u2014 a collection of event handlers to update the state Use a Counter as an example. const state = 0 ; const view = state => < div > < h1 > { state } < /h1> < button onclick = {()=> app . run ( '-1' )} >- 1 < /button> < button onclick = {()=> app . run ( '+1' )} >+ 1 < /button> < /div>; const update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; app . start ( document . body , state , view , update );","title":"Architecture Overview"},{"location":"architecture/#state","text":"The state can be any data structure, a number, an array, or an object that reflects the state of the application. In the _ Counter_ example, it is a number. const state = 0 ; Note You define the initial state. AppRun manages the state. Therefore the initial state is an immutable constant.","title":"State"},{"location":"architecture/#view","text":"The view generates Virtual DOM based on the state. Finally, AppRun calculates the differences against the web page element and renders the changes. const view = state => < div > < h1 > $ { state } < /h1> < button $onclick = \"-1\" >- 1 < /button> < button $onclick = \"+1\" >+ 1 < /button> < /div>; Note AppRun allows you to choose your favorite virtual DOM technology in the view function. The example above uses JSX. You can also use lit-html, uhtml, and etc.","title":"View"},{"location":"architecture/#update","text":"The update is a collection of named event handlers or a dictionary of event handlers. Each event handler creates a new state from the current state. const update = { '+1' : state => state + 1 , '-1' : state => state - 1 } Note There are a few other ways to define event handlers. When the three parts, the state , view , and update are provided to AppRun to start an application, AppRun registers the event handlers defined in the update and waits for AppRun events. app . start ( document . body , state , view , update ); Next, let's review some of the benefits of AppRun Architecture.","title":"Update"},{"location":"architecture/#avoid-spaghetti-code","text":"AppRun solves two challenging problems commonly found in application development: Let's make the Counter a bitter complicated to show how many times each button clicked. // initial state object const state = { count : 0 , count_plus : 0 , count_minus : 0 } // one view function to render the state, its' a pure function const view = ({ count , count_plus , count_minus }) => html ` <h1> ${ count } </h1> <button onclick=\"app.run('minus')\">- ( ${ count_minus } )</button> <button onclick=\"app.run('plus')\">+ ( ${ count_plus } )</button> ` // collection of state updates, state is immutable const minus = ( state ) => ({ ... state , count : state . count - 1 , count_minus : state . count_minus + 1 }); const plus = ( state ) => ({ ... state , count : state . count + 1 , count_plus : state . count_plus + 1 }); app . start ( document . body , state , view , { plus , minus }); The code below uses jQuery. jQuery is a library that provides the convenience to access and manipulate the DOM. It does not give any architectural guidance. jQuery code is similar to the vanilla JavaScript code that can go wild. A jQuery Example $ ( function () { // global state let count = 0 let count_plus = 0 let count_minus = 0 function plus () { // state update count ++ count_plus ++ // rendering $ ( '#total' ). html ( count ) $ ( '#plus' ). html ( `+ ( ${ count_plus } )` ) } function minus () { // state update count -- count_minus ++ // rendering $ ( '#total' ). html ( count ) $ ( '#minus' ). html ( `- ( ${ count_minus } )` ) } $ ( '#plus' ). on ( 'click' , plus ) $ ( '#minus' ). on ( 'click' , minus ) }) You can see from the above code that The state is shared globally. The two event handlers plus and minus both update the state directly. The two event handlers also render the DOM in different pieces. Therefore, the jQuery code has two problems: Direct State Update Rendering Fragments In much more complicated real applications, the logic could be long and tangled even more. How can we solve the problems using AppRun?","title":"Avoid Spaghetti Code"},{"location":"architecture/#apprun-code","text":"AppRun includes state management, an event system, and Virtual-DOM rendering. Following the Hollywood Principle (Don't call us. We call you), we provide code pieces to AppRun and wait for AppRun to call them. During an AppRun event lifecycle: AppRun let you update the state when needed AppRun let you create a virtual DOM out of the state when needed AppRun renders the virtual DOM when needed. When using AppRun to update the state , AppRun gives the current state . Then, we create a new state based on the current state . const minus = ( state ) => ({ ... state , count : state . count - 1 , count_minus : state . count_minus + 1 }); const plus = ( state ) => ({ ... state , count : state . count + 1 , count_plus : state . count_plus + 1 }); Because there is no reference to a shared global object, it is very easy to unit-test the logic. Also, we can focus on the parts of the state that are needed to update and ignore the rest of the state using the spread operator. We only write a view function that creates a virtual DOM. AppRun renders the DOM using the diffing algorithm. It only updates the DOM that is needed to change. Therefore, although we have only one view function for all events, AppRun takes care of the differential rendering accordingly. const view = ({ count , count_plus , count_minus }) => html ` <h1> ${ count } </h1> <button onclick=\"app.run('minus')\">- ( ${ count_minus } )</button> <button onclick=\"app.run('plus')\">+ ( ${ count_plus } )</button>` The view function always returns the same result as long as the state is the same. It also does not change the state or anything outside the function, which means it has no side effects. Therefore, the view function is a pure function . There are many benefits of using the pure__ function , including but not limited to unit testing. Finally, We have a _ counter _ application shown below by putting the state, _view , and update together. // initial state object const state = { count : 0 , count_plus : 0 , count_minus : 0 } // one view function to render the state, its' a pure function const view = ({ count , count_plus , count_minus }) => html ` <h1> ${ count } </h1> <button onclick=\"app.run('minus')\">- ( ${ count_minus } )</button> <button onclick=\"app.run('plus')\">+ ( ${ count_plus } )</button> ` // collection of state updates, state is immutable const minus = ( state ) => ({ ... state , count : state . count - 1 , count_minus : state . count_minus + 1 }); const plus = ( state ) => ({ ... state , count : state . count + 1 , count_plus : state . count_plus + 1 }); app . start ( document . body , state , view , { plus , minus }); You can see that with the help of AppRun state management and DOM differential rendering, we no longer have the Direct State Update with Rendering Fragments problems.","title":"AppRun Code"},{"location":"architecture/#apprun-benefits","text":"No matter how complex the application is, we will always have three parts, the state , view , and update . We don't mix the state update with DOM rendering. Because the three parts are decoupled, our codebase is so much easier to understand, test, and maintain.","title":"AppRun Benefits"},{"location":"architecture/#ceremony-vs-essence","text":"There was the 'Ceremony vs. Essence' discussion that happened about ten years ago. At that time, Ruby was on the rise. So people compared Ruby with C# . The fundamental idea of the Ceremony vs. Essence idea appears to be that, all other things being equal, programming languages should attempt to allow programmers to clearly express the essence of their programs without being caught up in excessive ceremony provided by the programming language. -- From this post . Let's take a look at some of today's frontend technologies from the Ceremony vs. Essence point of view. We will use a simple button-click counting application as an example. const add = count => count + 1 ; const view = count => < button $onclick = { add } > Clicks : { count } < /button>; const rendered = count => console . log ( count ); app . start ( document . body , 0 , view , null , { rendered }); console . log ( 'mounted!' );","title":"Ceremony vs. Essence"},{"location":"architecture/#the-essence","text":"The essence of the application is to display a button that adds the count by one and shows the count. Also, it will log some messages in the console to mimic effects after the rendering cycle. The concept is as simple as below. < button onclick = \"count+1\" > Clicks : { count } < /button> console . log ( count ); // upon very click console . log ( 'mounted!' ); // upon mounted We will compare the 95-character essence code above with a few front-end frameworks, such as AppRun, Svelte, React Hooks, and the Vue Composition API. A framework defines a skeleton where the application defines its features to fill out the skeleton. -- you can find this quote from googling. We need to write code to plugin the essence code into the frontend frameworks, which is the ceremony. We don't want them. Less of them is better.","title":"The Essence"},{"location":"architecture/#the-ceremony","text":"","title":"The Ceremony"},{"location":"architecture/#apprun","text":"Application logic is broken down into three separate parts in the AppRun architecture. const add = count => count + 1 ; const view = count => < button $onclick = { add } > Clicks : { count } < /button>; const rendered = count => console . log ( count ); app . start ( document . body , 0 , view , null , { rendered }); console . log ( 'mounted!' ); In the example above, The application's state is a number that has a default value of 0. The add function is the event handler to update the state. The view function displays the state. The rendered function runs after the DOM is rendered. The app.start function ties them all together to the document.body element. Now, we identify and cross out the ceremonies. With AppRun, the ceremony is mainly required by the JavaScript syntax, like the module import and the arrow functions. Overall, it has 226 characters, which means 58% of the code are ceremonies.","title":"AppRun"},{"location":"architecture/#svelte","text":"Svelte uses a single file for a component. The file consists of a script section for the code and the UI template. It requires a compiler to turn it into runnable JavaScript code. < script > import { onMount } from 'svelte' let count = 0 ; const add = () => count + 1 ; $ : console . log ( count ) onMount (() => console . log ( 'mounted!' ) < /script> < button on : click = { add } > Clicks : { count } < /button> Behind the scene, the svelte compiler creates the component class boilerplate. Then, the compiler extracts the script block, wires up the reactivity ($:), and adds the rendering template into the boilerplate. The boilerplate does not exist in our codebase. Therefore, the svelte application has very few ceremonies. Svelte code ceremony is also mainly the JavaScript syntax requirements. Only the script tags are required by the Svelte compiler, which is worth trading with what the compiler saves. It has 217 characters, which means 56% of the code is ceremony.","title":"Svelte"},{"location":"architecture/#react-hooks","text":"The React code is a slightly modified version of the React Hooks Docs]( https://reactjs.org/docs/hooks-overview.html ). import React , { useState , useEffect } from 'react' ; function Example () { const [ count , setCount ] = useState ( 0 ); const add = () => setCount ( count + 1 ) useEffect (() => { console . log ( count ); }); return ( < button onClick = { add } > Clicks : { count } < /button> ); } The React code has more ceremonies than the AppRun code and Svelte code above. It has 272 characters and a 65% ceremony. The setCount, _useState , and useEffect functions are the code that deals with the React framework itself. They don't help us to express the essence of the application. They are framework ceremonies.","title":"React Hooks"},{"location":"architecture/#vue-composition-api","text":"The Vue code is a slightly modified version of the Vue Composition API Docs . < template > < button @ click = \"add\" > Clicks : {{ count }} < /button> < /template> import { ref , watchEffect , onMounted } from 'vue' export default { setup () { const count = ref ( 0 ) function add () { count . value ++ } watchEffect (() => console . log ( count . value )) onMounted (() => console . log ( 'mounted!' )) return { count , add } } } The Vue code has 355 characters and a 73% ceremony. The ref , watchEffect , onMounted , setup, _count.value , and returning an object of count , and add are all required by the Vue framework. Sometimes, they may make writing code more difficult.","title":"Vue Composition API"},{"location":"architecture/#expression-comparison","text":"We are not stopping at only comparing the character counts or how many extra boilerplates are forced on you by the frameworks. We also compare how you express the business logic. For example, let's see how we express Increase the Counter as an example again. // AppRun const add = counter => counter + 1 ; //Svelte let count = 0 ; const add = () => counter + 1 ; // React const [ count , setCount ] = useState ( 0 ); const add = () => setCount ( count + 1 ); // Vue const count = ref ( 0 ); const add = () => count . value ++ ; Both the AppRun code and the Svelte code express the essence well and have less ceremony. So AppRun and Svelte are easy to understand. React Hooks and Vue Composition API are cool. However, they both add a lot more ceremonies to our codebase. Remember, the ceremony has no business values but just challenges to understand and maintain. In addition, AppRun has a few other benefits AppRun is lightweight that can run in browsers directly without a compiler. AppRun uses pure functions when it is possible. AppRun app codebase can easily be strongly typed if you wish. I hope you enjoy it. If you haven't clicked the 'Try the Code' buttons to run the AppRun code above, please give it a try.","title":"Expression Comparison"},{"location":"cli-in-console/","text":"AppRun Dev Tools \u00b6 We have been using the command-line interface (CLI) in the terminal window and the command prompt. Have you thought of a CLI in the console of the browser's developer tool? How does it work? \u00b6 In the console of the browser's developer tool (F12), you can type the command. _apprun `<command> [options]` Just like many other CLI, the help command lists all available commands. For example, you can see three commands in the screenshot components , events , and log . Why do we need a CLI in the console? \u00b6 CLI in the console is convenient for watching runtime data. For example, during application development, we often need to debug and check the application's internal data. Using the console.log function is the easiest yet most compelling way to display the data because the console lets us drill down into the nested array and object structure. With a CLI in the console, The app codebase stays clear of console.log . The CLI provides a non-destructive way of watching the runtime data. We can include the CLI script in the development environment and remove it from the production environment. How is it made? \u00b6 The CLI uses JavaScript tagged templates . We create the _apprun function in the window object. window [ '_apprun' ] = ( strings ) => { } The _apprun function is called when we type the AppRun commands in the console. The command and the command parameters are passed into the _apprun function as the function parameter strings , which we can parse and then invoke the command functions. window [ '_apprun' ] = ( strings ) => { const [ cmd , ... p ] = strings [ 0 ]. split ( ' ' ). filter ( c => !! c ); const command = window [ `_apprun- ${ cmd } ` ]; if ( command ) command [ 1 ](... p ); else window [ '_apprun-help' ][ 1 ](); } It has extensive architecture. We create the AppRun commands in the window object. The AppRun command is a tuple that includes the description of the command and the implementation function of the command. E.g., the help command looks like this: window [ '_apprun-help' ] = [ '' , () => { Object . keys ( window ). forEach ( cmd => { if ( cmd . startsWith ( '_apprun-' )) { cmd === '_apprun-help' ? console . log ( 'AppRun Commands:' ) : console . log ( `* ${ cmd . substring ( 8 ) } : ${ window [ cmd ][ 0 ] } ` ); } }); }]; The help command searches for the tuples stored in the window object and prints the description of other AppRun commands. That's all the infrastructure code we need to create CLI commands in the console. Let's see an example. Live Demo \u00b6 The AppRun Dev Tools is one of the developer tools included in the AppRun library. You can visit the AppRun RealWorld Example App https://gothinkster.github.io/apprun-realworld-example-app to see the CLI in action. The components command logs the DOM elements that have AppRun components The events command logs the event subscription of the app The log command logs the runtime events publication of the app The create-event-tests command creates unit tests for the app The create-state-tests command creates Jest snapshot tests for the app Conclusion \u00b6 Developers like CLI. Dev Tools helps get runtime events and messages hard for the traditional CLI in the terminal. The AppRun Dev Tools can watch the components and events, and can generate tests. Thus, it increases the development productivity for debugging and testing.","title":"Dev Tools"},{"location":"cli-in-console/#apprun-dev-tools","text":"We have been using the command-line interface (CLI) in the terminal window and the command prompt. Have you thought of a CLI in the console of the browser's developer tool?","title":"AppRun Dev Tools"},{"location":"cli-in-console/#how-does-it-work","text":"In the console of the browser's developer tool (F12), you can type the command. _apprun `<command> [options]` Just like many other CLI, the help command lists all available commands. For example, you can see three commands in the screenshot components , events , and log .","title":"How does it work?"},{"location":"cli-in-console/#why-do-we-need-a-cli-in-the-console","text":"CLI in the console is convenient for watching runtime data. For example, during application development, we often need to debug and check the application's internal data. Using the console.log function is the easiest yet most compelling way to display the data because the console lets us drill down into the nested array and object structure. With a CLI in the console, The app codebase stays clear of console.log . The CLI provides a non-destructive way of watching the runtime data. We can include the CLI script in the development environment and remove it from the production environment.","title":"Why do we need a CLI in the console?"},{"location":"cli-in-console/#how-is-it-made","text":"The CLI uses JavaScript tagged templates . We create the _apprun function in the window object. window [ '_apprun' ] = ( strings ) => { } The _apprun function is called when we type the AppRun commands in the console. The command and the command parameters are passed into the _apprun function as the function parameter strings , which we can parse and then invoke the command functions. window [ '_apprun' ] = ( strings ) => { const [ cmd , ... p ] = strings [ 0 ]. split ( ' ' ). filter ( c => !! c ); const command = window [ `_apprun- ${ cmd } ` ]; if ( command ) command [ 1 ](... p ); else window [ '_apprun-help' ][ 1 ](); } It has extensive architecture. We create the AppRun commands in the window object. The AppRun command is a tuple that includes the description of the command and the implementation function of the command. E.g., the help command looks like this: window [ '_apprun-help' ] = [ '' , () => { Object . keys ( window ). forEach ( cmd => { if ( cmd . startsWith ( '_apprun-' )) { cmd === '_apprun-help' ? console . log ( 'AppRun Commands:' ) : console . log ( `* ${ cmd . substring ( 8 ) } : ${ window [ cmd ][ 0 ] } ` ); } }); }]; The help command searches for the tuples stored in the window object and prints the description of other AppRun commands. That's all the infrastructure code we need to create CLI commands in the console. Let's see an example.","title":"How is it made?"},{"location":"cli-in-console/#live-demo","text":"The AppRun Dev Tools is one of the developer tools included in the AppRun library. You can visit the AppRun RealWorld Example App https://gothinkster.github.io/apprun-realworld-example-app to see the CLI in action. The components command logs the DOM elements that have AppRun components The events command logs the event subscription of the app The log command logs the runtime events publication of the app The create-event-tests command creates unit tests for the app The create-state-tests command creates Jest snapshot tests for the app","title":"Live Demo"},{"location":"cli-in-console/#conclusion","text":"Developers like CLI. Dev Tools helps get runtime events and messages hard for the traditional CLI in the terminal. The AppRun Dev Tools can watch the components and events, and can generate tests. Thus, it increases the development productivity for debugging and testing.","title":"Conclusion"},{"location":"component/","text":"Component \u00b6 The component is a technique to decompose the large system into smaller, manageable, and reusable pieces. The component is the basic building block. Usually, a component is an autonomous and reusable module that encapsulates a set of data and functions. An AppRun component is a mini-application with elm architecture, which means inside a component, there are state , view , and update . In addition, components provide a local scope. Render the Component \u00b6 To use the components, you can render them into an element. const element = document . getElementById ( 'my-app' ); app . render ( element , < Counter /> ); When rendering the component, AppRun creates a component instance and renders it to the element. Mount and Start \u00b6 Or you can create the component using the constructor and mount the component instance to an element or to an element ID . When the component is mounted to an element ID , It will render the element only when it exists. const element = document . getElementById ( 'my-app' ); new Counter (). mount ( element ); You can also pass the initial state into the component's constructor directly: new Counter ( 100 ). mount ( element ); When the component is mounted, by default, it won't display until the events come. It is useful in the single-page application (SPA) scenario where you can mount all components at once. Each component is activated by the routing events. If you need the component to display the initial state, you can use the start function. new Counter (). start ( document . body ); // mount and display You can render, mount, or start the component to document.body . // app . render ( document . body , < Counter /> ); // new Counter (). mount ( document . body ); // new Counter (). start ( document . body ); Child Component \u00b6 Components can have child components. class Child extends Component { state = {} view = state => < div >< /div> update = {} } class Parent extends Component { state = {} view = state => < div > < Child /> < /div> update = {} } You are not forced into the nested component structure. Sometimes, mounting components are more flexible. Please read this post, Redux vs. The React Context API vs. AppRun . Component Events \u00b6 A Component provides a local scope for events. The update registers the local events in the component. The this.run function fires local events that can only be picked up inside the component. You can prefix the event name with #, / or @ to make it global. class Counter extends Component { update = { '+1' : state => state + 1 , // local event '#+1' : state => state + 1 , // global event } } The app.run fires the global events that can be picked up by all components. In addition, to use the update for defining event handlers, you can also use the @on decorator or the $on directive. Event Handler Decorator \u00b6 In the component class, we can use TypeScript to compile the @on decorators to create the event handlers without using the update object. import app , { Component , on } from 'apprun' ; class Counter extends Component { state = 0 ; view = state => <> < h1 > { state } < /h1> < button onclick = {()=> this . run ( '-1' )} >- 1 < /button> < button onclick = {()=> this . run ( '+1' )} >+ 1 < /button> < />; @ on ( '-1' ) decrease = state => state - 1 ; @ on ( '+1' ) increase = state => state + 1 ; } Event Directive \u00b6 We can also use the directive to simplify event handling. import { app , Component } from 'apprun' ; class Counter extends Component { state = 0 ; view = state => < div > < h1 > { state } < /h1> < button $onclick = { state => state - 1 } >- 1 < /button> < button $onclick = { state => state + 1 } >+ 1 < /button> < /div>; } Life Cycle Functions \u00b6 Life Cycle Functions are callback functions that AppRun calls during the component life cycle. They are mounted , rendered , and unload . import { app , Component } from 'apprun' ; class MyApp extends Component { state = {}; view = state => < div >< /div>; update = {}; //life cycle functions mounted = ( props , children , state ) => state ; rendered = state => {}; unload = state => {}; } app . render ( document . body , < MyApp /> ); mounted \u00b6 The mounted function is called after the component instance is mounted to a DOM element. The mounted function can be used to set the initialize state . mounted : ( props : any , children : any [], state : T ) => T | void ; Note: the mounted function is only called in the child component. class Child extends Component { state = {} // you can define the initial state view = state => < div >< /div> update = {} mounted = ( props , children ) => { ... state , ... props } // this will be called, you can merge props into the state } class Parent extends Component { state = {} // you can define the initial state view = state => < div > < Child /> < /div> update = {} mounted = () => { } // this will NOT be called when component is created using the constructor } new Parent (). start ( document . body ); rendered \u00b6 The rendered function is called after AppRun renders the result of the view function. The rendered function can be used to modify the DOM element using 3rd party libraries. rendered : ( state : T , props ?: any []) => void ; unload \u00b6 The _unload function is called when the DOM element that the component is mounted to is removed or reused by other components. For example, the _unload function can be used to clean the resources created by the 3rd party libraries. unload : ( state : T ) => void ; You can see, the component life cycle functions are useful for integrating 3rd party libraries . Web Components \u00b6 You can convert AppRun components into web components/custom elements . AppRun components become the custom elements that also can handle AppRun events. < html > < head > < meta charset = \"utf-8\" > < title > Counter as web component </ title > </ head > < body > < my-app id = 'counter' ></ my-app > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/custom-elements/1.1.2/custom-elements.min.js\" ></ script > < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" ></ script > < script > class Counter extends Component { constructor () { super (); this . state = 0 ; this . view = state => `<div> <h1> ${ state } </h1> <button onclick='counter.run(\"-1\")'>-1</button> <button onclick='counter.run(\"+1\")'>+1</button> </div>` ; this . update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; } } app . webComponent ( 'my-app' , Counter ); </ script > </ body > </ html > HTML Child Components \u00b6 Unlike JSX, you can embed component classes into JSX; when using HTML string components, you will need to make a web component/custom element. Then you can embed the components. import app from 'apprun' ; import MyComponent from './MyComponent' ; app . webComponent ( 'my-component' , MyComponent ); const view = state => { return `<div> <my-component /> </div>` ; }; app . start ( 'my-app' , state , view );","title":"Component"},{"location":"component/#component","text":"The component is a technique to decompose the large system into smaller, manageable, and reusable pieces. The component is the basic building block. Usually, a component is an autonomous and reusable module that encapsulates a set of data and functions. An AppRun component is a mini-application with elm architecture, which means inside a component, there are state , view , and update . In addition, components provide a local scope.","title":"Component"},{"location":"component/#render-the-component","text":"To use the components, you can render them into an element. const element = document . getElementById ( 'my-app' ); app . render ( element , < Counter /> ); When rendering the component, AppRun creates a component instance and renders it to the element.","title":"Render the Component"},{"location":"component/#mount-and-start","text":"Or you can create the component using the constructor and mount the component instance to an element or to an element ID . When the component is mounted to an element ID , It will render the element only when it exists. const element = document . getElementById ( 'my-app' ); new Counter (). mount ( element ); You can also pass the initial state into the component's constructor directly: new Counter ( 100 ). mount ( element ); When the component is mounted, by default, it won't display until the events come. It is useful in the single-page application (SPA) scenario where you can mount all components at once. Each component is activated by the routing events. If you need the component to display the initial state, you can use the start function. new Counter (). start ( document . body ); // mount and display You can render, mount, or start the component to document.body . // app . render ( document . body , < Counter /> ); // new Counter (). mount ( document . body ); // new Counter (). start ( document . body );","title":"Mount and Start"},{"location":"component/#child-component","text":"Components can have child components. class Child extends Component { state = {} view = state => < div >< /div> update = {} } class Parent extends Component { state = {} view = state => < div > < Child /> < /div> update = {} } You are not forced into the nested component structure. Sometimes, mounting components are more flexible. Please read this post, Redux vs. The React Context API vs. AppRun .","title":"Child Component"},{"location":"component/#component-events","text":"A Component provides a local scope for events. The update registers the local events in the component. The this.run function fires local events that can only be picked up inside the component. You can prefix the event name with #, / or @ to make it global. class Counter extends Component { update = { '+1' : state => state + 1 , // local event '#+1' : state => state + 1 , // global event } } The app.run fires the global events that can be picked up by all components. In addition, to use the update for defining event handlers, you can also use the @on decorator or the $on directive.","title":"Component Events"},{"location":"component/#event-handler-decorator","text":"In the component class, we can use TypeScript to compile the @on decorators to create the event handlers without using the update object. import app , { Component , on } from 'apprun' ; class Counter extends Component { state = 0 ; view = state => <> < h1 > { state } < /h1> < button onclick = {()=> this . run ( '-1' )} >- 1 < /button> < button onclick = {()=> this . run ( '+1' )} >+ 1 < /button> < />; @ on ( '-1' ) decrease = state => state - 1 ; @ on ( '+1' ) increase = state => state + 1 ; }","title":"Event Handler Decorator"},{"location":"component/#event-directive","text":"We can also use the directive to simplify event handling. import { app , Component } from 'apprun' ; class Counter extends Component { state = 0 ; view = state => < div > < h1 > { state } < /h1> < button $onclick = { state => state - 1 } >- 1 < /button> < button $onclick = { state => state + 1 } >+ 1 < /button> < /div>; }","title":"Event Directive"},{"location":"component/#life-cycle-functions","text":"Life Cycle Functions are callback functions that AppRun calls during the component life cycle. They are mounted , rendered , and unload . import { app , Component } from 'apprun' ; class MyApp extends Component { state = {}; view = state => < div >< /div>; update = {}; //life cycle functions mounted = ( props , children , state ) => state ; rendered = state => {}; unload = state => {}; } app . render ( document . body , < MyApp /> );","title":"Life Cycle Functions"},{"location":"component/#mounted","text":"The mounted function is called after the component instance is mounted to a DOM element. The mounted function can be used to set the initialize state . mounted : ( props : any , children : any [], state : T ) => T | void ; Note: the mounted function is only called in the child component. class Child extends Component { state = {} // you can define the initial state view = state => < div >< /div> update = {} mounted = ( props , children ) => { ... state , ... props } // this will be called, you can merge props into the state } class Parent extends Component { state = {} // you can define the initial state view = state => < div > < Child /> < /div> update = {} mounted = () => { } // this will NOT be called when component is created using the constructor } new Parent (). start ( document . body );","title":"mounted"},{"location":"component/#rendered","text":"The rendered function is called after AppRun renders the result of the view function. The rendered function can be used to modify the DOM element using 3rd party libraries. rendered : ( state : T , props ?: any []) => void ;","title":"rendered"},{"location":"component/#unload","text":"The _unload function is called when the DOM element that the component is mounted to is removed or reused by other components. For example, the _unload function can be used to clean the resources created by the 3rd party libraries. unload : ( state : T ) => void ; You can see, the component life cycle functions are useful for integrating 3rd party libraries .","title":"unload"},{"location":"component/#web-components","text":"You can convert AppRun components into web components/custom elements . AppRun components become the custom elements that also can handle AppRun events. < html > < head > < meta charset = \"utf-8\" > < title > Counter as web component </ title > </ head > < body > < my-app id = 'counter' ></ my-app > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/custom-elements/1.1.2/custom-elements.min.js\" ></ script > < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" ></ script > < script > class Counter extends Component { constructor () { super (); this . state = 0 ; this . view = state => `<div> <h1> ${ state } </h1> <button onclick='counter.run(\"-1\")'>-1</button> <button onclick='counter.run(\"+1\")'>+1</button> </div>` ; this . update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; } } app . webComponent ( 'my-app' , Counter ); </ script > </ body > </ html >","title":"Web Components"},{"location":"component/#html-child-components","text":"Unlike JSX, you can embed component classes into JSX; when using HTML string components, you will need to make a web component/custom element. Then you can embed the components. import app from 'apprun' ; import MyComponent from './MyComponent' ; app . webComponent ( 'my-component' , MyComponent ); const view = state => { return `<div> <my-component /> </div>` ; }; app . start ( 'my-app' , state , view );","title":"HTML Child Components"},{"location":"create-apprun-app/","text":"Create AppRun App \u00b6 The npm create apprun-app command line tool creates a new AppRun project. It can scaffold a new project with build tools and a development server. To create a project, run: npx create-apprun-app my-app cd my-app npm start You can select one of the following project templates: ? Select a template \u203a - Use arrow-keys. Return to submit. HTML/JS HTML/JS - Web Component Blank App Signle Page App \u276f AppRun Site (default) You can also select a build tool: ? Select a compiler \u203a - Use arrow-keys. Return to submit. esbuild webpack \u276f vite Then, you can choose to add Jest and git repo: ? Add Jest? \u2026 No / Yes ? Add git repo? \u203a No / Yes Finally, it creates a new project for you: Project created in: ....../my-app Please go to the project directory and run: npm start And then, you can visit the project at: http://localhost:8080 You can read more about the project templates in the following sections. Single Page App AppRun Site","title":"Create AppRun App"},{"location":"create-apprun-app/#create-apprun-app","text":"The npm create apprun-app command line tool creates a new AppRun project. It can scaffold a new project with build tools and a development server. To create a project, run: npx create-apprun-app my-app cd my-app npm start You can select one of the following project templates: ? Select a template \u203a - Use arrow-keys. Return to submit. HTML/JS HTML/JS - Web Component Blank App Signle Page App \u276f AppRun Site (default) You can also select a build tool: ? Select a compiler \u203a - Use arrow-keys. Return to submit. esbuild webpack \u276f vite Then, you can choose to add Jest and git repo: ? Add Jest? \u2026 No / Yes ? Add git repo? \u203a No / Yes Finally, it creates a new project for you: Project created in: ....../my-app Please go to the project directory and run: npm start And then, you can visit the project at: http://localhost:8080 You can read more about the project templates in the following sections. Single Page App AppRun Site","title":"Create AppRun App"},{"location":"dev-server/","text":"Introduction \u00b6 We use JavaScript modules (ESM) extensively while coding nowadays. But we still cannot deploy the module-based code yet. It is because the browsers don't know how to handle global modules. E.g., When developing applications using AppRun , we need a globe module of apprun . import app from 'apprun' The browsers don't know how to import apprun . Therefore, We still need to use JavaScript bundlers such as webpack, rollup, or parcel to bundle the modules. But at least now, we can use the modules to speed up the development process. Recently, the Snowpack team introduced the concept of Unbundled Development , which is to leverage modules for speeding up the development process. In the past, I was thinking of building a tool to convert the global modules to the modules links on unpkg after compilation. The npm package CDN , unpkg.com supports delivering modules for along time. We can load apprun as a module from unpkg . import app from 'https://unpkg.com/apprun?module' Now, it seems that a development server is a different and better idea. So, I forked the live-server and made a development server for AppRun. This post is to introduce the AppRun development server, called apprun-dev-server . apprun-dev-server \u00b6 This is a static web server for developing JavaScript/TypeScript using ES modules following the concept of Unbundled Development . It serves the ES Modules from unpkg.com. Based on live-server , so it reloads the page automatically Also, it detects AppRun and can replace the module/Component while keeping the application state . The best part of the apprun-dev-server is that it does NOT require any code in our components to handle the hot module replacement. Instead, it retains the component state; replaces the module; and then puts the state back. All done automatically. If you want to refresh the state, you can reload the page in the browser by pressing F5 (on Windows) or Command+R (on Mac). How to Use \u00b6 You export Component as the default module export. import { app , Component } from 'apprun' ; export default class AboutComponent extends Component { state = 'About' ; view = state => < div > < h1 > { state } < /h1> < /div>; update = { '#About' : state => state , }; } Then, you use the Component in the main file. import About from './About' ; new About (). start ( 'my-app' ); Then, you use a module-type script tag in HTML. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > AppRun SPA </ title > </ head > < body > < script type = \"module\" src = \"/dist/main.js\" ></ script > </ body > </ html > Turn on the compiler, TypeScript, or Babel in watch mode. And then, start the apprun-dev-server using npx. npx apprun-dev-server Apprun-dev-server monitors the file changes. If the changed JavaScript files (*.js) file have global modules. Apprun-dev-server replaces the global module's references to unpkg . In the server console, if you see the file names that have some dots '......' in front, they are the files modified. Apprun-dev-server injects JavaScript code snippets in the index.html just like live-server. Also, Apprun-dev-server adds logic to detect AppRun and replace AppRun components. You can download an example app to give it a try. npx degit yysun/apprun-esm-server my-app Configuration \u00b6 Create a apprun-dev-server.config.js in your project: module . exports = { port : 8181 , // Set the server port. Defaults to 8080. host : \"0.0.0.0\" , // Set the address to bind to. Defaults to 0.0.0.0 or process.env.IP. root : \"public\" , // Set root directory that's being served. Defaults to cwd. open : false , // When false, it won't load your browser by default. ignore : '' , // comma-separated string for paths to ignore file : \"index.html\" , // When set, serve this file (server root relative) for every 404 (useful for single-page applications) wait : 1000 , // Waits for all changes, before reloading. Defaults to 0 sec. mount : [], // Mount a directory to a route. logLevel : 2 , // } Use with esbuild \u00b6 The apprun-dev-server is installed when creating a project by using the npm init apprun-app command and selecting the `esbuild`` option. npm init apprun-app [ my-app ] Give it a try and send pull requests. https://github.com/yysun/apprun-dev-server","title":"AppRun Dev Server Supports ESM"},{"location":"dev-server/#introduction","text":"We use JavaScript modules (ESM) extensively while coding nowadays. But we still cannot deploy the module-based code yet. It is because the browsers don't know how to handle global modules. E.g., When developing applications using AppRun , we need a globe module of apprun . import app from 'apprun' The browsers don't know how to import apprun . Therefore, We still need to use JavaScript bundlers such as webpack, rollup, or parcel to bundle the modules. But at least now, we can use the modules to speed up the development process. Recently, the Snowpack team introduced the concept of Unbundled Development , which is to leverage modules for speeding up the development process. In the past, I was thinking of building a tool to convert the global modules to the modules links on unpkg after compilation. The npm package CDN , unpkg.com supports delivering modules for along time. We can load apprun as a module from unpkg . import app from 'https://unpkg.com/apprun?module' Now, it seems that a development server is a different and better idea. So, I forked the live-server and made a development server for AppRun. This post is to introduce the AppRun development server, called apprun-dev-server .","title":"Introduction"},{"location":"dev-server/#apprun-dev-server","text":"This is a static web server for developing JavaScript/TypeScript using ES modules following the concept of Unbundled Development . It serves the ES Modules from unpkg.com. Based on live-server , so it reloads the page automatically Also, it detects AppRun and can replace the module/Component while keeping the application state . The best part of the apprun-dev-server is that it does NOT require any code in our components to handle the hot module replacement. Instead, it retains the component state; replaces the module; and then puts the state back. All done automatically. If you want to refresh the state, you can reload the page in the browser by pressing F5 (on Windows) or Command+R (on Mac).","title":"apprun-dev-server"},{"location":"dev-server/#how-to-use","text":"You export Component as the default module export. import { app , Component } from 'apprun' ; export default class AboutComponent extends Component { state = 'About' ; view = state => < div > < h1 > { state } < /h1> < /div>; update = { '#About' : state => state , }; } Then, you use the Component in the main file. import About from './About' ; new About (). start ( 'my-app' ); Then, you use a module-type script tag in HTML. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > AppRun SPA </ title > </ head > < body > < script type = \"module\" src = \"/dist/main.js\" ></ script > </ body > </ html > Turn on the compiler, TypeScript, or Babel in watch mode. And then, start the apprun-dev-server using npx. npx apprun-dev-server Apprun-dev-server monitors the file changes. If the changed JavaScript files (*.js) file have global modules. Apprun-dev-server replaces the global module's references to unpkg . In the server console, if you see the file names that have some dots '......' in front, they are the files modified. Apprun-dev-server injects JavaScript code snippets in the index.html just like live-server. Also, Apprun-dev-server adds logic to detect AppRun and replace AppRun components. You can download an example app to give it a try. npx degit yysun/apprun-esm-server my-app","title":"How to Use"},{"location":"dev-server/#configuration","text":"Create a apprun-dev-server.config.js in your project: module . exports = { port : 8181 , // Set the server port. Defaults to 8080. host : \"0.0.0.0\" , // Set the address to bind to. Defaults to 0.0.0.0 or process.env.IP. root : \"public\" , // Set root directory that's being served. Defaults to cwd. open : false , // When false, it won't load your browser by default. ignore : '' , // comma-separated string for paths to ignore file : \"index.html\" , // When set, serve this file (server root relative) for every 404 (useful for single-page applications) wait : 1000 , // Waits for all changes, before reloading. Defaults to 0 sec. mount : [], // Mount a directory to a route. logLevel : 2 , // }","title":"Configuration"},{"location":"dev-server/#use-with-esbuild","text":"The apprun-dev-server is installed when creating a project by using the npm init apprun-app command and selecting the `esbuild`` option. npm init apprun-app [ my-app ] Give it a try and send pull requests. https://github.com/yysun/apprun-dev-server","title":"Use with esbuild"},{"location":"directive/","text":"Directives \u00b6 AppRun directives are syntax sugars that help simplify the code. They are custom attributes in JSX that have names starting with $. AppRun two out-of-the-box directives: $on and $bind. $on... \u00b6 The $on directive simplifies the code to convert the DOM events to AppRun events. Publish Events \u00b6 class Counter extends Component { state = 0 ; view = state => <> < h1 > { state } < /h1> < button $onclick = '-1' >- 1 < /button> < button $onclick = '+1' >+ 1 < /button> < />; update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; } new Counter (). start ( document . body ); Invoke Functions \u00b6 The $on directive can also invoke functions. class Counter extends Component { state = 0 ; view = state => < div > < h1 > { state } < /h1> < button $onclick = { state => state - 1 } >- 1 < /button> < button $onclick = { state => state + 1 } >+ 1 < /button> < /div>; } new Counter (). start ( document . body ); $bind \u00b6 The $bind directive synchronizes the HTML input value to the state . See the $bind example below. const state = '' ; const view = state => < div > < h1 > Hello { state } < /h1> < input autofocus $bind /> < /div>; app . start ( document . body , state , view ); Or, you can bind to the properties of the state . const state = { a : 1 , b : 2 , get c () { return this . a + this . b ; } }; const view = ({ a , b , c }) => <> < input type = \"number\" $bind = \"a\" /> < input type = \"number\" $bind = \"b\" /> < p > { a } + { b } = { c } < /p> < />; app . start ( document . body , state , view ); Custom directive \u00b6 When AppRun is processing the JSX code, it publishes the $ event when it finds the custom attributes like $X. Thus, you can subscribe to the $ event to provide your directives. app . on ( '$' , ({ key , props }) => { if ( key === '$animation' ) { const value = props [ key ]; if ( typeof value === 'string' ) { props . class = \\ `animated \\${value}\\`; } } }); Animation directive \u00b6 We can create the $animation directive to attach the animation classes from the animation library, animation.css . See the $animation example below. // Animation Directive Using animate.css app . on ( '$' , ({ key , props }) => { if ( key === '$animation' ) { const value = props [ key ]; if ( typeof value === 'string' ) { props . class = `animated ${ value } ` ; } } }); const state = { animation : true } const start_animation = state => ({ animation : true }) const stop_animation = state => ({ animation : false }) const view = state => <> < link rel = \"stylesheet\" href = \"https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css\" >< /link> < img $animation = { state . animation && 'bounce infinite' } src = '../assets/logo.png' /> < div $animation = 'bounceInRight' > < button disabled = { state . animation } $onclick = { start_animation } > start < /button> < button disabled = { ! state . animation } $onclick = { stop_animation } > stop < /button> < /div> < /> app . start ( document . body , state , view ); Form Validation \u00b6 HTML5 Constraint Validation API simplifies client-side validation. We can use basic validation by choosing the type attribute of input elements, such as email and URL. Or we can use the pattern attribute for validation using regular expression. Also, we can use the required , maxlength , min , and max attributes. We can create the $validation directive to display the validation results by setting and removing the class. const validate = ( e ) => { const element = e . target ; element . checkValidity (); console . log ( element . validity . valid ); if ( element . validity . valid ) { element . classList . remove ( 'is-invalid' ); } else { element . classList . add ( 'is-invalid' ); } } app . on ( '$' , ({ key , props }) => { if ( key === '$validate' ) { const event = props [ key ]; props [ 'oninput' ] = validate ; } }); const signIn = ( state , e ) => { e . preventDefault (); alert ( 'form submitted' ) } const view = ({ name }) => <> < style > { `.is-invalid { border: 2px solid red; color: red }` } < /style> < form autocomplete = \"off\" $onsubmit = \"signIn\" > < p > < label for = \"name\" autocomplete = \"off\" > Enter an name ( letters only ) : < /label> < input $validate type = \"text\" name = \"name\" required pattern = \"[A-Za-z]+\" /> < /p> < p > < label for = \"email\" autocomplete = \"off\" > Enter a email : < /label> < input $validate type = \"email\" name = \"email\" required /> < /p> < p > < label for = \"url\" autocomplete = \"off\" > Enter an URL : < /label> < input $validate type = \"url\" name = \"url\" required /> < /p> < button type = \"submit\" > Submit < /button> < /form> < div > { name } < /div> < />; app . start ( document . body , {}, view , { signIn });","title":"Directive"},{"location":"directive/#directives","text":"AppRun directives are syntax sugars that help simplify the code. They are custom attributes in JSX that have names starting with $. AppRun two out-of-the-box directives: $on and $bind.","title":"Directives"},{"location":"directive/#on","text":"The $on directive simplifies the code to convert the DOM events to AppRun events.","title":"$on..."},{"location":"directive/#publish-events","text":"class Counter extends Component { state = 0 ; view = state => <> < h1 > { state } < /h1> < button $onclick = '-1' >- 1 < /button> < button $onclick = '+1' >+ 1 < /button> < />; update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; } new Counter (). start ( document . body );","title":"Publish Events"},{"location":"directive/#invoke-functions","text":"The $on directive can also invoke functions. class Counter extends Component { state = 0 ; view = state => < div > < h1 > { state } < /h1> < button $onclick = { state => state - 1 } >- 1 < /button> < button $onclick = { state => state + 1 } >+ 1 < /button> < /div>; } new Counter (). start ( document . body );","title":"Invoke Functions"},{"location":"directive/#bind","text":"The $bind directive synchronizes the HTML input value to the state . See the $bind example below. const state = '' ; const view = state => < div > < h1 > Hello { state } < /h1> < input autofocus $bind /> < /div>; app . start ( document . body , state , view ); Or, you can bind to the properties of the state . const state = { a : 1 , b : 2 , get c () { return this . a + this . b ; } }; const view = ({ a , b , c }) => <> < input type = \"number\" $bind = \"a\" /> < input type = \"number\" $bind = \"b\" /> < p > { a } + { b } = { c } < /p> < />; app . start ( document . body , state , view );","title":"$bind"},{"location":"directive/#custom-directive","text":"When AppRun is processing the JSX code, it publishes the $ event when it finds the custom attributes like $X. Thus, you can subscribe to the $ event to provide your directives. app . on ( '$' , ({ key , props }) => { if ( key === '$animation' ) { const value = props [ key ]; if ( typeof value === 'string' ) { props . class = \\ `animated \\${value}\\`; } } });","title":"Custom directive"},{"location":"directive/#animation-directive","text":"We can create the $animation directive to attach the animation classes from the animation library, animation.css . See the $animation example below. // Animation Directive Using animate.css app . on ( '$' , ({ key , props }) => { if ( key === '$animation' ) { const value = props [ key ]; if ( typeof value === 'string' ) { props . class = `animated ${ value } ` ; } } }); const state = { animation : true } const start_animation = state => ({ animation : true }) const stop_animation = state => ({ animation : false }) const view = state => <> < link rel = \"stylesheet\" href = \"https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css\" >< /link> < img $animation = { state . animation && 'bounce infinite' } src = '../assets/logo.png' /> < div $animation = 'bounceInRight' > < button disabled = { state . animation } $onclick = { start_animation } > start < /button> < button disabled = { ! state . animation } $onclick = { stop_animation } > stop < /button> < /div> < /> app . start ( document . body , state , view );","title":"Animation directive"},{"location":"directive/#form-validation","text":"HTML5 Constraint Validation API simplifies client-side validation. We can use basic validation by choosing the type attribute of input elements, such as email and URL. Or we can use the pattern attribute for validation using regular expression. Also, we can use the required , maxlength , min , and max attributes. We can create the $validation directive to display the validation results by setting and removing the class. const validate = ( e ) => { const element = e . target ; element . checkValidity (); console . log ( element . validity . valid ); if ( element . validity . valid ) { element . classList . remove ( 'is-invalid' ); } else { element . classList . add ( 'is-invalid' ); } } app . on ( '$' , ({ key , props }) => { if ( key === '$validate' ) { const event = props [ key ]; props [ 'oninput' ] = validate ; } }); const signIn = ( state , e ) => { e . preventDefault (); alert ( 'form submitted' ) } const view = ({ name }) => <> < style > { `.is-invalid { border: 2px solid red; color: red }` } < /style> < form autocomplete = \"off\" $onsubmit = \"signIn\" > < p > < label for = \"name\" autocomplete = \"off\" > Enter an name ( letters only ) : < /label> < input $validate type = \"text\" name = \"name\" required pattern = \"[A-Za-z]+\" /> < /p> < p > < label for = \"email\" autocomplete = \"off\" > Enter a email : < /label> < input $validate type = \"email\" name = \"email\" required /> < /p> < p > < label for = \"url\" autocomplete = \"off\" > Enter an URL : < /label> < input $validate type = \"url\" name = \"url\" required /> < /p> < button type = \"submit\" > Submit < /button> < /form> < div > { name } < /div> < />; app . start ( document . body , {}, view , { signIn });","title":"Form Validation"},{"location":"event-pubsub/","text":"Event Pub-Sub \u00b6 Event publication and subscription, also known as event emitter, is a commonly used pattern in JavaScript programming. Publishing an event means raising an event for some other code to handle. Publishing an event is also referred to as firing an event or triggering an event. Subscribing an event means registering an event handler function to the event. The event handler function executes when the correspondent event At the core, AppRun is an event pub-sub system. Event Life Cycle \u00b6 When an AppRun event is published, the following steps take place: AppRun dispatches the events to the event handlers defined in the update along with the current state . The event handlers create a new state based on the current state . AppRun passes the new state to the view function. The view function creates HTML or a Virtual DOM. AppRun renders the HTML/Virtual DOM to the screen AppRun calls the optional rendered function to complete the AppRun event life cycle. AppRun Event Life Cycle connects the state , view , and update (event handlers) together. Take a look at the Counter example again. const state = 0 ; const view = state => { return `<div> <h1> ${ state } </h1> <button onclick='app.run(\"-1\")'>-1</button> <button onclick='app.run(\"+1\")'>+1</button> </div>` ; }; const update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; app . start ( document . body , state , view , update ); When one of the buttons is clicked, it publishes AppRun event +1 or -1. The event handlers increase or decrease the state and return a new state. The view function creates the virtual DOM using the new state. Finally, AppRun renders the virtual DOM. Event Scope \u00b6 In AppRun global application mode, events are global events, which means that events are published and handled globally by all modules. In AppRun components , events are limited within the component's local scope. Local events are only available inside the components. Note app.run publishes global events this.run publishes local events Event Directives \u00b6 In addition to using app.run and this.run for publishing events AppRun Directives provides syntax sugar to simplify event publishing. JSX Directives \u00b6 The directives are special HTML attributes with names starting with $, such as $onclick . They are extensions to the JSX syntax to simplify the JSX or add extra features. We can use $onclick to simplify the syntax of publishing AppRun events from < button onclick = {()=> app . run ( '+1' )} >+ 1 < /button> to We use tuples for passing event parameters. < button $onclick = {[ 'add' , + 1 ]} >+ 1 < /button> Also, the $onclick directive can call the event directly. const add = count => count + 1 ; const view = count => < button $onclick = { add } > Clicks : { count } < /button>; app . start ( document . body , 0 , view ); You can see, because there are no events in this case, we don't need the update object anymore. lit-html Directive \u00b6 lit-html is the DOM rendering technology that lets us write HTML templates using string literals . Following the idea of using the JSX event directive what can we do similar thing with lit-html? The good news is that lit-html also has the directive concept to bring the event directive to lit-html. So the directive for lit-html is called run . The example below shows how to use the run directive to trigger AppRun events. Also, similar to the JSX event directives, the run directive can call the event lifecycle directly. const add = ( state , delta ) => state + delta ; const view = state => { return html `<div> <h1> ${ state } </h1> <button @click= ${ run ( 'add' , - 1 ) } >-1</button> <button @click= ${ run ( 'add' , + 1 ) } >+1</button> </div>` ; }; app . start ( document . body , 0 , view , { add }); The run directive will: Call the add function Call the view function Render the HTML element (document.body) Asynchronous Events \u00b6 In the service API-oriented applications, the state is created asynchronous operations. e.g., getting remote data from the server. It is easy to handle asynchronous operations in the AppRun event handlers. We only need to add the async keyword in front of the event handler and call the functions that return a Promise object with the await keyword. const state = {}; const view = state => <> < div >< button $onclick = \"fetchComic\" > fetch ... < /button></div> { state . loading && < div > loading ... < /div>} { state . comic && < img src = { state . comic . url } /> } < />; const update = { 'loading' : ( state , loading ) => ({... state , loading }), 'fetchComic' : async _ => { app . run ( 'loading' , true ); const response = await fetch ( 'https://xkcd-imgs.herokuapp.com/' ); const comic = await response . json (); return { comic }; } }; app . start ( document . body , state , view , update ); Use Events for Everything \u00b6 Web programming is event-driven. All we have to do is to convert DOM events to AppRun events to trigger the AppRun event life cycle. DOM events => AppRun Events => (current state) => Update => (new state) => View => (HTML/Virtual DOM) => Render Web Page Events are not only for handling user interactions. They are used for everything in AppRun. Routing is through events. Directives are through events. Event Typing \u00b6 Events can be strongly typed using TypeScript Discriminated Unions. If you are interested, please read this post: strong-typing .","title":"Event Pubsub"},{"location":"event-pubsub/#event-pub-sub","text":"Event publication and subscription, also known as event emitter, is a commonly used pattern in JavaScript programming. Publishing an event means raising an event for some other code to handle. Publishing an event is also referred to as firing an event or triggering an event. Subscribing an event means registering an event handler function to the event. The event handler function executes when the correspondent event At the core, AppRun is an event pub-sub system.","title":"Event Pub-Sub"},{"location":"event-pubsub/#event-life-cycle","text":"When an AppRun event is published, the following steps take place: AppRun dispatches the events to the event handlers defined in the update along with the current state . The event handlers create a new state based on the current state . AppRun passes the new state to the view function. The view function creates HTML or a Virtual DOM. AppRun renders the HTML/Virtual DOM to the screen AppRun calls the optional rendered function to complete the AppRun event life cycle. AppRun Event Life Cycle connects the state , view , and update (event handlers) together. Take a look at the Counter example again. const state = 0 ; const view = state => { return `<div> <h1> ${ state } </h1> <button onclick='app.run(\"-1\")'>-1</button> <button onclick='app.run(\"+1\")'>+1</button> </div>` ; }; const update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; app . start ( document . body , state , view , update ); When one of the buttons is clicked, it publishes AppRun event +1 or -1. The event handlers increase or decrease the state and return a new state. The view function creates the virtual DOM using the new state. Finally, AppRun renders the virtual DOM.","title":"Event Life Cycle"},{"location":"event-pubsub/#event-scope","text":"In AppRun global application mode, events are global events, which means that events are published and handled globally by all modules. In AppRun components , events are limited within the component's local scope. Local events are only available inside the components. Note app.run publishes global events this.run publishes local events","title":"Event Scope"},{"location":"event-pubsub/#event-directives","text":"In addition to using app.run and this.run for publishing events AppRun Directives provides syntax sugar to simplify event publishing.","title":"Event Directives"},{"location":"event-pubsub/#jsx-directives","text":"The directives are special HTML attributes with names starting with $, such as $onclick . They are extensions to the JSX syntax to simplify the JSX or add extra features. We can use $onclick to simplify the syntax of publishing AppRun events from < button onclick = {()=> app . run ( '+1' )} >+ 1 < /button> to We use tuples for passing event parameters. < button $onclick = {[ 'add' , + 1 ]} >+ 1 < /button> Also, the $onclick directive can call the event directly. const add = count => count + 1 ; const view = count => < button $onclick = { add } > Clicks : { count } < /button>; app . start ( document . body , 0 , view ); You can see, because there are no events in this case, we don't need the update object anymore.","title":"JSX Directives"},{"location":"event-pubsub/#lit-html-directive","text":"lit-html is the DOM rendering technology that lets us write HTML templates using string literals . Following the idea of using the JSX event directive what can we do similar thing with lit-html? The good news is that lit-html also has the directive concept to bring the event directive to lit-html. So the directive for lit-html is called run . The example below shows how to use the run directive to trigger AppRun events. Also, similar to the JSX event directives, the run directive can call the event lifecycle directly. const add = ( state , delta ) => state + delta ; const view = state => { return html `<div> <h1> ${ state } </h1> <button @click= ${ run ( 'add' , - 1 ) } >-1</button> <button @click= ${ run ( 'add' , + 1 ) } >+1</button> </div>` ; }; app . start ( document . body , 0 , view , { add }); The run directive will: Call the add function Call the view function Render the HTML element (document.body)","title":"lit-html Directive"},{"location":"event-pubsub/#asynchronous-events","text":"In the service API-oriented applications, the state is created asynchronous operations. e.g., getting remote data from the server. It is easy to handle asynchronous operations in the AppRun event handlers. We only need to add the async keyword in front of the event handler and call the functions that return a Promise object with the await keyword. const state = {}; const view = state => <> < div >< button $onclick = \"fetchComic\" > fetch ... < /button></div> { state . loading && < div > loading ... < /div>} { state . comic && < img src = { state . comic . url } /> } < />; const update = { 'loading' : ( state , loading ) => ({... state , loading }), 'fetchComic' : async _ => { app . run ( 'loading' , true ); const response = await fetch ( 'https://xkcd-imgs.herokuapp.com/' ); const comic = await response . json (); return { comic }; } }; app . start ( document . body , state , view , update );","title":"Asynchronous Events"},{"location":"event-pubsub/#use-events-for-everything","text":"Web programming is event-driven. All we have to do is to convert DOM events to AppRun events to trigger the AppRun event life cycle. DOM events => AppRun Events => (current state) => Update => (new state) => View => (HTML/Virtual DOM) => Render Web Page Events are not only for handling user interactions. They are used for everything in AppRun. Routing is through events. Directives are through events.","title":"Use Events for Everything"},{"location":"event-pubsub/#event-typing","text":"Events can be strongly typed using TypeScript Discriminated Unions. If you are interested, please read this post: strong-typing .","title":"Event Typing"},{"location":"getting-started/","text":"Getting Started \u00b6 This guide describes how to get up and running with AppRun in minutes. You can choose one of the following options: Use AppRun in the browser without any installation Use the npm create apprun-app to create a new AppRun project Create an AppRun Site for SSR and static site generation Installation \u00b6 AppRun is distributed on npm. To get it, run: npm install apprun You can use AppRun directly from the unpkg.com CDN: < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" >< /script> < script > const view = state => `<div> ${ state } </div>` ; app . start ( document . body , 'hello AppRun' , view ); < /script> Or, use the ESM version: < script type = \"module\" > import { app } from 'https://unpkg.com/apprun/dist/apprun-html.esm.js' ; const view = state => `<div> ${ state } </div>` ; app . start ( document . body , 'hello AppRun ESM' , view ); < /script>","title":"Installation"},{"location":"getting-started/#getting-started","text":"This guide describes how to get up and running with AppRun in minutes. You can choose one of the following options: Use AppRun in the browser without any installation Use the npm create apprun-app to create a new AppRun project Create an AppRun Site for SSR and static site generation","title":"Getting Started"},{"location":"getting-started/#installation","text":"AppRun is distributed on npm. To get it, run: npm install apprun You can use AppRun directly from the unpkg.com CDN: < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" >< /script> < script > const view = state => `<div> ${ state } </div>` ; app . start ( document . body , 'hello AppRun' , view ); < /script> Or, use the ESM version: < script type = \"module\" > import { app } from 'https://unpkg.com/apprun/dist/apprun-html.esm.js' ; const view = state => `<div> ${ state } </div>` ; app . start ( document . body , 'hello AppRun ESM' , view ); < /script>","title":"Installation"},{"location":"notebooks/","text":"Notebooks \u00b6 A notebook interface (also called a computational notebook) is a virtual notebook environment used for literate programming -- wikipedia Notebooks have a series of cells containing text, code, and visualizations. Observable \u00b6 Observable is a website for online JavaScript notebooks. You can use AppRun on the Observable site by following the steps: Import app, html from @yysun/apprun Create the state , view , and update Create a div Start an app on the div Visit https://observablehq.com/@yysun?tab=notebooks for more examples. .NET Interactive Notebooks \u00b6 With the .NET Interactive Notebooks extension for Visual Studio Code installed, we can run the .NET Interactive notebooks in Visual Studio Code. The .NET Interactive notebooks support C#, F#, HTML, JavaScript, Power Shell, and even SQL. You use AppRun in the .NET Interactive notebooks by following the steps: Import AppRun Create a div Create the state , view , and update Start an app on the div Download the sample notebook .","title":"Notebooks"},{"location":"notebooks/#notebooks","text":"A notebook interface (also called a computational notebook) is a virtual notebook environment used for literate programming -- wikipedia Notebooks have a series of cells containing text, code, and visualizations.","title":"Notebooks"},{"location":"notebooks/#observable","text":"Observable is a website for online JavaScript notebooks. You can use AppRun on the Observable site by following the steps: Import app, html from @yysun/apprun Create the state , view , and update Create a div Start an app on the div Visit https://observablehq.com/@yysun?tab=notebooks for more examples.","title":"Observable"},{"location":"notebooks/#net-interactive-notebooks","text":"With the .NET Interactive Notebooks extension for Visual Studio Code installed, we can run the .NET Interactive notebooks in Visual Studio Code. The .NET Interactive notebooks support C#, F#, HTML, JavaScript, Power Shell, and even SQL. You use AppRun in the .NET Interactive notebooks by following the steps: Import AppRun Create a div Create the state , view , and update Start an app on the div Download the sample notebook .","title":".NET Interactive Notebooks"},{"location":"react/","text":"Use AppRun with React \u00b6 React is a popular JavaScript library for building user interfaces. Using AppRun and React in conjunction is one of the best ways to build a web app. You can use AppRun with React in one of the two ways. Use AppRun components in React apps Use React Virtual DOM in AppRun apps Use AppRun Components \u00b6 It only takes one line of code to use AppRun components in React. Let's use the code from the React Hooks Doc as an example. import React , { useState } from 'react' ; function Example () { // Declare a new state variable, which we'll call \"count\" const [ count , setCount ] = useState ( 0 ); return ( < div > < p > You clicked { count } times < /p> < button onClick = {() => setCount ( count + 1 )} > Click me < /button> < /div> ); } The same app using the AppRun looks like below. class MyComponent extends Component { state = 0 ; view = count => < div > < p > You clicked { count } times < /p> < button onclick = {()=> this . run ( 'add' )} > Click me < /button> < /div>; update = { add : state => state + 1 }; } new MyComponent (). start ( document . body ); To use the AppRun component in React is very easy. All you need to do is converting the AppRun component to a React component by calling the toReact function. import { Component } from 'apprun/esm/component' ; import toReact from 'apprun/react' ; class MyComponent extends Component { state = 0 ; view = count => < div > < p > You clicked { count } times < /p> < button onClick = {()=> this . run ( 'add' )} > Click me < /button> < /div>; update = { add : state => state + 1 }; } const App = toReact ( MyComponent ); export default App ; Note The React VDOM uses JSX. AppRun VDOM also uses JSX. They are similar. However, React VDOM does not have directives. So you cannot use the AppRun $onclick directive. Instead, you need to use the React onClick attribute. Now, with just one line conversion to React component, we successfully used AppRun in React apps. Thus, we have the elm-inspired AppRun architecture in the React apps. You can visit https://github.com/yysun-apprun to see an example React project created by the Create React App Cli that uses AppRun components. Use React VDOM \u00b6 On the other hand, since we can use any Virtual DOM (VDOM) technology in AppRun apps, including the one from React, lets' use the React VDOM in AppRun apps. It also just needs one line of code to replace the app.render function with the ReactDOM.render function. app . render = ( el , vdom ) => ReactDOM . render ( vdom , el ); Below is the AppRun app that uses React VDOM. import app from 'apprun' ; import React from 'react' ; import ReactDOM from 'react-dom' ; app . render = ( el , vdom ) => ReactDOM . render ( vdom , el ); class MyComponent extends Component { state = 0 ; view = count => < div > < p > You clicked { count } times < /p> < button onClick = {()=> this . run ( 'add' )} > Click me < /button> < /div>; update = { add : state => state + 1 }; } new MyComponent (). start ( document . body ); Again, you must remember to use the React onClick attribute instead of the AppRun $onclick directive. Conclusion \u00b6 If you prefer to use React as the main framework, you can use AppRun to get the elm-inspired architecture. If you choose to use AppRun, you can also use the React Virtual DOM for rendering. You get the best of both worlds.","title":"Use with React"},{"location":"react/#use-apprun-with-react","text":"React is a popular JavaScript library for building user interfaces. Using AppRun and React in conjunction is one of the best ways to build a web app. You can use AppRun with React in one of the two ways. Use AppRun components in React apps Use React Virtual DOM in AppRun apps","title":"Use AppRun with React"},{"location":"react/#use-apprun-components","text":"It only takes one line of code to use AppRun components in React. Let's use the code from the React Hooks Doc as an example. import React , { useState } from 'react' ; function Example () { // Declare a new state variable, which we'll call \"count\" const [ count , setCount ] = useState ( 0 ); return ( < div > < p > You clicked { count } times < /p> < button onClick = {() => setCount ( count + 1 )} > Click me < /button> < /div> ); } The same app using the AppRun looks like below. class MyComponent extends Component { state = 0 ; view = count => < div > < p > You clicked { count } times < /p> < button onclick = {()=> this . run ( 'add' )} > Click me < /button> < /div>; update = { add : state => state + 1 }; } new MyComponent (). start ( document . body ); To use the AppRun component in React is very easy. All you need to do is converting the AppRun component to a React component by calling the toReact function. import { Component } from 'apprun/esm/component' ; import toReact from 'apprun/react' ; class MyComponent extends Component { state = 0 ; view = count => < div > < p > You clicked { count } times < /p> < button onClick = {()=> this . run ( 'add' )} > Click me < /button> < /div>; update = { add : state => state + 1 }; } const App = toReact ( MyComponent ); export default App ; Note The React VDOM uses JSX. AppRun VDOM also uses JSX. They are similar. However, React VDOM does not have directives. So you cannot use the AppRun $onclick directive. Instead, you need to use the React onClick attribute. Now, with just one line conversion to React component, we successfully used AppRun in React apps. Thus, we have the elm-inspired AppRun architecture in the React apps. You can visit https://github.com/yysun-apprun to see an example React project created by the Create React App Cli that uses AppRun components.","title":"Use AppRun Components"},{"location":"react/#use-react-vdom","text":"On the other hand, since we can use any Virtual DOM (VDOM) technology in AppRun apps, including the one from React, lets' use the React VDOM in AppRun apps. It also just needs one line of code to replace the app.render function with the ReactDOM.render function. app . render = ( el , vdom ) => ReactDOM . render ( vdom , el ); Below is the AppRun app that uses React VDOM. import app from 'apprun' ; import React from 'react' ; import ReactDOM from 'react-dom' ; app . render = ( el , vdom ) => ReactDOM . render ( vdom , el ); class MyComponent extends Component { state = 0 ; view = count => < div > < p > You clicked { count } times < /p> < button onClick = {()=> this . run ( 'add' )} > Click me < /button> < /div>; update = { add : state => state + 1 }; } new MyComponent (). start ( document . body ); Again, you must remember to use the React onClick attribute instead of the AppRun $onclick directive.","title":"Use React VDOM"},{"location":"react/#conclusion","text":"If you prefer to use React as the main framework, you can use AppRun to get the elm-inspired architecture. If you choose to use AppRun, you can also use the React Virtual DOM for rendering. You get the best of both worlds.","title":"Conclusion"},{"location":"reactivity/","text":"Introduction \u00b6 Reactivity has been a hot buzzword for modern JavaScript UI frameworks in the past few years. Angular, Vue, and Svelte all have reactivity built-in. They are famous and popular because of their reactivity features. Reactivity means that the changed application state will automatically reflect in the DOM. Don't be confuse the reactivity with another buzz word, reactive programming . Reactive programming is programming with asynchronous data streams. I will have another post to explain reactive programming . Reactivity is related to the data binding concept. Data binding is the process that establishes a connection between the application state and the application UI. There are two major types of data binding : one-way bing and two-binding . One-way binding means that changes in the application state cause changes to the application UI. Two-way binding means that either application state or application UI changes (for example, with input elements) automatically update the other. The reactivity also applies to the state object properties. E.g., if there is a person object with the properties of first-name, last-name, and full-name, we want the full-name property to be reactive to the other two name properties. With the reactivity concept clarified, let's see how we can have reactivity in AppRun. One-Way \u00b6 Many frameworks use the concept of \"variable assignments trigger UI updates.\" E.g., Vue wires up the application state objects with a change detection mechanism to become a view model or Proxy. Then you can modify the view model to trigger the UI update. Svelte has a compiler to inject change detection around your application state object. You can also modify the state to trigger the UI update. Unlike other frameworks, AppRun uses the events to trigger UI updates following the event-driven web programming model naturally. During an AppRun event lifecycle : AppRun gives you the current state for you to create a new state AppRun calls your view function to create a virtual AppRun renders the virtual DOM if it is not null. You can feel the Hollywood Principle (Don't call us. We call you.) here, which usually means things are loosely coupled. We provide code pieces. The framework calls them when needed. In the example below, the AppRun $onclick directive calls the event handler, then calls the view function, and then renders the virtual DOM. const view = state => < div > < h1 > { state } < /h1> < button $onclick = { state => state - 1 } >+ 1 < /button> < button $onclick = { state => state + 1 } >+ 1 < /button> < /div>; app . start ( document . body , 0 , view ) Two-Way Binding \u00b6 AppRun $bind directive can update the state properties automatically when used with the input elements and the textarea element. It looks similar to Angular's ngModel , Vue' v-model , and Svelte's bind:value syntax. However, Angular, Vue, and Svelte have invented their own proprietary template language/syntax that you need to learn. AppRun uses the JSX that React also uses. const view = state => <> < div > { state . text } < /div> < input $bind = \"text\" placeholder = \"type something here ...\" /> < /> app . start ( document . body , {}, view ) Reactive State \u00b6 The state properties' reactivity is not a problem that the UI frameworks are to solve. But if the UI frameworks wrap or change the original state objects, they have to solve the reactivity problems. E.g., Vue uses the computed object . Svelte uses the reactive-declarations , the famous $: sign. Property Getter \u00b6 Like in languages like Java and C#, JavaScript has object property getter , which we can use to compute the property values dynamically. const state = ({ a : 1 , b : 2 , get c () { return this . a + this . b ; } }) Binding to the state object properties is straightforward. // Reactivity - getter const state = { a : 1 , b : 2 , get c () { return this . a + this . b ; } }; const view = ({ a , b , c }) => <> < input type = \"number\" $bind = \"a\" /> < input type = \"number\" $bind = \"b\" /> < p > { a } + { b } = { c } < /p> < />; app . start ( document . body , state , view ); ES2015 Proxy \u00b6 The Proxy is used to define custom behavior for fundamental operations (e.g., property lookup, assignment, enumeration, function invocation, etc.). Proxies enable you to intercept and customize operations performed on objects (such as getting properties). They are a metaprogramming feature. - from Metaprogramming with proxies To create a Proxy, we create a handler first. Then, we combine the object proxied with the handler. const handler = ({ get : ( target , name ) => { const text = target . text || '' ; switch ( name ) { case 'text' : return target . text ; case 'characters' : return text . replace ( /\\s/g , '' ). length ; case 'words' : return ! text ? 0 : text . split ( /\\s/ ). length ; case 'lines' : return text . split ( '\\n' ). length ; default : return null } } }) const state = new Proxy ( { text : \"let's count\" }, handler ) Proxy has almost no barrier to use. Anywhere accepts objects can use Proxy. For example, AppRun can take a state with Proxy. // Reactivity - Proxy const handler = { get : ( target , name ) => { const text = target . text || '' ; switch ( name ) { case 'text' : return target . text ; case 'characters' : return text . replace ( /\\s/g , '' ). length ; case 'words' : return ! text ? 0 : text . split ( /\\s/ ). length ; case 'lines' : return text . split ( '\\n' ). length ; default : return null } } }; const state = new Proxy ( { text : \"let's count\" }, handler ); const view = state => < div > < textarea rows = \"10\" cols = \"50\" $bind = \"text\" >< /textarea> < div > chars : { state . characters } words : { state . words } lines : { state . lines } < /div> < pre > { state . text } < /pre> < /div>; app . start ( document . body , state , view ); I like Proxy because it takes the property value calculation logic out of the state objects. As a result, the proxy handler is much easier to test and maintain. On the other hand, the state objects stay lean. I want the state to act like the data transfer object (DTO) in traditional multi-layered application architecture, where the DTO is an object that carries data between logical and physical layers. Conclusion \u00b6 AppRun has full reactivity support that provides us the one-way and two-way data binding and the reactive state . Thus, we only need to use the native JavaScript/TypeScript features. Furthermore, AppRun does not require you to learn a new language or a new templating syntax.","title":"Reactivity"},{"location":"reactivity/#introduction","text":"Reactivity has been a hot buzzword for modern JavaScript UI frameworks in the past few years. Angular, Vue, and Svelte all have reactivity built-in. They are famous and popular because of their reactivity features. Reactivity means that the changed application state will automatically reflect in the DOM. Don't be confuse the reactivity with another buzz word, reactive programming . Reactive programming is programming with asynchronous data streams. I will have another post to explain reactive programming . Reactivity is related to the data binding concept. Data binding is the process that establishes a connection between the application state and the application UI. There are two major types of data binding : one-way bing and two-binding . One-way binding means that changes in the application state cause changes to the application UI. Two-way binding means that either application state or application UI changes (for example, with input elements) automatically update the other. The reactivity also applies to the state object properties. E.g., if there is a person object with the properties of first-name, last-name, and full-name, we want the full-name property to be reactive to the other two name properties. With the reactivity concept clarified, let's see how we can have reactivity in AppRun.","title":"Introduction"},{"location":"reactivity/#one-way","text":"Many frameworks use the concept of \"variable assignments trigger UI updates.\" E.g., Vue wires up the application state objects with a change detection mechanism to become a view model or Proxy. Then you can modify the view model to trigger the UI update. Svelte has a compiler to inject change detection around your application state object. You can also modify the state to trigger the UI update. Unlike other frameworks, AppRun uses the events to trigger UI updates following the event-driven web programming model naturally. During an AppRun event lifecycle : AppRun gives you the current state for you to create a new state AppRun calls your view function to create a virtual AppRun renders the virtual DOM if it is not null. You can feel the Hollywood Principle (Don't call us. We call you.) here, which usually means things are loosely coupled. We provide code pieces. The framework calls them when needed. In the example below, the AppRun $onclick directive calls the event handler, then calls the view function, and then renders the virtual DOM. const view = state => < div > < h1 > { state } < /h1> < button $onclick = { state => state - 1 } >+ 1 < /button> < button $onclick = { state => state + 1 } >+ 1 < /button> < /div>; app . start ( document . body , 0 , view )","title":"One-Way"},{"location":"reactivity/#two-way-binding","text":"AppRun $bind directive can update the state properties automatically when used with the input elements and the textarea element. It looks similar to Angular's ngModel , Vue' v-model , and Svelte's bind:value syntax. However, Angular, Vue, and Svelte have invented their own proprietary template language/syntax that you need to learn. AppRun uses the JSX that React also uses. const view = state => <> < div > { state . text } < /div> < input $bind = \"text\" placeholder = \"type something here ...\" /> < /> app . start ( document . body , {}, view )","title":"Two-Way Binding"},{"location":"reactivity/#reactive-state","text":"The state properties' reactivity is not a problem that the UI frameworks are to solve. But if the UI frameworks wrap or change the original state objects, they have to solve the reactivity problems. E.g., Vue uses the computed object . Svelte uses the reactive-declarations , the famous $: sign.","title":"Reactive State"},{"location":"reactivity/#property-getter","text":"Like in languages like Java and C#, JavaScript has object property getter , which we can use to compute the property values dynamically. const state = ({ a : 1 , b : 2 , get c () { return this . a + this . b ; } }) Binding to the state object properties is straightforward. // Reactivity - getter const state = { a : 1 , b : 2 , get c () { return this . a + this . b ; } }; const view = ({ a , b , c }) => <> < input type = \"number\" $bind = \"a\" /> < input type = \"number\" $bind = \"b\" /> < p > { a } + { b } = { c } < /p> < />; app . start ( document . body , state , view );","title":"Property Getter"},{"location":"reactivity/#es2015-proxy","text":"The Proxy is used to define custom behavior for fundamental operations (e.g., property lookup, assignment, enumeration, function invocation, etc.). Proxies enable you to intercept and customize operations performed on objects (such as getting properties). They are a metaprogramming feature. - from Metaprogramming with proxies To create a Proxy, we create a handler first. Then, we combine the object proxied with the handler. const handler = ({ get : ( target , name ) => { const text = target . text || '' ; switch ( name ) { case 'text' : return target . text ; case 'characters' : return text . replace ( /\\s/g , '' ). length ; case 'words' : return ! text ? 0 : text . split ( /\\s/ ). length ; case 'lines' : return text . split ( '\\n' ). length ; default : return null } } }) const state = new Proxy ( { text : \"let's count\" }, handler ) Proxy has almost no barrier to use. Anywhere accepts objects can use Proxy. For example, AppRun can take a state with Proxy. // Reactivity - Proxy const handler = { get : ( target , name ) => { const text = target . text || '' ; switch ( name ) { case 'text' : return target . text ; case 'characters' : return text . replace ( /\\s/g , '' ). length ; case 'words' : return ! text ? 0 : text . split ( /\\s/ ). length ; case 'lines' : return text . split ( '\\n' ). length ; default : return null } } }; const state = new Proxy ( { text : \"let's count\" }, handler ); const view = state => < div > < textarea rows = \"10\" cols = \"50\" $bind = \"text\" >< /textarea> < div > chars : { state . characters } words : { state . words } lines : { state . lines } < /div> < pre > { state . text } < /pre> < /div>; app . start ( document . body , state , view ); I like Proxy because it takes the property value calculation logic out of the state objects. As a result, the proxy handler is much easier to test and maintain. On the other hand, the state objects stay lean. I want the state to act like the data transfer object (DTO) in traditional multi-layered application architecture, where the DTO is an object that carries data between logical and physical layers.","title":"ES2015 Proxy"},{"location":"reactivity/#conclusion","text":"AppRun has full reactivity support that provides us the one-way and two-way data binding and the reactive state . Thus, we only need to use the native JavaScript/TypeScript features. Furthermore, AppRun does not require you to learn a new language or a new templating syntax.","title":"Conclusion"},{"location":"resources/","text":"Books and Resources \u00b6 Book About AppRun \u00b6 AppRun book published by Apress. Order from Amazon Blogs and Demos \u00b6 https://dev.to/@yysun https://glitch.com/@yysun https://observablehq.com/@yysun https://apprun.js.org/#play Posts \u00b6 All the Ways to Make a Web Component - May 2021 Update A Real-World Comparison of Front-End Frameworks with Benchmarks 2019 Update (2019) A Real-World Comparison of Front-End Frameworks with Benchmarks 2018 Update (2018) A Real-World Comparison of Front-End Frameworks with Benchmarks (2017) Performance Benchmark \u00b6 AppRun has also joined the js-framework-benchmark project. You can see its performance results compared to other frameworks and libraries.","title":"Resources"},{"location":"resources/#books-and-resources","text":"","title":"Books and Resources"},{"location":"resources/#book-about-apprun","text":"AppRun book published by Apress. Order from Amazon","title":"Book About AppRun"},{"location":"resources/#blogs-and-demos","text":"https://dev.to/@yysun https://glitch.com/@yysun https://observablehq.com/@yysun https://apprun.js.org/#play","title":"Blogs and Demos"},{"location":"resources/#posts","text":"All the Ways to Make a Web Component - May 2021 Update A Real-World Comparison of Front-End Frameworks with Benchmarks 2019 Update (2019) A Real-World Comparison of Front-End Frameworks with Benchmarks 2018 Update (2018) A Real-World Comparison of Front-End Frameworks with Benchmarks (2017)","title":"Posts"},{"location":"resources/#performance-benchmark","text":"AppRun has also joined the js-framework-benchmark project. You can see its performance results compared to other frameworks and libraries.","title":"Performance Benchmark"},{"location":"routing/","text":"Routing \u00b6 Routing in AppRun is event-driven. Therefore, handling routing using events is straightforward. Routing Event \u00b6 AppRun router detects the hash changes in the URL (by listening to the window's onpopstate event) and publishes the AppRun events using the hash as the event name. Components subscribe to the routing events. E.g., when the URL in the browser address bar becomes http://..../#counter, it triggers the #counter event. The Counter component reacts to the #counter and renders itself to the screen. That's it. There is no other code for routing. Unhandled Routes \u00b6 When the AppRun router triggers an AppRun event with no listener for the route, the router will automatically generate a ROUTER_404_EVENT AppRun event giving the application a chance to degrade gracefully by, perhaps, displaying a 404 page. To bind to this event, here are a few examples of things you can do: import app , { Component , ROUTER_404_EVENT } from 'apprun' ; // Generate an error message when there's no handler for a URL. app . on ( ROUTER_404_EVENT , ( url , ... _rest ) => console . error ( 'No event handler for' , url )); // Alternatively, create a component that will display a message. class NoRouteComponent extends Component { state = {}; view = ( state ) => { return <>< h1 > PAGE NOT FOUND ! WE SUCK !< /h1></ > } // Handle the \"no route found\" events with this component update = { [ ROUTER_404_EVENT ] : state => state } } new NoRouteComponent (). mount ( on some element ); Pretty Links \u00b6 If you would prefer to use pretty links (i.e., non-hash links) and have HTML5 browser history, then you can implement a new router yourself or use the pretty router from the apprun-router package. This router also handles unknown routes via the ROUTER_404_EVENT and has a few other goodies to make life easier. Replacing Default Router \u00b6 Replacing AppRun's default router couldn't be easier. Just overwrite app.route , and you're off to the races. You'll also want to bind to the popstate events and trigger the first URL event (via the DOMContentLoaded event handler in the code example below): // A simplistic but not great router. function newRouter ( url : string ) { app . run ( url ); app . run ( ROUTER_EVENT , url ); } // Kick off the first URL event when the DOM is loaded. document . addEventListener ( \"DOMContentLoaded\" , () => { window . onpopstate = app [ \"route\" ]( location . pathname , true ); newRouter ( location . pathname ); }); app [ \"route\" ] = newRouter ;","title":"Routing"},{"location":"routing/#routing","text":"Routing in AppRun is event-driven. Therefore, handling routing using events is straightforward.","title":"Routing"},{"location":"routing/#routing-event","text":"AppRun router detects the hash changes in the URL (by listening to the window's onpopstate event) and publishes the AppRun events using the hash as the event name. Components subscribe to the routing events. E.g., when the URL in the browser address bar becomes http://..../#counter, it triggers the #counter event. The Counter component reacts to the #counter and renders itself to the screen. That's it. There is no other code for routing.","title":"Routing Event"},{"location":"routing/#unhandled-routes","text":"When the AppRun router triggers an AppRun event with no listener for the route, the router will automatically generate a ROUTER_404_EVENT AppRun event giving the application a chance to degrade gracefully by, perhaps, displaying a 404 page. To bind to this event, here are a few examples of things you can do: import app , { Component , ROUTER_404_EVENT } from 'apprun' ; // Generate an error message when there's no handler for a URL. app . on ( ROUTER_404_EVENT , ( url , ... _rest ) => console . error ( 'No event handler for' , url )); // Alternatively, create a component that will display a message. class NoRouteComponent extends Component { state = {}; view = ( state ) => { return <>< h1 > PAGE NOT FOUND ! WE SUCK !< /h1></ > } // Handle the \"no route found\" events with this component update = { [ ROUTER_404_EVENT ] : state => state } } new NoRouteComponent (). mount ( on some element );","title":"Unhandled Routes"},{"location":"routing/#pretty-links","text":"If you would prefer to use pretty links (i.e., non-hash links) and have HTML5 browser history, then you can implement a new router yourself or use the pretty router from the apprun-router package. This router also handles unknown routes via the ROUTER_404_EVENT and has a few other goodies to make life easier.","title":"Pretty Links"},{"location":"routing/#replacing-default-router","text":"Replacing AppRun's default router couldn't be easier. Just overwrite app.route , and you're off to the races. You'll also want to bind to the popstate events and trigger the first URL event (via the DOMContentLoaded event handler in the code example below): // A simplistic but not great router. function newRouter ( url : string ) { app . run ( url ); app . run ( ROUTER_EVENT , url ); } // Kick off the first URL event when the DOM is loaded. document . addEventListener ( \"DOMContentLoaded\" , () => { window . onpopstate = app [ \"route\" ]( location . pathname , true ); newRouter ( location . pathname ); }); app [ \"route\" ] = newRouter ;","title":"Replacing Default Router"},{"location":"showcase/","text":"This page shows a few public applications built with AppRun. Conduit \u00b6 Project: https://github.com/gothinkster/apprun-realworld-example-app .modal-backdrop.show { opacity: 0.5; z-index: 1040 !important; } .modal-open { position: absolute; width: 100% } .modal-dialog { z-index: 1100 !important; } conduit conduit An interactive learning project from Thinkster . Code & design licensed under MIT. Hacker-News PWA \u00b6 Project: https://github.com/yysun/apprun-hn AppRun - HN * { box-sizing: border-box; margin: 0; padding: 0 } body { font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; font-size: 14px; line-height: 1.42857143; color: #333; background-color: #fff; overflow: scroll } a { color: #337ab7; text-decoration: none; background-color: transparent } ul { padding: 0; list-style: none } .inner { padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto } @media (min-width: 992px) { .inner { width: 970px } } @media (min-width: 768px) { .inner { width: 750px } } .hn .header { position: fixed; background-color: #faffe6; top: 0px; width: 100%; padding: 10px 0 } .hn .main { padding: 50px 0px } .hn .footer { position: fixed; background-color: #fff; right: 0; bottom: 0; left: 0; padding: 1rem } .hn .story-list li { padding: 10px 0 } .hn .score { color: #666; font-size: 1.1em; font-weight: 700; width: 60px; height: 60px; text-align: center; float: left; padding-top: 10px } .hn .meta { color: #aaa; white-space: nowrap } .hn .meta a { color: #096; cursor: pointer } .hn .comment { padding: 5px 0 5px 10px; border-left: 1px solid #eeeeee } .hn .text { padding: 10px 0 } .hn .toggle { color: #096; padding-bottom: 10px; cursor: pointer } .hn .collapsed { display: none } .hn .toggle:before { content: ' [-] ' } .hn .toggle.closed:before { content: ' [+] ' } .hn .toggle.closed:after { content: ' (...)' } .hn .more { margin-top: 20px; margin-left: 20px } .hn .more a { cursor: pointer; padding-bottom: 150px } if ('serviceWorker' in navigator) { navigator.serviceWorker.register('sw.js').then(function (registration) { // Registration was successful console.log('ServiceWorker registration successful with scope: ', registration.scope); }).catch(function (err) { // registration failed :( console.log('ServiceWorker registration failed: ', err); }); } TodoMVC \u00b6 Author: https://github.com/samsondav Project: https://github.com/samsondav/todomvc-apprun Double-click to edit a todo Created by Sam Davies Powered by AppRunJS Part of TodoMVC","title":"Showcase"},{"location":"showcase/#conduit","text":"Project: https://github.com/gothinkster/apprun-realworld-example-app .modal-backdrop.show { opacity: 0.5; z-index: 1040 !important; } .modal-open { position: absolute; width: 100% } .modal-dialog { z-index: 1100 !important; } conduit conduit An interactive learning project from Thinkster . Code & design licensed under MIT.","title":"Conduit"},{"location":"showcase/#hacker-news-pwa","text":"Project: https://github.com/yysun/apprun-hn AppRun - HN * { box-sizing: border-box; margin: 0; padding: 0 } body { font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; font-size: 14px; line-height: 1.42857143; color: #333; background-color: #fff; overflow: scroll } a { color: #337ab7; text-decoration: none; background-color: transparent } ul { padding: 0; list-style: none } .inner { padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto } @media (min-width: 992px) { .inner { width: 970px } } @media (min-width: 768px) { .inner { width: 750px } } .hn .header { position: fixed; background-color: #faffe6; top: 0px; width: 100%; padding: 10px 0 } .hn .main { padding: 50px 0px } .hn .footer { position: fixed; background-color: #fff; right: 0; bottom: 0; left: 0; padding: 1rem } .hn .story-list li { padding: 10px 0 } .hn .score { color: #666; font-size: 1.1em; font-weight: 700; width: 60px; height: 60px; text-align: center; float: left; padding-top: 10px } .hn .meta { color: #aaa; white-space: nowrap } .hn .meta a { color: #096; cursor: pointer } .hn .comment { padding: 5px 0 5px 10px; border-left: 1px solid #eeeeee } .hn .text { padding: 10px 0 } .hn .toggle { color: #096; padding-bottom: 10px; cursor: pointer } .hn .collapsed { display: none } .hn .toggle:before { content: ' [-] ' } .hn .toggle.closed:before { content: ' [+] ' } .hn .toggle.closed:after { content: ' (...)' } .hn .more { margin-top: 20px; margin-left: 20px } .hn .more a { cursor: pointer; padding-bottom: 150px } if ('serviceWorker' in navigator) { navigator.serviceWorker.register('sw.js').then(function (registration) { // Registration was successful console.log('ServiceWorker registration successful with scope: ', registration.scope); }).catch(function (err) { // registration failed :( console.log('ServiceWorker registration failed: ', err); }); }","title":"Hacker-News PWA"},{"location":"showcase/#todomvc","text":"Author: https://github.com/samsondav Project: https://github.com/samsondav/todomvc-apprun Double-click to edit a todo Created by Sam Davies Powered by AppRunJS Part of TodoMVC","title":"TodoMVC"},{"location":"spa/","text":"Single Page Apps \u00b6 Create Project \u00b6 You can initialize a project using the npm create apprun-app command and select the Single Page App template. npm create apprun-app [ my-app ] SPA Architecture \u00b6 AppRun SPA usually includes an HTML file, the main program that renders the screen layout, and page components that render the pages. . \u251c\u2500 dist/ \u251c\u2500 src/ \u2502 \u251c\u2500 About.tsx \u2502 \u251c\u2500 Contact.tsx \u2502 \u251c\u2500 Home.tsx \u2502 \u251c\u2500 Layour.tsx \u2502 \u2514\u2500 main.tsx \u2514\u2500 index.html Example of the index.html file: <!doctype html> < html > < head > < meta charset = \"utf-8\" > < title > AppRun SPA </ title > < body > < div id = \"main\" ></ div > < script src = \"dist/main.js\" ></ script > </ body > </ html > Example of the main.tsx file: import Home from './Home' ; import About from './About' ; import Contact from './Contact' ; import Layout from './Layout' ; new Layout (). start ( document . getElementById ( 'main' )); const element = document . getElementById ( 'my-app' ); new Home (). start ( element ); new About (). mount ( element ); new Contact (). mount ( element ); AppRun SPA uses the events to route user interaction to the components. Treating routing like other web events is the smart idea of AppRun. All web events are unified under the event pub-sub pattern. Routing does not require special treatment. Dynamic Component Loading \u00b6 AppRun components are modularized using the ECMAScript module standard. We can import the modules statically and dynamically. We can also use the native module from modern browsers. import app from 'apprun' ; import Layout from './Layout' ; new Layout (). start ( document . getElementById ( 'main' )); app . on ( '#,#home' , async () => { const module = await import ( './home' ); new module . default (). mount ( element ); }); app . on ( '#about' , async () => { const module = await import ( './about' ); new module . default (). mount ( element ); }); app . on ( '#contact' , async () => { const module = await import ( './contact' ); new module . default (). mount ( element ); })","title":"Single Page App"},{"location":"spa/#single-page-apps","text":"","title":"Single Page Apps"},{"location":"spa/#create-project","text":"You can initialize a project using the npm create apprun-app command and select the Single Page App template. npm create apprun-app [ my-app ]","title":"Create Project"},{"location":"spa/#spa-architecture","text":"AppRun SPA usually includes an HTML file, the main program that renders the screen layout, and page components that render the pages. . \u251c\u2500 dist/ \u251c\u2500 src/ \u2502 \u251c\u2500 About.tsx \u2502 \u251c\u2500 Contact.tsx \u2502 \u251c\u2500 Home.tsx \u2502 \u251c\u2500 Layour.tsx \u2502 \u2514\u2500 main.tsx \u2514\u2500 index.html Example of the index.html file: <!doctype html> < html > < head > < meta charset = \"utf-8\" > < title > AppRun SPA </ title > < body > < div id = \"main\" ></ div > < script src = \"dist/main.js\" ></ script > </ body > </ html > Example of the main.tsx file: import Home from './Home' ; import About from './About' ; import Contact from './Contact' ; import Layout from './Layout' ; new Layout (). start ( document . getElementById ( 'main' )); const element = document . getElementById ( 'my-app' ); new Home (). start ( element ); new About (). mount ( element ); new Contact (). mount ( element ); AppRun SPA uses the events to route user interaction to the components. Treating routing like other web events is the smart idea of AppRun. All web events are unified under the event pub-sub pattern. Routing does not require special treatment.","title":"SPA Architecture"},{"location":"spa/#dynamic-component-loading","text":"AppRun components are modularized using the ECMAScript module standard. We can import the modules statically and dynamically. We can also use the native module from modern browsers. import app from 'apprun' ; import Layout from './Layout' ; new Layout (). start ( document . getElementById ( 'main' )); app . on ( '#,#home' , async () => { const module = await import ( './home' ); new module . default (). mount ( element ); }); app . on ( '#about' , async () => { const module = await import ( './about' ); new module . default (). mount ( element ); }); app . on ( '#contact' , async () => { const module = await import ( './contact' ); new module . default (). mount ( element ); })","title":"Dynamic Component Loading"},{"location":"ssr/","text":"Server-Side Rendering \u00b6 AppRun is a front-end library for developing SPA. It also supports rendering the SPAs on the server-side, just like other frameworks. Furthermore, it also allows us to make existing traditional server-side rendered applications into SPAs. Thus, AppRun can make many existing applications built using the server-side model-view-control (MVC) architecture become SPAs quickly. SPA to SSR \u00b6 AppRun is isomorphic/universal. AppRun components can render on the client-side and on the server-side using the AppRun server-side view engine. Included in the SSR AppRun application example , there are: The express.js server application (server.ts), The site layout (components/layout.tsx), The AppRun components (components/*.tsx) The client-side application (/public/spa.js). You can run the application on @glitch, https://apprun-ssr.glitch.me . SSR to SPA \u00b6 Please read this post, Making ASP.NET Core MVC Apps into Single Page Apps using AppRun","title":"Server-Side Rendering"},{"location":"ssr/#server-side-rendering","text":"AppRun is a front-end library for developing SPA. It also supports rendering the SPAs on the server-side, just like other frameworks. Furthermore, it also allows us to make existing traditional server-side rendered applications into SPAs. Thus, AppRun can make many existing applications built using the server-side model-view-control (MVC) architecture become SPAs quickly.","title":"Server-Side Rendering"},{"location":"ssr/#spa-to-ssr","text":"AppRun is isomorphic/universal. AppRun components can render on the client-side and on the server-side using the AppRun server-side view engine. Included in the SSR AppRun application example , there are: The express.js server application (server.ts), The site layout (components/layout.tsx), The AppRun components (components/*.tsx) The client-side application (/public/spa.js). You can run the application on @glitch, https://apprun-ssr.glitch.me .","title":"SPA to SSR"},{"location":"ssr/#ssr-to-spa","text":"Please read this post, Making ASP.NET Core MVC Apps into Single Page Apps using AppRun","title":"SSR to SPA"},{"location":"state-management/","text":"State Management \u00b6 The State , one of three main parts of the AppRun architecture, plays an essential role in the AppRun event lifecycle. It is the equivalent of the Model of Elm architecture. Elm defines the Model as the application state. Modal and State are two names of the same thing. Therefore, they are interchangeable in the AppRun architecture. Most of the time, we use the term State in AppRun. The State is the application state at any given time of your application. The State is the data flow between Update and View. It acts as the data transfer object (DTO) in traditional multilayered application architecture, where the DTO is an object that carries data between logical and physical layers. The benefit of using events and DTO like the state is that there are no dependencies between the view and update (event handlers) . Thus, it makes the AppRun applications easier to develop, test, and maintain. You can get more information about unit testing later. Initial State \u00b6 We only need to define the initial state. The initial state is an immutable constant. AppRun manages the state through the event lifecycle. Asynchronous State \u00b6 We can define the initial state as a function. And even an asynchronous function to initialize the state. // Init State as an Async Function const state = async () => { const response = await fetch ( 'https://xkcd-imgs.herokuapp.com/' ); const comic = await response . json (); return { comic }; }; const view = state => <> { state . comic && < img src = { state . comic . url } /> } < />; app . start ( document . body , state , view ); State History \u00b6 The state can be stored in state history by AppRun. Once the state history is enabled, we can travel through the history back and forth to get the previous and next state. See the sample below. const state = []; const Counter = ({ num , idx }) => ( < div > < h1 > { num } < /h1> < button onclick = {() => app . run ( \"-1\" , idx )} >- 1 < /button> < button onclick = {() => app . run ( \"+1\" , idx )} >+ 1 < /button> < button onclick = {() => app . run ( \"remove-counter\" , idx )} > x < /button> < /div> ); const CounterList = ({ counters }) => counters . map (( num , idx ) => < Counter num = { num } idx = { idx } /> ); const view = ( state ) => { return ( < div > < div > < button onclick = {() => app . run ( \"history-prev\" )} > & lt ; & lt ; < /button> < button onclick = {() => app . run ( \"history-next\" )} > & gt ; & gt ; < /button> < button onclick = {() => app . run ( \"add-counter\" )} > add counter < /button> < button onclick = {() => app . run ( \"remove-counter\" , state . length - 1 )} disabled = { state . length <= 0 } > remove counter < /button> < /div> < br /> < CounterList counters = { state } /> < /div>); }; const update = { 'add-counter' : ( state ) => [... state , 0 ], 'remove-counter' : ( state , idx ) => [ ... state . slice ( 0 , idx ), ... state . slice ( idx + 1 ) ], '+1' : ( state , idx ) => [ ... state . slice ( 0 , idx ), state [ idx ] + 1 , ... state . slice ( idx + 1 ) ], '-1' : ( state , idx ) => [ ... state . slice ( 0 , idx ), state [ idx ] - 1 , ... state . slice ( idx + 1 ) ] }; app . start ( document . body , state , view , update , { history : true }); Although it is effortless to enable the AppRun state history, the caveat must be immutable. Because the AppRun state history stores the references to the states, if we have modified the state directly, each state stored in the state history refers to the same state, which is always the value of the last change. Thus, the time travel back and forward will not work. Therefore, the fundamental concept of using state history is to make the state immutable.","title":"State Management"},{"location":"state-management/#state-management","text":"The State , one of three main parts of the AppRun architecture, plays an essential role in the AppRun event lifecycle. It is the equivalent of the Model of Elm architecture. Elm defines the Model as the application state. Modal and State are two names of the same thing. Therefore, they are interchangeable in the AppRun architecture. Most of the time, we use the term State in AppRun. The State is the application state at any given time of your application. The State is the data flow between Update and View. It acts as the data transfer object (DTO) in traditional multilayered application architecture, where the DTO is an object that carries data between logical and physical layers. The benefit of using events and DTO like the state is that there are no dependencies between the view and update (event handlers) . Thus, it makes the AppRun applications easier to develop, test, and maintain. You can get more information about unit testing later.","title":"State Management"},{"location":"state-management/#initial-state","text":"We only need to define the initial state. The initial state is an immutable constant. AppRun manages the state through the event lifecycle.","title":"Initial State"},{"location":"state-management/#asynchronous-state","text":"We can define the initial state as a function. And even an asynchronous function to initialize the state. // Init State as an Async Function const state = async () => { const response = await fetch ( 'https://xkcd-imgs.herokuapp.com/' ); const comic = await response . json (); return { comic }; }; const view = state => <> { state . comic && < img src = { state . comic . url } /> } < />; app . start ( document . body , state , view );","title":"Asynchronous State"},{"location":"state-management/#state-history","text":"The state can be stored in state history by AppRun. Once the state history is enabled, we can travel through the history back and forth to get the previous and next state. See the sample below. const state = []; const Counter = ({ num , idx }) => ( < div > < h1 > { num } < /h1> < button onclick = {() => app . run ( \"-1\" , idx )} >- 1 < /button> < button onclick = {() => app . run ( \"+1\" , idx )} >+ 1 < /button> < button onclick = {() => app . run ( \"remove-counter\" , idx )} > x < /button> < /div> ); const CounterList = ({ counters }) => counters . map (( num , idx ) => < Counter num = { num } idx = { idx } /> ); const view = ( state ) => { return ( < div > < div > < button onclick = {() => app . run ( \"history-prev\" )} > & lt ; & lt ; < /button> < button onclick = {() => app . run ( \"history-next\" )} > & gt ; & gt ; < /button> < button onclick = {() => app . run ( \"add-counter\" )} > add counter < /button> < button onclick = {() => app . run ( \"remove-counter\" , state . length - 1 )} disabled = { state . length <= 0 } > remove counter < /button> < /div> < br /> < CounterList counters = { state } /> < /div>); }; const update = { 'add-counter' : ( state ) => [... state , 0 ], 'remove-counter' : ( state , idx ) => [ ... state . slice ( 0 , idx ), ... state . slice ( idx + 1 ) ], '+1' : ( state , idx ) => [ ... state . slice ( 0 , idx ), state [ idx ] + 1 , ... state . slice ( idx + 1 ) ], '-1' : ( state , idx ) => [ ... state . slice ( 0 , idx ), state [ idx ] - 1 , ... state . slice ( idx + 1 ) ] }; app . start ( document . body , state , view , update , { history : true }); Although it is effortless to enable the AppRun state history, the caveat must be immutable. Because the AppRun state history stores the references to the states, if we have modified the state directly, each state stored in the state history refers to the same state, which is always the value of the last change. Thus, the time travel back and forward will not work. Therefore, the fundamental concept of using state history is to make the state immutable.","title":"State History"},{"location":"strong-typing/","text":"Strong Typing \u00b6 From the AppRun architecture and AppRun event life cycle, we can see two places that require strong typing: state and event names. The initial state and the state passed between the view function and event handlers The event names for publishing and subscribing to Apprun events Strong Typing of State \u00b6 The state is used in the view function and in the update (event handlers). We can make the state strong typed in the view function and in the update . Typed View \u00b6 First, we can make the state used in the view strongly typed by importing the View type from AppRun and applying it to the view function. import { app , View } from 'apprun' ; const view : View < number > => state => < div > ... < /div> The View type imported from AppRun is a generic type . It makes the view function into a generic function, which let us define the type of its parameters. E.g., we define the view function to be View , TypeScript recognizes the state parameter of the view function is a number. Typed Update \u00b6 Next, let's import the Update type from AppRun and apply it to the update object. import { app , View , Update } from 'apprun' ; const update : Update < number > = { ... } The Update type imported from AppRun is also generic. It makes the event handlers in the update object into generic functions. TypeScript recognizes the state parameter of the event handler functions as are number. Typed Application \u00b6 Finally, let's make the application strongly typed. The app.start is a generic function already. If we give the app.start function a type, E.g., number, it means the state of the application is number, the view of the application is View and the update of the application is Update . app . start < number > ( ... ) If the type of state does not match the types assigned to the app.start function, TypeScript catches the type error. If the type of the view function does not match the types assigned to the app.start function, TypeScript catches the type error. If the type of the update object does not match the type assigned to the app.start function, TypeScript catches the type error. So far, e have made the strongly typed state to the view function, the event handlers in the update object, and the application. Next, we will move to make strongly typed events. Strong Typing of Events \u00b6 AppRun update object is a named collection or dictionary of the event handlers. The event names are strings, such as +1 and -1. They are not typed, not checked by the compiler, and not IDE friendly. Instead, we can use the TypeScript enum to define the event names. Enum of Event Names \u00b6 We define the Events enum and use it in the view functions and the update object. enum Events { inc = '+1' , dec = '-1' } You can see when we type 'Events.', Visual Studio code provides the intelliSense to help us typing. However, you can also see that the string +0 is still allowed in the update object. It is because the object index can only be a number or string. Or as long as a number or string is used, the compiler is happy and has no more type checking. Update Tuple \u00b6 The update can be an array of tuples for defining AppRun event handlers. The event handler tuple has two fields: the event name and the event handler function. We can use two advanced TypeScript types the tuple: union type and string literal type, to create so call discriminated union. For more information about union type, string literal type, and discriminated union, please refer to the TypeScript handbook. Discriminated Union Typed Event Names \u00b6 First, we define a union type called Events, which is made out of two string literal types, -1 and +1. type Events = '-1' | '+1' ; Then, we use the Events type as the second generic of the Update type imported from AppRun and apply it to the update tuple. const update : Update < number , Events > = [ ... ] The event names are strongly typed. TypeScript can even provide code auto-completion (IntelliSense) to hint at the event names. If the event name is not one of the strings defined in the Events type, TypeScript catches the error. Typed Events in View \u00b6 To make the event names in the view function strongly type, we need to make the event names of the application strongly type first. We can add the Events type to the app .start_ the generic function. app . start < number , Events > (...) It makes the application only can trigger the events that are defined in the Events type. Because we have made the event names strongly typed TypeScript provides intelliSense to the event names of the application. TypeScript also catches the event name errors in the view function. So far, we have accomplished strong typing for the AppRun global application. Next, we will implement strong typing for AppRun Components. Strong Typing of Component \u00b6 AppRun Component is like a scoped AppRun application. It also has three parts: state , view , and update . AppRun Component is a generic class. We create our components by extending the AppRun Component class. We can add the state type and events type to the Component class, as well as to the view function, and update the tuple to make the component strongly typed so that TypeScript can provide IntelliSense and type validation while we are coding. Typed Event Decorator \u00b6 The AppRun @on decorator makes a function in the component class to be an event handler. The @on decorator is also generic. When we add the event type to the @on the decorator, TypeScript recognizes and enforces the event names to be the event type. Typed $on Directive \u00b6 The AppRun directive is a syntax sugar for JSX. The $on directive is helpful for publishing DOM events to AppRun events. The $on directive can be strongly typed. Conclusion \u00b6 Thanks to TypeScript, we can make AppRun application strong-typed.","title":"Strong Typing"},{"location":"strong-typing/#strong-typing","text":"From the AppRun architecture and AppRun event life cycle, we can see two places that require strong typing: state and event names. The initial state and the state passed between the view function and event handlers The event names for publishing and subscribing to Apprun events","title":"Strong Typing"},{"location":"strong-typing/#strong-typing-of-state","text":"The state is used in the view function and in the update (event handlers). We can make the state strong typed in the view function and in the update .","title":"Strong Typing of\u00a0State"},{"location":"strong-typing/#typed-view","text":"First, we can make the state used in the view strongly typed by importing the View type from AppRun and applying it to the view function. import { app , View } from 'apprun' ; const view : View < number > => state => < div > ... < /div> The View type imported from AppRun is a generic type . It makes the view function into a generic function, which let us define the type of its parameters. E.g., we define the view function to be View , TypeScript recognizes the state parameter of the view function is a number.","title":"Typed View"},{"location":"strong-typing/#typed-update","text":"Next, let's import the Update type from AppRun and apply it to the update object. import { app , View , Update } from 'apprun' ; const update : Update < number > = { ... } The Update type imported from AppRun is also generic. It makes the event handlers in the update object into generic functions. TypeScript recognizes the state parameter of the event handler functions as are number.","title":"Typed Update"},{"location":"strong-typing/#typed-application","text":"Finally, let's make the application strongly typed. The app.start is a generic function already. If we give the app.start function a type, E.g., number, it means the state of the application is number, the view of the application is View and the update of the application is Update . app . start < number > ( ... ) If the type of state does not match the types assigned to the app.start function, TypeScript catches the type error. If the type of the view function does not match the types assigned to the app.start function, TypeScript catches the type error. If the type of the update object does not match the type assigned to the app.start function, TypeScript catches the type error. So far, e have made the strongly typed state to the view function, the event handlers in the update object, and the application. Next, we will move to make strongly typed events.","title":"Typed Application"},{"location":"strong-typing/#strong-typing-of-events","text":"AppRun update object is a named collection or dictionary of the event handlers. The event names are strings, such as +1 and -1. They are not typed, not checked by the compiler, and not IDE friendly. Instead, we can use the TypeScript enum to define the event names.","title":"Strong Typing of\u00a0Events"},{"location":"strong-typing/#enum-of-event-names","text":"We define the Events enum and use it in the view functions and the update object. enum Events { inc = '+1' , dec = '-1' } You can see when we type 'Events.', Visual Studio code provides the intelliSense to help us typing. However, you can also see that the string +0 is still allowed in the update object. It is because the object index can only be a number or string. Or as long as a number or string is used, the compiler is happy and has no more type checking.","title":"Enum of Event\u00a0Names"},{"location":"strong-typing/#update-tuple","text":"The update can be an array of tuples for defining AppRun event handlers. The event handler tuple has two fields: the event name and the event handler function. We can use two advanced TypeScript types the tuple: union type and string literal type, to create so call discriminated union. For more information about union type, string literal type, and discriminated union, please refer to the TypeScript handbook.","title":"Update Tuple"},{"location":"strong-typing/#discriminated-union-typed-event-names","text":"First, we define a union type called Events, which is made out of two string literal types, -1 and +1. type Events = '-1' | '+1' ; Then, we use the Events type as the second generic of the Update type imported from AppRun and apply it to the update tuple. const update : Update < number , Events > = [ ... ] The event names are strongly typed. TypeScript can even provide code auto-completion (IntelliSense) to hint at the event names. If the event name is not one of the strings defined in the Events type, TypeScript catches the error.","title":"Discriminated Union Typed Event\u00a0Names"},{"location":"strong-typing/#typed-events-in-view","text":"To make the event names in the view function strongly type, we need to make the event names of the application strongly type first. We can add the Events type to the app .start_ the generic function. app . start < number , Events > (...) It makes the application only can trigger the events that are defined in the Events type. Because we have made the event names strongly typed TypeScript provides intelliSense to the event names of the application. TypeScript also catches the event name errors in the view function. So far, we have accomplished strong typing for the AppRun global application. Next, we will implement strong typing for AppRun Components.","title":"Typed Events in\u00a0View"},{"location":"strong-typing/#strong-typing-of-component","text":"AppRun Component is like a scoped AppRun application. It also has three parts: state , view , and update . AppRun Component is a generic class. We create our components by extending the AppRun Component class. We can add the state type and events type to the Component class, as well as to the view function, and update the tuple to make the component strongly typed so that TypeScript can provide IntelliSense and type validation while we are coding.","title":"Strong Typing of Component"},{"location":"strong-typing/#typed-event-decorator","text":"The AppRun @on decorator makes a function in the component class to be an event handler. The @on decorator is also generic. When we add the event type to the @on the decorator, TypeScript recognizes and enforces the event names to be the event type.","title":"Typed Event Decorator"},{"location":"strong-typing/#typed-on-directive","text":"The AppRun directive is a syntax sugar for JSX. The $on directive is helpful for publishing DOM events to AppRun events. The $on directive can be strongly typed.","title":"Typed $on Directive"},{"location":"strong-typing/#conclusion","text":"Thanks to TypeScript, we can make AppRun application strong-typed.","title":"Conclusion"},{"location":"svg/","text":"SVG \u00b6 Create SVG \u00b6 You can create SVG using JSX or lit-HTML. For example, below is a reimplementation of a snabbdom example by Jon Kleiser (@jkleiser). SVG use JSX \u00b6 const style = ` svg { display: block; margin-bottom: 10px; border: 1px solid gray; } g#carousel { -webkit-transition: -webkit-transform 1s ease; transition: transform 1s ease; } polygon { stroke: #808000; transition: fill 0.5s linear; } polygon#yellow { fill: rgba(255,255,0,0.4); } polygon#yellow:hover, polygon#yellow:active { fill: yellow; } polygon#green { fill: rgba(0,128,0,0.4); } polygon#green:hover, polygon#green:active { fill: green; } polygon#magenta { fill: rgba(255,0,255,0.4); } polygon#magenta:hover, polygon#magenta:active { fill: magenta; } polygon#red { fill: rgba(255,0,0,0.4); } polygon#red:hover, polygon#red:active { fill: red; } polygon#cyan { fill: rgba(0,255,255,0.4); } polygon#cyan:hover, polygon#cyan:active { fill: cyan; } polygon#blue { fill: rgba(0,0,255,0.4); } polygon#blue:hover, polygon#blue:active { fill: blue; } ` const triangles = [ { id : \"yellow\" , rot : 0 }, { id : \"green\" , rot : 60 }, { id : \"magenta\" , rot : 120 }, { id : \"red\" , rot : 180 }, { id : \"cyan\" , rot : 240 }, { id : \"blue\" , rot : 300 } ]; class SvgComponent extends Component { state = 0 ; view = state => { const transform = \"rotate(\" + state + \"deg)\" ; return < div className = \"view\" > < style > { style } < /style> < svg width = \"380\" height = \"380\" viewBox = \"-190,-190,380,380\" > < g id = \"carousel\" style = {{ transform }} > { triangles . map ( t => < polygon id = { t . id } points = \"-50,-88 0,-175 50,-88\" transform = { `rotate( ${ t . rot } )` } stroke - width = \"3\" /> )} < /g> < /svg> < button $onclick = \"rot+60\" > Rotate Clockwise < /button> < button $onclick = \"rot-60\" > Rotate Anticlockwise < /button> < button $onclick = \"reset\" > Reset < /button> < /div> }; update = { \"rot+60\" : state => state + 60 , \"rot-60\" : state => state - 60 , \"reset\" : state => 0 , }; } new SvgComponent (). start ( document . body ); SVG use lit-HTML \u00b6 const style = ` svg { display: block; margin-bottom: 10px; border: 1px solid gray; } g#carousel { -webkit-transition: -webkit-transform 1s ease; transition: transform 1s ease; } polygon { stroke: #808000; transition: fill 0.5s linear; } polygon#yellow { fill: rgba(255,255,0,0.4); } polygon#yellow:hover, polygon#yellow:active { fill: yellow; } polygon#green { fill: rgba(0,128,0,0.4); } polygon#green:hover, polygon#green:active { fill: green; } polygon#magenta { fill: rgba(255,0,255,0.4); } polygon#magenta:hover, polygon#magenta:active { fill: magenta; } polygon#red { fill: rgba(255,0,0,0.4); } polygon#red:hover, polygon#red:active { fill: red; } polygon#cyan { fill: rgba(0,255,255,0.4); } polygon#cyan:hover, polygon#cyan:active { fill: cyan; } polygon#blue { fill: rgba(0,0,255,0.4); } polygon#blue:hover, polygon#blue:active { fill: blue; } ` const triangles = [ { id : \"yellow\" , rot : 0 }, { id : \"green\" , rot : 60 }, { id : \"magenta\" , rot : 120 }, { id : \"red\" , rot : 180 }, { id : \"cyan\" , rot : 240 }, { id : \"blue\" , rot : 300 } ]; class SvgComponent extends Component { state = 0 ; view = state => { const items = triangles . map ( t => svg `<polygon id=\" ${ t . id } \" points=\"-50,-88 0,-175 50,-88\" transform=\"rotate( ${ t . rot } )\" stroke-width=\"3\" />` ); return html `<div class=\"view\"> <style> ${ style } </style> <svg width=\"380\" height=\"380\" viewBox=\"-190,-190,380,380\"> <g id=\"carousel\" style=\"transform: rotate( ${ state } deg);\"> ${ items } </g> </svg> <button @click= ${ run ( \"@rot+60\" ) } >Rotate Clockwise</button> <button @click= ${ run ( \"@rot-60\" ) } >Rotate Anticlockwise</button> <button @click= ${ run ( \"@reset\" ) } >Reset</button> </div>` ; }; update = { \"@rot+60\" : state => state + 60 , \"@rot-60\" : state => state - 60 , \"@reset\" : () => 0 , }; } new SvgComponent (). start ( document . body ); SVG - xlink:href \u00b6 You can use xlinkHref to define the xlink:href attribute of SVG. // SVG - xlink const view = () => < svg viewBox = \"0 0 150 20\" > < a xlinkHref = \"https://apprun.js.org/\" > < text x = \"10\" y = \"10\" font - size = \"5\" > Click Here < /text></a> < /svg> app . start ( document . body , {}, view ); SVG Event Handlers \u00b6 You can handle the onclick event of SVG elements. Or use the $onclick directive // SVG - $onclick const view = state => <> < div > click the buttons :< /div> < svg viewBox = \"0 0 520 520\" xmlns = \"http://www.w3.org/2000/svg\" > < rect x = \"10\" y = \"10\" width = \"90\" height = \"20\" fill = \"#aaa\" $onclick = \"test\" id = \"$onclick\" /> < rect x = \"110\" y = \"10\" width = \"90\" height = \"20\" fill = \"#bbb\" onclick = \"app.run('test', event)\" id = \"onclick\" /> < /svg> < /> const update = { test : ( state , evt ) => alert ( \"You have used: \" + evt . target . id ) } app . start ( document . body , '' , view , update ); SVG Animation \u00b6 You can use the animate element to add animation to SVG. // SVG - animation const view = () => <> < svg height = \"60\" width = \"160\" > < rect width = \"100%\" height = \"100%\" rx = \"10\" ry = \"10\" fill = \"lightgrey\" /> < circle cx = \"30\" cy = \"30\" r = \"20\" fill = 'lime' > < animate attributeType = \"XML\" attributeName = \"fill\" values = \"lime;lightgrey;lime;lightgrey\" dur = \"0.5s\" repeatCount = \"indefinite\" /> < /circle> < circle cx = \"80\" cy = \"30\" r = \"20\" fill = 'yellow' fill - opacity = '0.2' /> < circle cx = \"130\" cy = \"30\" r = \"20\" fill = 'orangered' fill - opacity = '0.2' /> < /svg> < />; app . start ( document . body , {}, view );","title":"SVG"},{"location":"svg/#svg","text":"","title":"SVG"},{"location":"svg/#create-svg","text":"You can create SVG using JSX or lit-HTML. For example, below is a reimplementation of a snabbdom example by Jon Kleiser (@jkleiser).","title":"Create SVG"},{"location":"svg/#svg-use-jsx","text":"const style = ` svg { display: block; margin-bottom: 10px; border: 1px solid gray; } g#carousel { -webkit-transition: -webkit-transform 1s ease; transition: transform 1s ease; } polygon { stroke: #808000; transition: fill 0.5s linear; } polygon#yellow { fill: rgba(255,255,0,0.4); } polygon#yellow:hover, polygon#yellow:active { fill: yellow; } polygon#green { fill: rgba(0,128,0,0.4); } polygon#green:hover, polygon#green:active { fill: green; } polygon#magenta { fill: rgba(255,0,255,0.4); } polygon#magenta:hover, polygon#magenta:active { fill: magenta; } polygon#red { fill: rgba(255,0,0,0.4); } polygon#red:hover, polygon#red:active { fill: red; } polygon#cyan { fill: rgba(0,255,255,0.4); } polygon#cyan:hover, polygon#cyan:active { fill: cyan; } polygon#blue { fill: rgba(0,0,255,0.4); } polygon#blue:hover, polygon#blue:active { fill: blue; } ` const triangles = [ { id : \"yellow\" , rot : 0 }, { id : \"green\" , rot : 60 }, { id : \"magenta\" , rot : 120 }, { id : \"red\" , rot : 180 }, { id : \"cyan\" , rot : 240 }, { id : \"blue\" , rot : 300 } ]; class SvgComponent extends Component { state = 0 ; view = state => { const transform = \"rotate(\" + state + \"deg)\" ; return < div className = \"view\" > < style > { style } < /style> < svg width = \"380\" height = \"380\" viewBox = \"-190,-190,380,380\" > < g id = \"carousel\" style = {{ transform }} > { triangles . map ( t => < polygon id = { t . id } points = \"-50,-88 0,-175 50,-88\" transform = { `rotate( ${ t . rot } )` } stroke - width = \"3\" /> )} < /g> < /svg> < button $onclick = \"rot+60\" > Rotate Clockwise < /button> < button $onclick = \"rot-60\" > Rotate Anticlockwise < /button> < button $onclick = \"reset\" > Reset < /button> < /div> }; update = { \"rot+60\" : state => state + 60 , \"rot-60\" : state => state - 60 , \"reset\" : state => 0 , }; } new SvgComponent (). start ( document . body );","title":"SVG use JSX"},{"location":"svg/#svg-use-lit-html","text":"const style = ` svg { display: block; margin-bottom: 10px; border: 1px solid gray; } g#carousel { -webkit-transition: -webkit-transform 1s ease; transition: transform 1s ease; } polygon { stroke: #808000; transition: fill 0.5s linear; } polygon#yellow { fill: rgba(255,255,0,0.4); } polygon#yellow:hover, polygon#yellow:active { fill: yellow; } polygon#green { fill: rgba(0,128,0,0.4); } polygon#green:hover, polygon#green:active { fill: green; } polygon#magenta { fill: rgba(255,0,255,0.4); } polygon#magenta:hover, polygon#magenta:active { fill: magenta; } polygon#red { fill: rgba(255,0,0,0.4); } polygon#red:hover, polygon#red:active { fill: red; } polygon#cyan { fill: rgba(0,255,255,0.4); } polygon#cyan:hover, polygon#cyan:active { fill: cyan; } polygon#blue { fill: rgba(0,0,255,0.4); } polygon#blue:hover, polygon#blue:active { fill: blue; } ` const triangles = [ { id : \"yellow\" , rot : 0 }, { id : \"green\" , rot : 60 }, { id : \"magenta\" , rot : 120 }, { id : \"red\" , rot : 180 }, { id : \"cyan\" , rot : 240 }, { id : \"blue\" , rot : 300 } ]; class SvgComponent extends Component { state = 0 ; view = state => { const items = triangles . map ( t => svg `<polygon id=\" ${ t . id } \" points=\"-50,-88 0,-175 50,-88\" transform=\"rotate( ${ t . rot } )\" stroke-width=\"3\" />` ); return html `<div class=\"view\"> <style> ${ style } </style> <svg width=\"380\" height=\"380\" viewBox=\"-190,-190,380,380\"> <g id=\"carousel\" style=\"transform: rotate( ${ state } deg);\"> ${ items } </g> </svg> <button @click= ${ run ( \"@rot+60\" ) } >Rotate Clockwise</button> <button @click= ${ run ( \"@rot-60\" ) } >Rotate Anticlockwise</button> <button @click= ${ run ( \"@reset\" ) } >Reset</button> </div>` ; }; update = { \"@rot+60\" : state => state + 60 , \"@rot-60\" : state => state - 60 , \"@reset\" : () => 0 , }; } new SvgComponent (). start ( document . body );","title":"SVG use lit-HTML"},{"location":"svg/#svg-xlinkhref","text":"You can use xlinkHref to define the xlink:href attribute of SVG. // SVG - xlink const view = () => < svg viewBox = \"0 0 150 20\" > < a xlinkHref = \"https://apprun.js.org/\" > < text x = \"10\" y = \"10\" font - size = \"5\" > Click Here < /text></a> < /svg> app . start ( document . body , {}, view );","title":"SVG - xlink:href"},{"location":"svg/#svg-event-handlers","text":"You can handle the onclick event of SVG elements. Or use the $onclick directive // SVG - $onclick const view = state => <> < div > click the buttons :< /div> < svg viewBox = \"0 0 520 520\" xmlns = \"http://www.w3.org/2000/svg\" > < rect x = \"10\" y = \"10\" width = \"90\" height = \"20\" fill = \"#aaa\" $onclick = \"test\" id = \"$onclick\" /> < rect x = \"110\" y = \"10\" width = \"90\" height = \"20\" fill = \"#bbb\" onclick = \"app.run('test', event)\" id = \"onclick\" /> < /svg> < /> const update = { test : ( state , evt ) => alert ( \"You have used: \" + evt . target . id ) } app . start ( document . body , '' , view , update );","title":"SVG Event Handlers"},{"location":"svg/#svg-animation","text":"You can use the animate element to add animation to SVG. // SVG - animation const view = () => <> < svg height = \"60\" width = \"160\" > < rect width = \"100%\" height = \"100%\" rx = \"10\" ry = \"10\" fill = \"lightgrey\" /> < circle cx = \"30\" cy = \"30\" r = \"20\" fill = 'lime' > < animate attributeType = \"XML\" attributeName = \"fill\" values = \"lime;lightgrey;lime;lightgrey\" dur = \"0.5s\" repeatCount = \"indefinite\" /> < /circle> < circle cx = \"80\" cy = \"30\" r = \"20\" fill = 'yellow' fill - opacity = '0.2' /> < circle cx = \"130\" cy = \"30\" r = \"20\" fill = 'orangered' fill - opacity = '0.2' /> < /svg> < />; app . start ( document . body , {}, view );","title":"SVG Animation"},{"location":"tutorial/","text":"Quick Start Tutorial \u00b6 Create Your First App \u00b6 AppRun Application logic is broken down into three separate parts in the AppRun architecture. State (a.k.a. Model) \u2014 the state of your application View \u2014 a function to display the state Update \u2014 a collection of event handlers to update the state Let's use the Counter app as an example and code it directly in the HTML file. < html > < head > < meta charset = \"utf-8\" > < title > Counter </ title > </ head > < body > < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" ></ script > < script > const state = 0 ; const view = state => { return html `<div> <h1> ${ state } </h1> <button onclick='app.run(\"-1\")'>-1</button> <button onclick='app.run(\"+1\")'>+1</button> </div>` ; }; const update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; app . start ( document . body , state , view , update ); </ script > </ body > </ html > It is easy to have simple code in the HTML file. However, most of the time, we use external script files for complex app logic. < html > < head > < meta charset = \"utf-8\" > < title > Counter </ title > </ head > < body > < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" ></ script > < script src = \"app.js\" ></ script > </ body > </ html > Next, we will create an AppRun component in the app.js file. Create Your First Component \u00b6 AppRun components are mini-applications with the state , view , and update architecture. It is straightforward to re-create the Counter app as a component. //app.js class Counter extends Component { state = 0 ; view = state => { return html `<div> <h1> ${ state } </h1> <button @click= ${ ()=> this . run ( \"-1\" ) } >-1</button> <button @click= ${ ()=> this . run ( \"+1\" ) } >+1</button> </div>` ; }; update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; } new Counter (). start ( document . body ); Note Components have local event events. We use this.run instead of app.run to publish local events. Create a Web Component \u00b6 AppRun components can be defined as web components/custom elements and used in HTML. All we need to do is to give the AppRun component a custom-element name using the app.webComponent function. < html > < head > < meta charset = \"utf-8\" > < title > Counter < /title> < /head> < body > < my - counter >< /my-counter> < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" >< /script> < script > class Counter extends Component { state = 0 ; view = state => { return html `<div> <h1> ${ state } </h1> <button @click= ${ ()=> this . run ( \"-1\" ) } >-1</button> <button @click= ${ ()=> this . run ( \"+1\" ) } >+1</button> </div>` ; }; update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; } app . webComponent ( 'my-counter' , Counter ); < /script> < /body> < /html> Create a Single-Page App \u00b6 We can easily make a single-page page (SPA) using AppRun components. Each page is a component that can be activated by anchor links like #Home, #contact, and #about. class Home extends Component { view = () => < div > Home < /div>; update = { '#, #home' : state => state }; } class Contact extends Component { view = () => < div > Contact < /div>; update = { '#contact' : state => state }; } class About extends Component { view = () => < div > About < /div>; update = { '#about' : state => state }; } const App = () => <> < div id = \"menus\" > < a href = \"#home\" > Home < /a>{' | '} < a href = \"#contact\" > Contact < /a>{' | '} < a href = \"#about\" > About < /a></div> < div id = \"pages\" >< /div> < /> app . render ( document . body , < App /> ); [ About , Contact , Home ]. map ( C => new C (). start ( 'pages' )); Note We have just created a simple SPA using components. In a real-world scenario, usually, create pages as modules and bundle them together or load them dynamically. Next, you will learn how to Use the npm create apprun-app to create a new AppRun project Create an AppRun Site for SSR and static site generation","title":"Tutorial"},{"location":"tutorial/#quick-start-tutorial","text":"","title":"Quick Start Tutorial"},{"location":"tutorial/#create-your-first-app","text":"AppRun Application logic is broken down into three separate parts in the AppRun architecture. State (a.k.a. Model) \u2014 the state of your application View \u2014 a function to display the state Update \u2014 a collection of event handlers to update the state Let's use the Counter app as an example and code it directly in the HTML file. < html > < head > < meta charset = \"utf-8\" > < title > Counter </ title > </ head > < body > < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" ></ script > < script > const state = 0 ; const view = state => { return html `<div> <h1> ${ state } </h1> <button onclick='app.run(\"-1\")'>-1</button> <button onclick='app.run(\"+1\")'>+1</button> </div>` ; }; const update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; app . start ( document . body , state , view , update ); </ script > </ body > </ html > It is easy to have simple code in the HTML file. However, most of the time, we use external script files for complex app logic. < html > < head > < meta charset = \"utf-8\" > < title > Counter </ title > </ head > < body > < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" ></ script > < script src = \"app.js\" ></ script > </ body > </ html > Next, we will create an AppRun component in the app.js file.","title":"Create Your First App"},{"location":"tutorial/#create-your-first-component","text":"AppRun components are mini-applications with the state , view , and update architecture. It is straightforward to re-create the Counter app as a component. //app.js class Counter extends Component { state = 0 ; view = state => { return html `<div> <h1> ${ state } </h1> <button @click= ${ ()=> this . run ( \"-1\" ) } >-1</button> <button @click= ${ ()=> this . run ( \"+1\" ) } >+1</button> </div>` ; }; update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; } new Counter (). start ( document . body ); Note Components have local event events. We use this.run instead of app.run to publish local events.","title":"Create Your First Component"},{"location":"tutorial/#create-a-web-component","text":"AppRun components can be defined as web components/custom elements and used in HTML. All we need to do is to give the AppRun component a custom-element name using the app.webComponent function. < html > < head > < meta charset = \"utf-8\" > < title > Counter < /title> < /head> < body > < my - counter >< /my-counter> < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" >< /script> < script > class Counter extends Component { state = 0 ; view = state => { return html `<div> <h1> ${ state } </h1> <button @click= ${ ()=> this . run ( \"-1\" ) } >-1</button> <button @click= ${ ()=> this . run ( \"+1\" ) } >+1</button> </div>` ; }; update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; } app . webComponent ( 'my-counter' , Counter ); < /script> < /body> < /html>","title":"Create a Web Component"},{"location":"tutorial/#create-a-single-page-app","text":"We can easily make a single-page page (SPA) using AppRun components. Each page is a component that can be activated by anchor links like #Home, #contact, and #about. class Home extends Component { view = () => < div > Home < /div>; update = { '#, #home' : state => state }; } class Contact extends Component { view = () => < div > Contact < /div>; update = { '#contact' : state => state }; } class About extends Component { view = () => < div > About < /div>; update = { '#about' : state => state }; } const App = () => <> < div id = \"menus\" > < a href = \"#home\" > Home < /a>{' | '} < a href = \"#contact\" > Contact < /a>{' | '} < a href = \"#about\" > About < /a></div> < div id = \"pages\" >< /div> < /> app . render ( document . body , < App /> ); [ About , Contact , Home ]. map ( C => new C (). start ( 'pages' )); Note We have just created a simple SPA using components. In a real-world scenario, usually, create pages as modules and bundle them together or load them dynamically. Next, you will learn how to Use the npm create apprun-app to create a new AppRun project Create an AppRun Site for SSR and static site generation","title":"Create a Single-Page App"},{"location":"unit-testing/","text":"Unit Testing \u00b6 AppRun architecture is unit test-oriented. The three architectural parts state , view , and update (event handlers) are decoupled. They are straightforward to test. AppRun development environment includes the Jest framework. The convention to run the tests is to use the npm script: npm run jest We can also run the Jest testing interactive mode using the npm script: npm test Jest watches file changes and runs the test files only related to changed files. Jest also executes the tests in parallel. Therefore, it is very fast to execute the tests. The interactive way for us to define which tests to be executed during the watch mode. Types of Testing \u00b6 There are two types of unit tests in the AppRun application. Test the events-states - publishing the events and asserting the states. Test the state-vdom - set the states and assert the VDOM output of the view function. Create Tests using CLI \u00b6 Creating unit tests could be tedious, but you can use the AppRun Dev Tools to generate the tests. First, include the CLI scripts in your HTML. < script src = \"https://unpkg.com/apprun@latest/dist/apprun-dev-tools.js\" ></ script > Event-State Tests \u00b6 Use the create-event-tests command to create event-state tests. State-VDOM Tests \u00b6 Use the create-state-tests (start|stop) command to create state-view tests. Examples \u00b6 Please check out the unit tests from the AppRun RealWorld example application . You can find: How to mock the API calls Event-State Test State-VDOM Test","title":"Unit Testing"},{"location":"unit-testing/#unit-testing","text":"AppRun architecture is unit test-oriented. The three architectural parts state , view , and update (event handlers) are decoupled. They are straightforward to test. AppRun development environment includes the Jest framework. The convention to run the tests is to use the npm script: npm run jest We can also run the Jest testing interactive mode using the npm script: npm test Jest watches file changes and runs the test files only related to changed files. Jest also executes the tests in parallel. Therefore, it is very fast to execute the tests. The interactive way for us to define which tests to be executed during the watch mode.","title":"Unit Testing"},{"location":"unit-testing/#types-of-testing","text":"There are two types of unit tests in the AppRun application. Test the events-states - publishing the events and asserting the states. Test the state-vdom - set the states and assert the VDOM output of the view function.","title":"Types of Testing"},{"location":"unit-testing/#create-tests-using-cli","text":"Creating unit tests could be tedious, but you can use the AppRun Dev Tools to generate the tests. First, include the CLI scripts in your HTML. < script src = \"https://unpkg.com/apprun@latest/dist/apprun-dev-tools.js\" ></ script >","title":"Create Tests using CLI"},{"location":"unit-testing/#event-state-tests","text":"Use the create-event-tests command to create event-state tests.","title":"Event-State Tests"},{"location":"unit-testing/#state-vdom-tests","text":"Use the create-state-tests (start|stop) command to create state-view tests.","title":"State-VDOM Tests"},{"location":"unit-testing/#examples","text":"Please check out the unit tests from the AppRun RealWorld example application . You can find: How to mock the API calls Event-State Test State-VDOM Test","title":"Examples"},{"location":"view-patterns/","text":"JSX \u00b6 AppRun uses virtual DOM technology (VDOM). The VDOM is the data representing a DOM structure. AppRun compares the VDOM with the real DOM and updates only the changed elements and element properties. It provides high performance. AppRun allows you to choose your favorite virtual DOM technology to create user interfaces in the view function. We recommend using JSX. Some advanced features only apply to JSX. JSX \u00b6 JSX is a syntax sugar of function calls. Thus, you can compose the functions and apply dynamic and conditional rendering without the run-time cost of parsing the HTML string. You can use the JSX features described below. JSX fragments \u00b6 JSX Fragments let you group a list of children without adding extra root node. E.g., you can use <> for declaring fragments. E.g., const view = <> < h1 > title 1 < /h1> < h2 > title 2 < /h2> < /> Function Calls \u00b6 We can also use the capitalized JSX tag to call JavaScript functions with capitalized function names. The functions are also known as the Pure Function Component. E.g., To render the todo item list, You can call the Todo function in an array.map function. const Todo = ({ todo , idx }) => < li > { todo . title } < /li>; const view = state => < ul class = \"todo-list\" > { state . list . map (( todo , idx ) => < Todo todo = { todo } idx = { idx } /> ) } < /ul> De-structuring Properties \u00b6 The call to the Todo function passes two properties todo and idx. In the Todo function, you can retrieve the two properties by de-structuring the parameters. const Todo = ({ todo , idx }) => < li > { todo . title } < /li>; Set Class \u00b6 Each todo item should have a class \u201cview\u201d that represents that active or complete for a complete status of the todo item. You can use the ternary operator to toggle between two classes. const Todo = ({ todo , idx }) => < li class = { todo . done ? \"completed\" : \"view\" } > Please note that AppRun supports using the keyword class in JSX. Toggle Class \u00b6 Sometimes, you need to toggle classes based on the state. You can also use the ternary operator to toggle the class. E.g., toggle the selected class to a menu item. < li >< a class = { state . filter === 'All' ? 'selected' : '' } > All < /a></li> Show and Hide Element \u00b6 To show or hide an element dynamically, you can use the && operator. const countComplete = state . list . filter ( todo => todo . done ). length || 0 ; { countComplete && < button > Clear completed < /button>} ref \u00b6 ref is a special JSX property, which is a callback function that is called after the view function is executed. const view = < div ref = { el =>{...}} >< /div> We can use ref function to update the HTML element, e.g., set focus to an input box . ref is a better method to update the element than using the rendered lifecycle function. Please think of using the ref function before you use the rendered function. Element embedding \u00b6 Furthermore, AppRun allows embedding elements directly into JSX . view = state => { const canvas = document . createElement ( 'canvas' ); return < div > { canvas } < /div> }; A few use cases of the Element embedding are: Create special element, e.g. element has shadow root Create elements using 3rd libraries. Create and cache the element to avoid recreation in every event lifecycle Just create the HTML element and add it to the AppRun view . Please think of embedding the element before you use the ref function. Directive \u00b6 The directive is the special property that looks like $xxx. When AppRun is processing the JSX code and finds the properties of $xxx, it publishes the $ event. The event parameters contain the directive key, properties, and tag Name of the HTML element and component instance. const view = < div $myDirective >< /div>; app . on ( '$' , ({ key , props , tag , component }) => { if ( key === '$myDirective' ) { } } We can subscribe to the $ event and create custom directives to modify the properties of the HTML element. See more details about directive in the next section.","title":"JSX"},{"location":"view-patterns/#jsx","text":"AppRun uses virtual DOM technology (VDOM). The VDOM is the data representing a DOM structure. AppRun compares the VDOM with the real DOM and updates only the changed elements and element properties. It provides high performance. AppRun allows you to choose your favorite virtual DOM technology to create user interfaces in the view function. We recommend using JSX. Some advanced features only apply to JSX.","title":"JSX"},{"location":"view-patterns/#jsx_1","text":"JSX is a syntax sugar of function calls. Thus, you can compose the functions and apply dynamic and conditional rendering without the run-time cost of parsing the HTML string. You can use the JSX features described below.","title":"JSX"},{"location":"view-patterns/#jsx-fragments","text":"JSX Fragments let you group a list of children without adding extra root node. E.g., you can use <> for declaring fragments. E.g., const view = <> < h1 > title 1 < /h1> < h2 > title 2 < /h2> < />","title":"JSX fragments"},{"location":"view-patterns/#function-calls","text":"We can also use the capitalized JSX tag to call JavaScript functions with capitalized function names. The functions are also known as the Pure Function Component. E.g., To render the todo item list, You can call the Todo function in an array.map function. const Todo = ({ todo , idx }) => < li > { todo . title } < /li>; const view = state => < ul class = \"todo-list\" > { state . list . map (( todo , idx ) => < Todo todo = { todo } idx = { idx } /> ) } < /ul>","title":"Function Calls"},{"location":"view-patterns/#de-structuring-properties","text":"The call to the Todo function passes two properties todo and idx. In the Todo function, you can retrieve the two properties by de-structuring the parameters. const Todo = ({ todo , idx }) => < li > { todo . title } < /li>;","title":"De-structuring Properties"},{"location":"view-patterns/#set-class","text":"Each todo item should have a class \u201cview\u201d that represents that active or complete for a complete status of the todo item. You can use the ternary operator to toggle between two classes. const Todo = ({ todo , idx }) => < li class = { todo . done ? \"completed\" : \"view\" } > Please note that AppRun supports using the keyword class in JSX.","title":"Set Class"},{"location":"view-patterns/#toggle-class","text":"Sometimes, you need to toggle classes based on the state. You can also use the ternary operator to toggle the class. E.g., toggle the selected class to a menu item. < li >< a class = { state . filter === 'All' ? 'selected' : '' } > All < /a></li>","title":"Toggle Class"},{"location":"view-patterns/#show-and-hide-element","text":"To show or hide an element dynamically, you can use the && operator. const countComplete = state . list . filter ( todo => todo . done ). length || 0 ; { countComplete && < button > Clear completed < /button>}","title":"Show and Hide Element"},{"location":"view-patterns/#ref","text":"ref is a special JSX property, which is a callback function that is called after the view function is executed. const view = < div ref = { el =>{...}} >< /div> We can use ref function to update the HTML element, e.g., set focus to an input box . ref is a better method to update the element than using the rendered lifecycle function. Please think of using the ref function before you use the rendered function.","title":"ref"},{"location":"view-patterns/#element-embedding","text":"Furthermore, AppRun allows embedding elements directly into JSX . view = state => { const canvas = document . createElement ( 'canvas' ); return < div > { canvas } < /div> }; A few use cases of the Element embedding are: Create special element, e.g. element has shadow root Create elements using 3rd libraries. Create and cache the element to avoid recreation in every event lifecycle Just create the HTML element and add it to the AppRun view . Please think of embedding the element before you use the ref function.","title":"Element embedding"},{"location":"view-patterns/#directive","text":"The directive is the special property that looks like $xxx. When AppRun is processing the JSX code and finds the properties of $xxx, it publishes the $ event. The event parameters contain the directive key, properties, and tag Name of the HTML element and component instance. const view = < div $myDirective >< /div>; app . on ( '$' , ({ key , props , tag , component }) => { if ( key === '$myDirective' ) { } } We can subscribe to the $ event and create custom directives to modify the properties of the HTML element. See more details about directive in the next section.","title":"Directive"},{"location":"architecture-ideas/dapr/","text":"Use AppRun with Dapr \u00b6 Welcome to the world of AppRun, microservices, CQRS, and Dapr. Dapr is a portable, serverless, event-driven runtime for building resilient, stateless, and stateful microservices. We can connect AppRun events to Dapr PubSub through WebSockets to build microservices using CQRS, and Dapr. https://github.com/yysun/apprun-dapr/","title":"Microservice wirh Dapr"},{"location":"architecture-ideas/dapr/#use-apprun-with-dapr","text":"Welcome to the world of AppRun, microservices, CQRS, and Dapr. Dapr is a portable, serverless, event-driven runtime for building resilient, stateless, and stateful microservices. We can connect AppRun events to Dapr PubSub through WebSockets to build microservices using CQRS, and Dapr. https://github.com/yysun/apprun-dapr/","title":"Use AppRun with Dapr"},{"location":"architecture-ideas/db-websocket/","text":"Introduction \u00b6 The database is a specific technology for storing, managing, and processing data. In the real-world, web sites, mobile apps, and business applications that serve dynamic content all have a backend database. Started being popular in the web and mobile apps, moving to the business applications, nowadays most of the database-driven applications use a REST API based architecture. The REST API provides flexibility, scalability, and simplicity over other traditional web services architectures. However, the primary purpose of the REST API is to decouple the backend and frontend, which assumes backend and frontend know nothing about each other. Even in case we know and own both backend and frontend, such as in many business applications, we still have to develop the backend API endpoints first. And then, we develop the frontend API clients. Developing backend and frontend separately is tedious and error-prone. Also, If we want to publish events from the frontend to be handled in the backend business logic modules, we cannot do it directly. Furthermore, the REST API is not a duplex protocol. Only the frontend can call the API. The backend cannot call the frontend. Therefore sometimes, the REST API has become a barrier between frontend and backend that costs us extra time and effort to overcome. In this post, I will introduce a new application architecture that allows us to send events back and forth between the frontend apps to the backend business logic modules using the WebSocket API and AppRun without REST API. The WebSocket API is a duplex communication channel. It works well with an event-driven framework, such as AppRun. The Architecture \u00b6 The new architecture uses the WebSocket API and AppRun event system. AppRun has two important functions: app.run and app.on . app.run fires events. app.on handles events. E.g.: Module A handles the print event: import app from 'apprun' ; export default () => app . on ( 'print' , e => console . log ( e )); Module B fires the print event: import app from 'apprun' ; app . run ( 'print' , {}); Module B can invoke the function in Module A without knowing Module A. It works when Module A and Module B are both frontend modules. Can the business logic modules behind the webserver also subscribe to the frontend events? Yes, that's the exact idea of the new architecture. Let's see how it works. An Example Application \u00b6 We will create a database-driven todo application to demonstrate the new architecture. The project has the following files: The database: db/todo.db is a SQLite database The public folder has the frontend code: index.html dist/app.js The server folder has the backend code: db.js : the business logic server.js : the web server using the express and _websocket libraries The src folder has the frontend code: todo.tsx : the AppRun component for managing the todo list main.tsx : the main program Send Events to Server Through WebSocket \u00b6 First, we create a WebSocket in the frontend app ( main.tsx ). Then, We define a special AppRun global event called //ws: , which sends the events to the server. const ws = new WebSocket ( `wss:// ${ location . host } ` ); app . on ( '//ws:' , ( event , state ) => { const msg = { event , state }; ws . send ( JSON . stringify ( msg )); }); Receiving Events from Frontend \u00b6 We create the WebSockets on the webserver side ( index.js ). We listen to the WebSockets messages and convert them to AppRun events. AppRun runs on the webserver. Just like Module A and Module B example above, the AppRun events will be handled in the business logic module ( db.js ). const apprun = require ( 'apprun' ). app ; require ( './db' ); const path = require ( 'path' ); const express = require ( 'express' ); const { createServer } = require ( 'http' ); const webSocket = require ( 'ws' ); const app = express (); app . use ( express . static ( path . join ( __dirname , '../public' ))); const server = createServer ( app ); const wss = new webSocket . Server ({ server }); wss . on ( 'connection' , function ( ws ) { ws . on ( 'message' , function ( data ) { try { const json = JSON . parse ( data ); console . log ( '==>' , json ); apprun . run ( json . event , json , ws ); } catch ( e ) { ws . send ( e . toString ()); console . error ( e ); } }); }); Notice the webserver also adds the WebSocket reference, ws as the event parameter for the business logic module. Handle Events in Business Logic Module \u00b6 We handle AppRun events in the business logic module ( db.js ) to complete the CRUD operations against the database. const app = require ( 'apprun' ). app ; const sqlite3 = require ( 'sqlite3' ). verbose (); const dbFile = \"db/todo.db\" ; app . on ( '@get-all-todo' , ( json , ws ) => { const sql = 'select * from todo' ; db . all ( sql , function ( err , rows ) { json . state = rows || []; ws . send ( JSON . stringify ( json )); }); }); app . on ( '@get-todo' , ( json , ws ) => { }); app . on ( '@create-todo' , ( json , ws ) => { }); app . on ( '@update-todo' , ( json , ws ) => { }); app . on ( '@delete-todo' , ( json , ws ) => { }); app . on ( '@delete-all-todo' , ( json , ws ) => { }); Once completed the database operations, we use the WebSocket reference, ws , to send events back. Receiving Events from Backend \u00b6 Receiving events from the backend in the frontend app ( main.tsx ) is straightforward. const ws = new WebSocket ( `wss:// ${ location . host } ` ); ws . onmessage = function ( msg ) { const { event , state } = JSON . parse ( msg . data ); app . run ( event , state ); } You can see now we have 9 lines of client-side code in main.tsx and 11 lines of server-side code in index.js for transferring AppRun events between frontend and backend through WebSockets. We also have a business logic module that operates the database using AppRun events. They are ready to serve the frontend application. The Frontend Application \u00b6 The frontend Todo application is a typical AppRun application that has the Elm inspired architecture ( todo.tsx ). Listed below is the simplified code except. import app , { Component } from 'apprun' ; const state = { filter : 0 , todos : [] } const add = () => { app . run ( '//ws:' , '@create-todo' , { title : document . getElementById ( 'new_todo' ). value , done : 0 }) }; const toggle = ( _ , todo ) => { app . run ( '//ws:' , '@update-todo' , { ... }) }; const remove = ( _ , todo ) => { app . run ( '//ws:' , '@delete-todo' , todo ) }; const clear = () => { app . run ( '//ws:' , '@delete-all-todo' ) }; const search = ( state , filter ) => ({ ... state , filter }); const view = ( state ) => {...} const update = { '@get-all-todo' : ( state , todos ) => ({ ... state , todos }), '@create-todo' : ( state , todo ) => ({ ... }), '@update-todo' : ( state , todo ) => { ... }, '@delete-todo' : ( state , todo ) => { ... }, '@delete-all-todo' : state => ({ ... state , todos : [] }) } export default new Component ( state , view , update ); You can see we have state , view , and update to form an AppRun component. The local functions handle local events, such as add , toggle , remove , clear , and search . These functions fire the global event //ws: to the WebSocket. The update object contains the event handlers for the events fired from the backend. That's all the implementation plan. For details, please take a look at the live demo and the source code if you like. Run the Demo \u00b6 Live Demo: https://glitch.com/~apprun-websockets-sqlite Source Code: https://github.com/yysun/apprun-websockets-sqlite Conclusion \u00b6 The todo application has demonstrated the architecture of using events through WebSockets. The web server has no REST API endpoints. The frontend has only event handlings and has no REST API calls. The architecture is useful for database-driven applications, especially business applications. Furthermore, AppRun events are not limited to frontend and WebSockets. We can use AppRun events with the Web Workers API explained in the AppRun Book . We can also use AppRun in the Electron Apps , Firebase, Cloud Pub-Sub, and more ... Feel the power of event pub-sub pattern and learn more about building applications with AppRun.","title":"Database and Websocket"},{"location":"architecture-ideas/db-websocket/#introduction","text":"The database is a specific technology for storing, managing, and processing data. In the real-world, web sites, mobile apps, and business applications that serve dynamic content all have a backend database. Started being popular in the web and mobile apps, moving to the business applications, nowadays most of the database-driven applications use a REST API based architecture. The REST API provides flexibility, scalability, and simplicity over other traditional web services architectures. However, the primary purpose of the REST API is to decouple the backend and frontend, which assumes backend and frontend know nothing about each other. Even in case we know and own both backend and frontend, such as in many business applications, we still have to develop the backend API endpoints first. And then, we develop the frontend API clients. Developing backend and frontend separately is tedious and error-prone. Also, If we want to publish events from the frontend to be handled in the backend business logic modules, we cannot do it directly. Furthermore, the REST API is not a duplex protocol. Only the frontend can call the API. The backend cannot call the frontend. Therefore sometimes, the REST API has become a barrier between frontend and backend that costs us extra time and effort to overcome. In this post, I will introduce a new application architecture that allows us to send events back and forth between the frontend apps to the backend business logic modules using the WebSocket API and AppRun without REST API. The WebSocket API is a duplex communication channel. It works well with an event-driven framework, such as AppRun.","title":"Introduction"},{"location":"architecture-ideas/db-websocket/#the-architecture","text":"The new architecture uses the WebSocket API and AppRun event system. AppRun has two important functions: app.run and app.on . app.run fires events. app.on handles events. E.g.: Module A handles the print event: import app from 'apprun' ; export default () => app . on ( 'print' , e => console . log ( e )); Module B fires the print event: import app from 'apprun' ; app . run ( 'print' , {}); Module B can invoke the function in Module A without knowing Module A. It works when Module A and Module B are both frontend modules. Can the business logic modules behind the webserver also subscribe to the frontend events? Yes, that's the exact idea of the new architecture. Let's see how it works.","title":"The Architecture"},{"location":"architecture-ideas/db-websocket/#an-example-application","text":"We will create a database-driven todo application to demonstrate the new architecture. The project has the following files: The database: db/todo.db is a SQLite database The public folder has the frontend code: index.html dist/app.js The server folder has the backend code: db.js : the business logic server.js : the web server using the express and _websocket libraries The src folder has the frontend code: todo.tsx : the AppRun component for managing the todo list main.tsx : the main program","title":"An Example Application"},{"location":"architecture-ideas/db-websocket/#send-events-to-server-through-websocket","text":"First, we create a WebSocket in the frontend app ( main.tsx ). Then, We define a special AppRun global event called //ws: , which sends the events to the server. const ws = new WebSocket ( `wss:// ${ location . host } ` ); app . on ( '//ws:' , ( event , state ) => { const msg = { event , state }; ws . send ( JSON . stringify ( msg )); });","title":"Send Events to Server Through WebSocket"},{"location":"architecture-ideas/db-websocket/#receiving-events-from-frontend","text":"We create the WebSockets on the webserver side ( index.js ). We listen to the WebSockets messages and convert them to AppRun events. AppRun runs on the webserver. Just like Module A and Module B example above, the AppRun events will be handled in the business logic module ( db.js ). const apprun = require ( 'apprun' ). app ; require ( './db' ); const path = require ( 'path' ); const express = require ( 'express' ); const { createServer } = require ( 'http' ); const webSocket = require ( 'ws' ); const app = express (); app . use ( express . static ( path . join ( __dirname , '../public' ))); const server = createServer ( app ); const wss = new webSocket . Server ({ server }); wss . on ( 'connection' , function ( ws ) { ws . on ( 'message' , function ( data ) { try { const json = JSON . parse ( data ); console . log ( '==>' , json ); apprun . run ( json . event , json , ws ); } catch ( e ) { ws . send ( e . toString ()); console . error ( e ); } }); }); Notice the webserver also adds the WebSocket reference, ws as the event parameter for the business logic module.","title":"Receiving Events from Frontend"},{"location":"architecture-ideas/db-websocket/#handle-events-in-business-logic-module","text":"We handle AppRun events in the business logic module ( db.js ) to complete the CRUD operations against the database. const app = require ( 'apprun' ). app ; const sqlite3 = require ( 'sqlite3' ). verbose (); const dbFile = \"db/todo.db\" ; app . on ( '@get-all-todo' , ( json , ws ) => { const sql = 'select * from todo' ; db . all ( sql , function ( err , rows ) { json . state = rows || []; ws . send ( JSON . stringify ( json )); }); }); app . on ( '@get-todo' , ( json , ws ) => { }); app . on ( '@create-todo' , ( json , ws ) => { }); app . on ( '@update-todo' , ( json , ws ) => { }); app . on ( '@delete-todo' , ( json , ws ) => { }); app . on ( '@delete-all-todo' , ( json , ws ) => { }); Once completed the database operations, we use the WebSocket reference, ws , to send events back.","title":"Handle Events in Business Logic Module"},{"location":"architecture-ideas/db-websocket/#receiving-events-from-backend","text":"Receiving events from the backend in the frontend app ( main.tsx ) is straightforward. const ws = new WebSocket ( `wss:// ${ location . host } ` ); ws . onmessage = function ( msg ) { const { event , state } = JSON . parse ( msg . data ); app . run ( event , state ); } You can see now we have 9 lines of client-side code in main.tsx and 11 lines of server-side code in index.js for transferring AppRun events between frontend and backend through WebSockets. We also have a business logic module that operates the database using AppRun events. They are ready to serve the frontend application.","title":"Receiving Events from Backend"},{"location":"architecture-ideas/db-websocket/#the-frontend-application","text":"The frontend Todo application is a typical AppRun application that has the Elm inspired architecture ( todo.tsx ). Listed below is the simplified code except. import app , { Component } from 'apprun' ; const state = { filter : 0 , todos : [] } const add = () => { app . run ( '//ws:' , '@create-todo' , { title : document . getElementById ( 'new_todo' ). value , done : 0 }) }; const toggle = ( _ , todo ) => { app . run ( '//ws:' , '@update-todo' , { ... }) }; const remove = ( _ , todo ) => { app . run ( '//ws:' , '@delete-todo' , todo ) }; const clear = () => { app . run ( '//ws:' , '@delete-all-todo' ) }; const search = ( state , filter ) => ({ ... state , filter }); const view = ( state ) => {...} const update = { '@get-all-todo' : ( state , todos ) => ({ ... state , todos }), '@create-todo' : ( state , todo ) => ({ ... }), '@update-todo' : ( state , todo ) => { ... }, '@delete-todo' : ( state , todo ) => { ... }, '@delete-all-todo' : state => ({ ... state , todos : [] }) } export default new Component ( state , view , update ); You can see we have state , view , and update to form an AppRun component. The local functions handle local events, such as add , toggle , remove , clear , and search . These functions fire the global event //ws: to the WebSocket. The update object contains the event handlers for the events fired from the backend. That's all the implementation plan. For details, please take a look at the live demo and the source code if you like.","title":"The Frontend Application"},{"location":"architecture-ideas/db-websocket/#run-the-demo","text":"Live Demo: https://glitch.com/~apprun-websockets-sqlite Source Code: https://github.com/yysun/apprun-websockets-sqlite","title":"Run the Demo"},{"location":"architecture-ideas/db-websocket/#conclusion","text":"The todo application has demonstrated the architecture of using events through WebSockets. The web server has no REST API endpoints. The frontend has only event handlings and has no REST API calls. The architecture is useful for database-driven applications, especially business applications. Furthermore, AppRun events are not limited to frontend and WebSockets. We can use AppRun events with the Web Workers API explained in the AppRun Book . We can also use AppRun in the Electron Apps , Firebase, Cloud Pub-Sub, and more ... Feel the power of event pub-sub pattern and learn more about building applications with AppRun.","title":"Conclusion"},{"location":"architecture-ideas/firebase-app/","text":"Introduction \u00b6 I have been writing about the application architecture without REST, which includes the underlying architecture using WebSockets and the database-driven architecture . In this post, I will continue the journey to make a serverless application architecture using Firebase and AppRun . You will see how easy it is to use AppRun's event system with the Firebase stack to develop applications that have the full business logic process capabilities, such as authentication, authorization, request logging, and real-time database, and without REST layer. Finally, we can make the application a serverless deployment to Firebase. The Architecture \u00b6 The example application uses the following technologies: Firebase Cloud Firestore as the backend database Firebase Cloud Functions for business logic process Firebase Hosting to host the frontend Firebase Authentication Firebase is Google's mobile platform that helps you quickly develop high-quality apps and grow your business. I will focus on the architecture instead of step-by-step instructions. If you are not familiar with the Firebase suite of products, please search google for the tutorials. The architecture can be summarized in the diagram below. Figure 1. Architecture Diagram Let's get into the details. Event Pub-Sub Using FireStore \u00b6 The center of the architecture is the Firebase Cloud Firestore. Firestore is a real-time database that keeps your data in-sync across client apps. When one client saves the data, FireStore pushes the data to all other clients. In the AppRun applications, we use app.on to publish events. If we save the events to FireStore, the events can be handled by other applications. It is the step (1) shown in Figure 1 above. Firestore also triggers Cloud Functions. Business Logic Process Using Cloud Functions \u00b6 Cloud Functions is Google Cloud's serverless compute platform. It runs on the server, not in the client apps. Therefore it is the best technology for business logic processing, authentication, and authorization. Functions are serverless. Functions run on Google's server, so we don't need to provision, manage, or upgrade the server. The Functions are event-driven (the magic word, I love). Firestore can trigger Functions upon data updates. When we save the events into FireStore, FireStore triggers the Function to handle the events automatically. It is the step (2) in Figure 1. Real-Time Data Sync Using FireStore. \u00b6 During the Functions event handling, it writes the updated data back to FireStore (step (3) in Figure 1). FireStore pushes the update to the frontend applications (step (4) in Figure 1). The frontend application listens to FireStore changes and publishes AppRun events for the frontend logic process to run. Now, the event handling cycle is completed. Let's see it in action with an example. Example \u00b6 The example is a ToDo application. Figure 2. ToDo Application Save Events to FireStore \u00b6 As usual, in the AppRun applications, we convert the DOM events into AppRun events. E.g., When users click the add button, we publish the //: event. // in JSX < button $onclick = {[ add ]} > Add < /button> const add = () => { app . run ( '//:' , '@create-todo' , { title : ( document . getElementById ( 'new_todo' ). value , done : 0 }) } The //: event handler saves the event into FireStore. const db = firebase . firestore (); app . on ( '//:' , ( event , data = {}) => { db . collection ( `events` ). add ({ uid , event , data }) }); There is a top-level collection, called events in FireStore. We save the user id (obtained using Firebase anonymous authentication), event name (@create-todo), and event parameters (the new to-do item). FireStore triggers our Function, which is monitoring the events collection. Handle Events in Functions \u00b6 exports . updateTodo = functions . firestore . document ( 'events/{Id}' ) . onWrite (( change , context ) => { const dat = change . after . data () as any ; const { uid , event , data } = dat ; const db = admin . firestore (); const todos = db . collection ( '/users/' + uid + '/todos' ); switch ( event ) { case '@create-todo' : return todos . add ( data ); case '@update-todo' : ... case '@delete-todo' : ... case '@delete-all-todo' : ... default : return ; } }); The Function destructs the user id, event name, and event parameters and handles it accordingly, e.g., it adds a new Todo item data into FireStore upon the '@create-todo' event. And so on so forth. FireStore then pushes the data change to the frontend. Real-Time Data in Frontend \u00b6 In the frontend, we subscribe to the onSnapshot of FireStore and publish the AppRun event, '@show-all'. const db = firebase . firestore (); db . collection ( `users/ ${ uid } /todos` ). onSnapshot ( snapshot => { app . run ( '@show-all' , snapshot . docs . map ( d => ({ id : d . id , ... d . data () }))) }); Now, we are back to our AppRun application world, in which you can see the three familiar parts: state , view , and update . import app , { Component } from 'apprun' ; const state = { filter : 0 , todos : [] } const add = () => { app . run ( '//:' , '@create-todo' , { title : ( document . getElementById ( 'new_todo' ). value , done : 0 }) }; const toggle = ( _ , todo ) => { app . run ( '//:' , '@update-todo' , { ... todo , done : ! todo . done }) }; const remove = ( _ , todo ) => { app . run ( '//:' , '@delete-todo' , todo ) }; const clear = () => { app . run ( '//:' , '@delete-all-todo' ) }; const view = ({ todos }) => {...} const update = { '@show-all' : ( state , todos ) => ({ ... state , todos }) } The Firebase ToDo application shares the same architecture as in the Database-Driven Application Post . They are only different in events. The Firebase ToDo application saves the events to FireStore. The Database-Driven Application sends and receives the events through the WebSockets. If you are new to AppRun, read the AppRun Book or visit AppRun Docs . Live Demo and Source Code \u00b6 You can play with the live demo at https://apprun-demo.firebaseapp.com . Source Code: https://github.com/yysun/apprun-firebase Conclusion \u00b6 The AppRun event pub-sub pattern looks so simple (just app.run and app.on ), yet so powerful. It is not only useful inside the frontend app. It shines more in crossing process boundaries, such as in the cases of WebSockets , Web Workers , Electron Apps , Firebase of course, and more ...","title":"Serverless App Using Firebase"},{"location":"architecture-ideas/firebase-app/#introduction","text":"I have been writing about the application architecture without REST, which includes the underlying architecture using WebSockets and the database-driven architecture . In this post, I will continue the journey to make a serverless application architecture using Firebase and AppRun . You will see how easy it is to use AppRun's event system with the Firebase stack to develop applications that have the full business logic process capabilities, such as authentication, authorization, request logging, and real-time database, and without REST layer. Finally, we can make the application a serverless deployment to Firebase.","title":"Introduction"},{"location":"architecture-ideas/firebase-app/#the-architecture","text":"The example application uses the following technologies: Firebase Cloud Firestore as the backend database Firebase Cloud Functions for business logic process Firebase Hosting to host the frontend Firebase Authentication Firebase is Google's mobile platform that helps you quickly develop high-quality apps and grow your business. I will focus on the architecture instead of step-by-step instructions. If you are not familiar with the Firebase suite of products, please search google for the tutorials. The architecture can be summarized in the diagram below. Figure 1. Architecture Diagram Let's get into the details.","title":"The Architecture"},{"location":"architecture-ideas/firebase-app/#event-pub-sub-using-firestore","text":"The center of the architecture is the Firebase Cloud Firestore. Firestore is a real-time database that keeps your data in-sync across client apps. When one client saves the data, FireStore pushes the data to all other clients. In the AppRun applications, we use app.on to publish events. If we save the events to FireStore, the events can be handled by other applications. It is the step (1) shown in Figure 1 above. Firestore also triggers Cloud Functions.","title":"Event Pub-Sub Using FireStore"},{"location":"architecture-ideas/firebase-app/#business-logic-process-using-cloud-functions","text":"Cloud Functions is Google Cloud's serverless compute platform. It runs on the server, not in the client apps. Therefore it is the best technology for business logic processing, authentication, and authorization. Functions are serverless. Functions run on Google's server, so we don't need to provision, manage, or upgrade the server. The Functions are event-driven (the magic word, I love). Firestore can trigger Functions upon data updates. When we save the events into FireStore, FireStore triggers the Function to handle the events automatically. It is the step (2) in Figure 1.","title":"Business Logic Process Using Cloud Functions"},{"location":"architecture-ideas/firebase-app/#real-time-data-sync-using-firestore","text":"During the Functions event handling, it writes the updated data back to FireStore (step (3) in Figure 1). FireStore pushes the update to the frontend applications (step (4) in Figure 1). The frontend application listens to FireStore changes and publishes AppRun events for the frontend logic process to run. Now, the event handling cycle is completed. Let's see it in action with an example.","title":"Real-Time Data Sync Using FireStore."},{"location":"architecture-ideas/firebase-app/#example","text":"The example is a ToDo application. Figure 2. ToDo Application","title":"Example"},{"location":"architecture-ideas/firebase-app/#save-events-to-firestore","text":"As usual, in the AppRun applications, we convert the DOM events into AppRun events. E.g., When users click the add button, we publish the //: event. // in JSX < button $onclick = {[ add ]} > Add < /button> const add = () => { app . run ( '//:' , '@create-todo' , { title : ( document . getElementById ( 'new_todo' ). value , done : 0 }) } The //: event handler saves the event into FireStore. const db = firebase . firestore (); app . on ( '//:' , ( event , data = {}) => { db . collection ( `events` ). add ({ uid , event , data }) }); There is a top-level collection, called events in FireStore. We save the user id (obtained using Firebase anonymous authentication), event name (@create-todo), and event parameters (the new to-do item). FireStore triggers our Function, which is monitoring the events collection.","title":"Save Events to FireStore"},{"location":"architecture-ideas/firebase-app/#handle-events-in-functions","text":"exports . updateTodo = functions . firestore . document ( 'events/{Id}' ) . onWrite (( change , context ) => { const dat = change . after . data () as any ; const { uid , event , data } = dat ; const db = admin . firestore (); const todos = db . collection ( '/users/' + uid + '/todos' ); switch ( event ) { case '@create-todo' : return todos . add ( data ); case '@update-todo' : ... case '@delete-todo' : ... case '@delete-all-todo' : ... default : return ; } }); The Function destructs the user id, event name, and event parameters and handles it accordingly, e.g., it adds a new Todo item data into FireStore upon the '@create-todo' event. And so on so forth. FireStore then pushes the data change to the frontend.","title":"Handle Events in Functions"},{"location":"architecture-ideas/firebase-app/#real-time-data-in-frontend","text":"In the frontend, we subscribe to the onSnapshot of FireStore and publish the AppRun event, '@show-all'. const db = firebase . firestore (); db . collection ( `users/ ${ uid } /todos` ). onSnapshot ( snapshot => { app . run ( '@show-all' , snapshot . docs . map ( d => ({ id : d . id , ... d . data () }))) }); Now, we are back to our AppRun application world, in which you can see the three familiar parts: state , view , and update . import app , { Component } from 'apprun' ; const state = { filter : 0 , todos : [] } const add = () => { app . run ( '//:' , '@create-todo' , { title : ( document . getElementById ( 'new_todo' ). value , done : 0 }) }; const toggle = ( _ , todo ) => { app . run ( '//:' , '@update-todo' , { ... todo , done : ! todo . done }) }; const remove = ( _ , todo ) => { app . run ( '//:' , '@delete-todo' , todo ) }; const clear = () => { app . run ( '//:' , '@delete-all-todo' ) }; const view = ({ todos }) => {...} const update = { '@show-all' : ( state , todos ) => ({ ... state , todos }) } The Firebase ToDo application shares the same architecture as in the Database-Driven Application Post . They are only different in events. The Firebase ToDo application saves the events to FireStore. The Database-Driven Application sends and receives the events through the WebSockets. If you are new to AppRun, read the AppRun Book or visit AppRun Docs .","title":"Real-Time Data in Frontend"},{"location":"architecture-ideas/firebase-app/#live-demo-and-source-code","text":"You can play with the live demo at https://apprun-demo.firebaseapp.com . Source Code: https://github.com/yysun/apprun-firebase","title":"Live Demo and Source Code"},{"location":"architecture-ideas/firebase-app/#conclusion","text":"The AppRun event pub-sub pattern looks so simple (just app.run and app.on ), yet so powerful. It is not only useful inside the frontend app. It shines more in crossing process boundaries, such as in the cases of WebSockets , Web Workers , Electron Apps , Firebase of course, and more ...","title":"Conclusion"},{"location":"architecture-ideas/rust-app/","text":"Introduction \u00b6 WebAssembly has many different definitions on the Internet. I like the one from MDN the most, which says WebAssembly is a new binary assembly-like language that can run in the modern web browsers at near-native speed. There are many tools to compile code written in C/C++, Rust, Go, C#, etc. to be WebAssembly. It tells us that we can create high-performance code, but not using JavaScript/TypeScript I decided to play with Rust. Rust is another hot buzzword. It is a relatively new programming language focused on performance and safety, especially safe concurrency. -- Wikipedia This post describes how to create a WebAssembly package using Rust and use it in the AppRun applications from a JavaScript/TypeScript developer point of view. You will see the minimum steps of adding and using WebAssembly into your JavaScript/TypeScript project. Setup \u00b6 First, you will need the Rust toolchain, including rustup, rustc, and cargo for compiling Rust code, and wasm-pack for building, testing and publishing Rust-generated WebAssembly. Install Rust \u00b6 To install Rust on Mac/Linux, run the following command in the terminal. curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh On Windows, I enabled the Windows Subsystem for Linux and used Rust in the Linux terminal. Install wasm-pack \u00b6 Once installed Rust, run the following command in the terminal. cargo install wasm-pack Believe it or not, that's all you need to create WebAssembly. Let's go back to the JavaScript/TypeScript world. If you start from scratch, follow the next section to create an AppRun project. If you already have an existing project, jump to the section of Create WebAssembly Project. Create AppRun Project \u00b6 Run the commands to create an AppRun project: mkdir your-app-name cd your-app-name npx apprun -i Wait a few minutes for installing the npm packages, and then run the npm command: npm start You will see a hello world application running. AppRun Hello World Next, we will add WebAssembly to this project. Create WebAssembly Project \u00b6 Let's create a Rust project by running the following command: cargo new wasm --lib The command creates a folder called wasm and two files under the folder your-app-name/wasm : Cargo.toml and src/lib.rs . It is a regular Rust project, not a WebAssembly yet. You will need to add wasm-bindgen as the dependency to make it target WebAssembly. Open Cargo.toml and add the following sections. [lib] crate-type = [\"cdylib\"] [dependencies] wasm-bindgen = \"0.2.60\" js-sys = \"0.3.37\" wasm-bindgen is a Rust library that facilitates high-level interactions between wasm modules and JavaScript. js-sys is the waw bindings to JS global APIs for projects using wasm-bindgen. Now, you can use wasm-pack to build a WebAssembly. cd wasm wasm-pack build Use WebPack \u00b6 Since the AppRun project is a WebPack project, we can use the wasm-pack-plugin to unify the build process that creates the WebAssembly and JavaScript code at the same time. Go ahead to add the package: npm i @wasm-tool/wasm-pack-plugin -D And add the wasm-pack-plugin into the webpack.config.js . const WasmPackPlugin = require ( \"@wasm-tool/wasm-pack-plugin\" ); module . exports = { ... plugins : [ new WasmPackPlugin ({ crateDirectory : path . resolve ( __dirname , \".\" ) }), ] ... } Also, because the wasm-pack-plugin generates the dynamic import module, you need to modify tsconfig.json file to set the module to be esnext . { \"compilerOptions\" : { ... \"module\" : \"esnext\" , ... } } Finally, the npm scripts: npm start and npm run build will build the TypeScript code as well the Rust code. Let's write some Rust code. WebAssembly and AppRun \u00b6 We will demonstrate two interactions between the WebAssembly and the AppRun application. Call the WebAssembly from the AppRun application Call the AppRun application from the WebAssembly Call WebAssembly \u00b6 First, we create a Rust function in the wasm/src/lib.rs file. use wasm_bindgen :: prelude :: * ; #[wasm_bindgen] pub fn add ( a : i32 , b : i32 ) -> i32 { a + b } This function adds two numbers. We can make a counter application from it. Here is the counter application in AppRun. import app from 'apprun' ; let wasm ; import ( '../wasm/pkg' ). then ( module => wasm = module ); const state = { title : 'Hello world - AppRun !' , count : 0 } const add = ( state , num ) => ({ ... state , count : wasm . add ( state . count , num ) }); const view = ({ title , count }) => <> < h1 > { title } < /h1> < h1 > { count } < /h1> < button $onclick = {[ add , - 1 ]} >- 1 < /button> < button $onclick = {[ add , + 1 ]} >+ 1 < /button> < />; app . start ( document . body , state , view ); You can see from the code above: Wasm-pack has created a JavaScript module that we can import dynamically. We can call the WebAssembly function just like a regular JavaScript function from a module. Running the application, we have a counter that uses the WebAssembly function. Counter with WASM Next, let's see how does the WebAssembly function call AppRun functions. Call the AppRun \u00b6 Open wasm/src/lib.rs file and add the following functions. #[wasm_bindgen] extern \"C\" { #[wasm_bindgen(js_namespace = app)] fn run ( event : & str , p : & str ); } #[wasm_bindgen(start)] pub fn start () { run ( \"@hello\" , \"hello world from rust\" ); } The first function named run binds to the AppRun app.run function. The second function named start runs automatically when the WebAssembly is loaded. The start function calls the run function to send a '@hello' event to AppRun. Back to AppRun code, we will handle the '@hello' event. import app from 'apprun' ; let wasm ; import ( '../wasm/pkg' ). then ( module => wasm = module ); const state = {...} const add = ( state , num ) => ({...}); const view = ({ title , count }) => <> ... < />; const update = { '@hello' : ( state , title ) => ({... state , title }) } app . start ( document . body , state , view , update ); Now, when the application starts, it displays the messages sent from the WebAssembly. Message from wasm We have successfully made two-way interactions between the WebAssembly and the AppRun application. Souce Code \u00b6 You can run the live demo: https://yysun.github.io/apprun-rust . Or visit the source. {% github yysun/apprun-rust %} You also can use this project as an AppRun application template. Run the command to create your application. npx degit yysun/apprun-rust my-app Conclusion \u00b6 This post should give you a quick start to use Rust/WebAssembly in the AppRun applications. The demo project shows the two technologies interact with each other very well. You can use the demo project as a template. We have now opened the door to a new world. There is much more potential to explore.","title":"Webassembly app with Rust"},{"location":"architecture-ideas/rust-app/#introduction","text":"WebAssembly has many different definitions on the Internet. I like the one from MDN the most, which says WebAssembly is a new binary assembly-like language that can run in the modern web browsers at near-native speed. There are many tools to compile code written in C/C++, Rust, Go, C#, etc. to be WebAssembly. It tells us that we can create high-performance code, but not using JavaScript/TypeScript I decided to play with Rust. Rust is another hot buzzword. It is a relatively new programming language focused on performance and safety, especially safe concurrency. -- Wikipedia This post describes how to create a WebAssembly package using Rust and use it in the AppRun applications from a JavaScript/TypeScript developer point of view. You will see the minimum steps of adding and using WebAssembly into your JavaScript/TypeScript project.","title":"Introduction"},{"location":"architecture-ideas/rust-app/#setup","text":"First, you will need the Rust toolchain, including rustup, rustc, and cargo for compiling Rust code, and wasm-pack for building, testing and publishing Rust-generated WebAssembly.","title":"Setup"},{"location":"architecture-ideas/rust-app/#install-rust","text":"To install Rust on Mac/Linux, run the following command in the terminal. curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh On Windows, I enabled the Windows Subsystem for Linux and used Rust in the Linux terminal.","title":"Install Rust"},{"location":"architecture-ideas/rust-app/#install-wasm-pack","text":"Once installed Rust, run the following command in the terminal. cargo install wasm-pack Believe it or not, that's all you need to create WebAssembly. Let's go back to the JavaScript/TypeScript world. If you start from scratch, follow the next section to create an AppRun project. If you already have an existing project, jump to the section of Create WebAssembly Project.","title":"Install wasm-pack"},{"location":"architecture-ideas/rust-app/#create-apprun-project","text":"Run the commands to create an AppRun project: mkdir your-app-name cd your-app-name npx apprun -i Wait a few minutes for installing the npm packages, and then run the npm command: npm start You will see a hello world application running. AppRun Hello World Next, we will add WebAssembly to this project.","title":"Create AppRun Project"},{"location":"architecture-ideas/rust-app/#create-webassembly-project","text":"Let's create a Rust project by running the following command: cargo new wasm --lib The command creates a folder called wasm and two files under the folder your-app-name/wasm : Cargo.toml and src/lib.rs . It is a regular Rust project, not a WebAssembly yet. You will need to add wasm-bindgen as the dependency to make it target WebAssembly. Open Cargo.toml and add the following sections. [lib] crate-type = [\"cdylib\"] [dependencies] wasm-bindgen = \"0.2.60\" js-sys = \"0.3.37\" wasm-bindgen is a Rust library that facilitates high-level interactions between wasm modules and JavaScript. js-sys is the waw bindings to JS global APIs for projects using wasm-bindgen. Now, you can use wasm-pack to build a WebAssembly. cd wasm wasm-pack build","title":"Create WebAssembly Project"},{"location":"architecture-ideas/rust-app/#use-webpack","text":"Since the AppRun project is a WebPack project, we can use the wasm-pack-plugin to unify the build process that creates the WebAssembly and JavaScript code at the same time. Go ahead to add the package: npm i @wasm-tool/wasm-pack-plugin -D And add the wasm-pack-plugin into the webpack.config.js . const WasmPackPlugin = require ( \"@wasm-tool/wasm-pack-plugin\" ); module . exports = { ... plugins : [ new WasmPackPlugin ({ crateDirectory : path . resolve ( __dirname , \".\" ) }), ] ... } Also, because the wasm-pack-plugin generates the dynamic import module, you need to modify tsconfig.json file to set the module to be esnext . { \"compilerOptions\" : { ... \"module\" : \"esnext\" , ... } } Finally, the npm scripts: npm start and npm run build will build the TypeScript code as well the Rust code. Let's write some Rust code.","title":"Use WebPack"},{"location":"architecture-ideas/rust-app/#webassembly-and-apprun","text":"We will demonstrate two interactions between the WebAssembly and the AppRun application. Call the WebAssembly from the AppRun application Call the AppRun application from the WebAssembly","title":"WebAssembly and AppRun"},{"location":"architecture-ideas/rust-app/#call-webassembly","text":"First, we create a Rust function in the wasm/src/lib.rs file. use wasm_bindgen :: prelude :: * ; #[wasm_bindgen] pub fn add ( a : i32 , b : i32 ) -> i32 { a + b } This function adds two numbers. We can make a counter application from it. Here is the counter application in AppRun. import app from 'apprun' ; let wasm ; import ( '../wasm/pkg' ). then ( module => wasm = module ); const state = { title : 'Hello world - AppRun !' , count : 0 } const add = ( state , num ) => ({ ... state , count : wasm . add ( state . count , num ) }); const view = ({ title , count }) => <> < h1 > { title } < /h1> < h1 > { count } < /h1> < button $onclick = {[ add , - 1 ]} >- 1 < /button> < button $onclick = {[ add , + 1 ]} >+ 1 < /button> < />; app . start ( document . body , state , view ); You can see from the code above: Wasm-pack has created a JavaScript module that we can import dynamically. We can call the WebAssembly function just like a regular JavaScript function from a module. Running the application, we have a counter that uses the WebAssembly function. Counter with WASM Next, let's see how does the WebAssembly function call AppRun functions.","title":"Call WebAssembly"},{"location":"architecture-ideas/rust-app/#call-the-apprun","text":"Open wasm/src/lib.rs file and add the following functions. #[wasm_bindgen] extern \"C\" { #[wasm_bindgen(js_namespace = app)] fn run ( event : & str , p : & str ); } #[wasm_bindgen(start)] pub fn start () { run ( \"@hello\" , \"hello world from rust\" ); } The first function named run binds to the AppRun app.run function. The second function named start runs automatically when the WebAssembly is loaded. The start function calls the run function to send a '@hello' event to AppRun. Back to AppRun code, we will handle the '@hello' event. import app from 'apprun' ; let wasm ; import ( '../wasm/pkg' ). then ( module => wasm = module ); const state = {...} const add = ( state , num ) => ({...}); const view = ({ title , count }) => <> ... < />; const update = { '@hello' : ( state , title ) => ({... state , title }) } app . start ( document . body , state , view , update ); Now, when the application starts, it displays the messages sent from the WebAssembly. Message from wasm We have successfully made two-way interactions between the WebAssembly and the AppRun application.","title":"Call the AppRun"},{"location":"architecture-ideas/rust-app/#souce-code","text":"You can run the live demo: https://yysun.github.io/apprun-rust . Or visit the source. {% github yysun/apprun-rust %} You also can use this project as an AppRun application template. Run the command to create your application. npx degit yysun/apprun-rust my-app","title":"Souce Code"},{"location":"architecture-ideas/rust-app/#conclusion","text":"This post should give you a quick start to use Rust/WebAssembly in the AppRun applications. The demo project shows the two technologies interact with each other very well. You can use the demo project as a template. We have now opened the door to a new world. There is much more potential to explore.","title":"Conclusion"},{"location":"architecture-ideas/state-machine/","text":"Introduction \u00b6 The state machine is the tool that developers must have in their toolbox. If you are new to the state machine, check out the reference section below. How can a state machine help? Typically, when building applications, we follow what's known as the event-driven \u2014 where an event happens in the application, we update the application state and render the state to the screen. Events can happen anytime during user interactions and system interactions, while the application can be in any state. Therefore, before we start to handle the events, we first have to determine the current state and then handle the event accordingly. Sometimes it can be challenging. The state machine provides a state-event-state mapping. Thus, before we start to handle the events, we know the current state and the future state, so that we only need to focus on the limited state-event scope. The specific state machine we are going to use is the Mealy machine . It has an initial state and then transitions to new states based on events and its current state. We are going to build a calculator application as an example. You will learn from this post: Model a state machine declaratively, Make the state machine type-safe Add the state machine to the AppRun application Model a Calculator \u00b6 State and Event \u00b6 The calculator application looks like this: const find_transition = ( state_machine , state , event ) => { const current_state = state_machine [ state ]; if ( ! current_state ) throw new Error ( `No state: ${ current_state } found in state machine` ); const event_tuple = current_state . find ( s => s [ 0 ] === event ); return event_tuple ? { next_state : event_tuple [ 1 ], transition : event_tuple [ 2 ] } : {} }; const state = { _state : 'START' , display : '0' , arg1 : 0 , arg2 : 0 , op : '' , stack : [] }; const view = ({ _state , op , arg1 , arg2 , display , stack }) => <> < style > { ` .calculator { width: 200px; } .buttons { display: grid; grid-template-columns: repeat(4, 1fr); grid-gap: 2px; } button { padding: 10px; width:100%; } button:nth-of-type(1) { grid-column: span 2; } button:nth-of-type(16) { grid-column: span 2; } ` } < /style> < div class = \"calculator\" > < h1 > { display } < /h1> < div class = \"buttons\" $onclick = { button_click } > < button > CE < /button> < button >+ /-</button> < button > /</button> < button > 7 < /button> < button > 8 < /button> < button > 9 < /button> < button >*< /button> < button > 4 < /button> < button > 5 < /button> < button > 6 < /button> < button >-< /button> < button > 1 < /button> < button > 2 < /button> < button > 3 < /button> < button >+< /button> < button > 0 < /button> < button > . < /button> < button >=< /button> < /div> < small > { stack . length > 0 && ` ${ stack [ 0 ][ 0 ] } ${ stack [ 0 ][ 1 ] } ` } { _state . startsWith ( \"FIRST_\" ) && ` ${ display } ` } { _state === \"OP\" && ` ${ arg1 } ${ op } ` } { _state . startsWith ( \"SECOND_\" ) && ` ${ arg1 } ${ op } ${ display } ` } { _state === \"EQ\" && ` ${ arg1 } ${ op } ${ arg2 } = ${ display } ` } < /small> < /div> < />; const button_click = ( state , e ) => { const priority = { '*' : 2 , '/' : 2 , '+' : 1 , '-' : 1 } const getEvent = c => { switch ( c ) { case '+/-' : return '+/-' ; case 'CE' : return 'CE' ; case '.' : return 'DOT' ; case '=' : return 'EQ' ; default : return /\\d/ . test ( c ) ? 'NUM' : 'OP' ; } }; const key = e . target ? . textContent || e ; const event = getEvent ( key ); let { _state , op , arg1 , arg2 , display , stack } = state ; const clear = () => { display = '0' ; arg1 = arg2 = 0 ; op = '' ; stack . length = 0 ; } const negative = () => { display = display . startsWith ( '-' ) ? display . substring ( 1 ) : '-' + display ; }; const calc = () => { display = eval ( ` ${ arg1 }${ op }${ arg2 } ` ). toString (); }; const op1 = () => { op = key ; arg1 = parseFloat ( display ); }; const op2 = () => { if ( priority [ key ] === priority [ op ]) { arg2 = parseFloat ( display ); calc (); op = key ; arg1 = parseFloat ( display ); } else if ( priority [ key ] < priority [ op ]) { arg2 = parseFloat ( display ); calc (); arg1 = parseFloat ( display ); op = key ; if ( stack . length ) { const f = stack . pop (); arg1 = eval ( ` ${ f [ 0 ] }${ f [ 1 ] }${ display } ` ); display = arg1 . toString (); } } else { stack . push ([ arg1 , op ]); arg1 = parseFloat ( display ); op = key ; } }; const eq0 = () => { arg1 = parseFloat ( display ); calc (); }; const eq2 = () => { arg2 = parseFloat ( display ); calc (); if ( stack . length ) { arg2 = parseFloat ( display ); const f = stack . pop (); display = eval ( ` ${ f [ 0 ] }${ f [ 1 ] }${ display } ` ). toString (); arg1 = f [ 0 ]; op = f [ 1 ]; } }; const state_machine = { START : [ [ 'NUM' , 'FIRST_ARG' , () => display = key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display = '0.' ] ], FIRST_ARG : [ [ '+/-' , 'FIRST_ARG' , negative ], [ 'NUM' , 'FIRST_ARG' , () => display += key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display += key ], [ 'OP' , 'OP' , op1 ], [ 'CE' , 'START' , clear ] ], FIRST_ARG_FLOAT : [ [ '+/-' , 'FIRST_ARG_FLOAT' , negative ], [ 'NUM' , 'FIRST_ARG_FLOAT' , () => display += key ], [ 'OP' , 'OP' , op1 ], [ 'CE' , 'START' , clear ] ], OP : [ [ 'NUM' , 'SECOND_ARG' , () => display = key ], [ 'DOT' , 'SECOND_ARG' , () => display = '0.' ], [ 'OP' , 'OP' , () => op = key ], [ 'CE' , 'START' , clear ] ], SECOND_ARG : [ [ '+/-' , 'SECOND_ARG' , negative ], [ 'NUM' , 'SECOND_ARG' , () => display += key ], [ 'DOT' , 'SECOND_ARG_FLOAT' , () => display += key ], [ 'EQ' , 'EQ' , eq2 ], [ 'OP' , 'OP' , op2 ], [ 'CE' , 'OP' , () => display = '0' ] ], SECOND_ARG_FLOAT : [ [ '+/-' , 'SECOND_ARG_FLOAT' , negative ], [ 'NUM' , 'SECOND_ARG_FLOAT' , () => display += key ], [ 'EQ' , 'EQ' , eq2 ], [ 'OP' , 'OP' , op2 ], [ 'CE' , 'OP' , () => display = '0' ] ], EQ : [ [ '+/-' , 'FIRST_ARG' , negative ], [ 'NUM' , 'FIRST_ARG' , () => display = key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display = '0.' ], [ 'EQ' , 'EQ' , eq0 ], [ 'OP' , 'OP' , op1 ], [ 'CE' , 'START' , clear ] ] }; const { next_state , transition } = find_transition ( state_machine , _state , event ); _state = next_state || _state ; transition && transition (); return { _state , op , arg1 , arg2 , display , stack }; } app . start ( document . body , state , view ); Click the 'Try the Code' button; you will see the source code. The calculator has a grid of buttons that users can click at any time. It also displays: The numbers that the user typed and the calculation result on top of the grid. The calculation formula includes the first argument, the operator, and the second argument, and the calculation result below the gird. Let's model the initial state of the calculator. const state = { display : '0' , arg1 : 0 , arg2 : 0 , op : '' , }; We handle the buttons' click events in the event handler, button___click . Because of the HTML event bubbling, we only need one event handler for all the buttons. const view = < div class = \"buttons\" $onclick = { button_click } > ...... < /div> const button_click = ( state , e ) => { } app . start ( document . body , state , view ); That's all we need to do to create an AppRun application, an initial state , a view , and event handlers . Next, we will add the state machine implementation. State Machine \u00b6 We follow and extend the calculator state machine from David's post . The post also provides a diagram helpful to understand the state machine. We first define the states and events of the state machine using TypeScript Discriminated Unions . type Events = 'NUM' | 'OP' | 'DOT' | 'CE' | 'EQ' | '+/-' ; type States = 'START' | 'FIRST_ARG' | 'FIRST_ARG_FLOAT' | 'OP' | 'SECOND_ARG' | 'SECOND_ARG_FLOAT' | 'EQ' ; We then define the state machine. It is a collection of all the states . Each state has a list of available events and transitions in an array. The transition is the function to update the state . const state_machine = { START : [ [ 'NUM' , 'FIRST_ARG' , () => display = key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display = '0.' ] ], FIRST_ARG : [ [ '+/-' , 'FIRST_ARG' , negative ], [ 'NUM' , 'FIRST_ARG' , () => display += key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display += key ], [ 'OP' , 'OP' , op1 ], [ 'CE' , 'START' , clear ] ], ... } For example, when the current state is START, and the NUM event comes, the new state should be 'FIRST_ARG (waiting for 1st argument)'. The display property of the state should be the user's input. Another example, when the current state is FIRST_ARG, and the +/- event comes, the display property should toggle between positive and negative. So on and so forth. It is straightforward to create the state machine object according to the diagram. Next, we make the state machine type-safe by adding more types. export type Transition = () => void ; export type EventStateTransition < E , S > = [ E , S , Transition ]; export type StateMachine < S extends string , E > = { [ key in S ] : EventStateTransition < E , S > []; }; The Tansition is a function to update the application state. The EventStateTransition is a TypeScript Tuple . It describes which event leads to which new state. The StateMachine is an object that uses the _States as the index key. Now, the state machine is type-safe. The TypeScript compiler only allows you to use the states and events defined in States and Events . const state_machine : StateMachine < States , Events > = { START0 : [ // Error on START0 [ 'NUM0' , 'FIRST_ARG' , () => {}], // Error on NUM0 [ 'DOT' , 'FIRST_ARG_FLOAT0' , () => {}] // Error on FIRST_ARG_FLOAT0 ], } Also, the compiler makes sure all States have their relevant entries in the state machine. const state_machine : StateMachine < States , Events > = { START : [], FIRST_ARG : [], FIRST_ARG_FLOAT : [], OP : [], SECOND_ARG : [], SECOND_ARG_FLOAT : [], //EQ:[] // Error on missing EQ state, if we commented it out } You can see the state machine is just a simple data structure. Add State-Machine State \u00b6 We add a new property for tracking the state-machine state, called _state , into the initial state. const state = { _state : 'START' as States , display : '0' , arg1 : 0 , arg2 : 0 , op : '' , }; export type State = typeof state ; Convert UI Events \u00b6 All button clicks use the button___click event handler. We convert UI events into different state-machine events. export const button_click = ( state : State , e : any ) => { const getEvent = ( c : string ) : Events => { switch ( c ) { case '+/-' : return '+/-' ; case 'CE' : return 'CE' ; case '.' : return 'DOT' ; case '=' : return 'EQ' ; default : return / \\ d / . test ( c ) ? 'NUM' : 'OP' ; } }; const key = e . target ? . textContent || e ; const event = getEvent ( key ); } Use State Machine \u00b6 Now that we know the current state-machine state from the _state property of the application state. We also know which state-machine event we are in. We now can use the state___machine to find the matching transition . Finding transitions from the state___machine is straightforward. const find_transition = < S extends string , E > ( state_machine : StateMachine < S , E > , state : S , event : E ) : { next_state? : S , transition? : Transition } => { const current_state = state_machine [ state ]; if ( ! current_state ) throw new Error ( `No state: ${ current_state } found in state machine` ); const event_tuple = current_state . find ( s => s [ 0 ] === event ); return event_tuple ? { next_state : event_tuple [ 1 ], transition : event_tuple [ 2 ] } : {} }; If we found the transition , we run the transition function. It updates the destructed application state properties, such as op , arg1 , arg2 , and display accordingly. We then update the application state to be the next state . const button_click = ( state , e ) => { let { _state , op , arg1 , arg2 , display } = state ; const event = getEvent ( s ); const state_machine = { }; const { next_state , transition } = find_transition ( state_machine , _state , event ); transition && transition (); _state = next_state || _state ; return { _state , op , arg1 , arg2 , display }; } If no transition found, nothing will happen. Finally, we return a new state from the event handler; AppRun will render the screen accordingly. Now, we have successfully created the calculator application. You can see the calculator in TypeScript below. Source state machine export type Transition < T = any > = ( state? : T ) => void ; export type EventStateTransition < E , S > = [ E , S , Transition ]; export type StateMachine < S extends string , E > = { [ key in S ] : EventStateTransition < E , S > []; }; export const find_transition = < S extends string , E > ( state_machine : StateMachine < S , E > , state : S , event : E ) : { next_state? : S , transition? : Transition } => { const current_state = state_machine [ state ]; if ( ! current_state ) throw new Error ( `No state: ${ current_state } found in state machine` ); const event_tuple = current_state . find ( s => s [ 0 ] === event ); return event_tuple ? { next_state : event_tuple [ 1 ], transition : event_tuple [ 2 ] } : {} }; calculator app import app , { Component } from '../../src/apprun' ; import { StateMachine , find_transition } from './state-machine' ; type Events = 'NUM' | 'OP' | 'DOT' | 'CE' | 'EQ' | '+/-' ; type States = 'START' | 'FIRST_ARG' | 'FIRST_ARG_FLOAT' | 'OP' | 'SECOND_ARG' | 'SECOND_ARG_FLOAT' | 'EQ' ; const state = { _state : 'START' as States , display : '0' , arg1 : 0 , arg2 : 0 , op : '' , stack : [] }; export type State = typeof state ; const view = ({ _state , op , arg1 , arg2 , display , stack } : State ) => <> < style > { ` .calculator { width: 200px; } .buttons { display: grid; grid-template-columns: repeat(4, 1fr); grid-gap: 2px; } button { padding: 10px; width:100%; } button:nth-of-type(1) { grid-column: span 2; } button:nth-of-type(16) { grid-column: span 2; } ` } < /style> < div class = \"calculator\" > < h1 > { display } < /h1> < div class = \"buttons\" $onclick = { button_click } > < button > CE < /button> < button >+ /-</button> < button > /</button> < button > 7 < /button> < button > 8 < /button> < button > 9 < /button> < button >*< /button> < button > 4 < /button> < button > 5 < /button> < button > 6 < /button> < button >-< /button> < button > 1 < /button> < button > 2 < /button> < button > 3 < /button> < button >+< /button> < button > 0 < /button> < button > . < /button> < button >=< /button> < /div> < small > { stack . length > 0 && ` ${ stack [ 0 ][ 0 ] } ${ stack [ 0 ][ 1 ] } ` } { _state . startsWith ( \"FIRST_\" ) && ` ${ display } ` } { _state === \"OP\" && ` ${ arg1 } ${ op } ` } { _state . startsWith ( \"SECOND_\" ) && ` ${ arg1 } ${ op } ${ display } ` } { _state === \"EQ\" && ` ${ arg1 } ${ op } ${ arg2 } = ${ display } ` } < /small> < /div> < />; export const button_click = ( state : State , e : any ) => { const priority = { '*' : 2 , '/' : 2 , '+' : 1 , '-' : 1 } const getEvent = ( c : string ) : Events => { switch ( c ) { case '+/-' : return '+/-' ; case 'CE' : return 'CE' ; case '.' : return 'DOT' ; case '=' : return 'EQ' ; default : return / \\ d / . test ( c ) ? 'NUM' : 'OP' ; } }; const key = e . target ? . textContent || e ; const event = getEvent ( key ); let { _state , op , arg1 , arg2 , display , stack } = state ; const clear = () => { display = '0' ; arg1 = arg2 = 0 ; op = '' ; stack . length = 0 ; } const negative = () => { display = display . startsWith ( '-' ) ? display . substring ( 1 ) : '-' + display ; }; const calc = () => { display = eval ( ` ${ arg1 }${ op }${ arg2 } ` ). toString (); }; const op1 = () => { op = key ; arg1 = parseFloat ( display ); }; const op2 = () => { if ( priority [ key ] === priority [ op ]) { arg2 = parseFloat ( display ); calc (); op = key ; arg1 = parseFloat ( display ); } else if ( priority [ key ] < priority [ op ]) { arg2 = parseFloat ( display ); calc (); arg1 = parseFloat ( display ); op = key ; if ( stack . length ) { const f = stack . pop (); arg1 = eval ( ` ${ f [ 0 ] }${ f [ 1 ] }${ display } ` ); display = arg1 . toString (); } } else { stack . push ([ arg1 , op ]); arg1 = parseFloat ( display ); op = key ; } }; const eq0 = () => { arg1 = parseFloat ( display ); calc (); }; const eq2 = () => { arg2 = parseFloat ( display ); calc (); if ( stack . length ) { arg2 = parseFloat ( display ); const f = stack . pop (); display = eval ( ` ${ f [ 0 ] }${ f [ 1 ] }${ display } ` ). toString (); arg1 = f [ 0 ]; op = f [ 1 ]; } }; const state_machine : StateMachine < States , Events > = { START : [ [ 'NUM' , 'FIRST_ARG' , () => display = key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display = '0.' ] ], FIRST_ARG : [ [ '+/-' , 'FIRST_ARG' , negative ], [ 'NUM' , 'FIRST_ARG' , () => display += key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display += key ], [ 'OP' , 'OP' , op1 ], [ 'CE' , 'START' , clear ] ], FIRST_ARG_FLOAT : [ [ '+/-' , 'FIRST_ARG_FLOAT' , negative ], [ 'NUM' , 'FIRST_ARG_FLOAT' , () => display += key ], [ 'OP' , 'OP' , op1 ], [ 'CE' , 'START' , clear ] ], OP : [ [ 'NUM' , 'SECOND_ARG' , () => display = key ], [ 'DOT' , 'SECOND_ARG' , () => display = '0.' ], [ 'OP' , 'OP' , () => op = key ], [ 'CE' , 'START' , clear ] ], SECOND_ARG : [ [ '+/-' , 'SECOND_ARG' , negative ], [ 'NUM' , 'SECOND_ARG' , () => display += key ], [ 'DOT' , 'SECOND_ARG_FLOAT' , () => display += key ], [ 'EQ' , 'EQ' , eq2 ], [ 'OP' , 'OP' , op2 ], [ 'CE' , 'OP' , () => display = '0' ] ], SECOND_ARG_FLOAT : [ [ '+/-' , 'SECOND_ARG_FLOAT' , negative ], [ 'NUM' , 'SECOND_ARG_FLOAT' , () => display += key ], [ 'EQ' , 'EQ' , eq2 ], [ 'OP' , 'OP' , op2 ], [ 'CE' , 'OP' , () => display = '0' ] ], EQ : [ [ '+/-' , 'FIRST_ARG' , negative ], [ 'NUM' , 'FIRST_ARG' , () => display = key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display = '0.' ], [ 'EQ' , 'EQ' , eq0 ], [ 'OP' , 'OP' , op1 ], [ 'CE' , 'START' , clear ] ] }; const { next_state , transition } = find_transition ( state_machine , _state , event ); _state = next_state || _state ; transition && transition (); return { _state , op , arg1 , arg2 , display , stack }; }; const update = { '#calculator' : state => state }; export default element => new Component ( state , view , update ). mount ( element ); calculator specs import { button_click , State } from './calculator' ; const state : State = { _state : 'START' , display : '0' , arg1 : 0 , arg2 : 0 , op : '' , stack : [] }; const click = ( input : string ) => { const keys = [... input ]; let s = state ; keys . forEach ( key => { const new_state = button_click ( s , key ); s = new_state }) return s ; } describe ( 'calculator' , () => { it ( 'case 1' , () => { const { _state , display } = click ( '1' ); expect ( display ). toBe ( '1' ); expect ( _state ). toBe ( 'FIRST_ARG' ); }) it ( 'case 2' , () => { const { _state , display } = click ( '12' ); expect ( display ). toBe ( '12' ); expect ( _state ). toBe ( 'FIRST_ARG' ); }) it ( 'case 3' , () => { const { _state , display , arg1 , arg2 } = click ( '1+2=' ); expect ( display ). toBe ( '3' ); expect ( arg1 ). toBe ( 1 ); expect ( arg2 ). toBe ( 2 ); expect ( _state ). toBe ( 'EQ' ); }) it ( 'case 4' , () => { const { _state , display } = click ( '1/' ); expect ( display ). toBe ( '1' ); expect ( _state ). toBe ( 'OP' ); }) it ( 'case 5' , () => { const { _state , display } = click ( '1/2' ); expect ( display ). toBe ( '2' ); expect ( _state ). toBe ( 'SECOND_ARG' ); }) it ( 'case 6' , () => { const { _state , display , op } = click ( '1//' ); expect ( display ). toBe ( '1' ); expect ( op ). toBe ( '/' ); expect ( _state ). toBe ( 'OP' ); }) it ( 'case 7' , () => { const { _state , display , op } = click ( '1/=' ); expect ( display ). toBe ( '1' ); expect ( op ). toBe ( '/' ); expect ( _state ). toBe ( 'OP' ); }) it ( 'case 8' , () => { const { _state , display , op } = click ( '1/+' ); expect ( display ). toBe ( '1' ); expect ( op ). toBe ( '+' ); expect ( _state ). toBe ( 'OP' ); }) it ( 'case 9' , () => { const { _state , display } = click ( '1/10' ); expect ( display ). toBe ( '10' ); expect ( _state ). toBe ( 'SECOND_ARG' ); }) it ( 'case 10' , () => { const { _state , display } = click ( '1+1.' ); expect ( display ). toBe ( '1.' ); expect ( _state ). toBe ( 'SECOND_ARG_FLOAT' ); }) it ( 'case 11' , () => { const { _state , display } = click ( '0.' ); expect ( display ). toBe ( '0.' ); expect ( _state ). toBe ( 'FIRST_ARG_FLOAT' ); }) it ( 'case 12' , () => { const { _state , display } = click ( '=' ); expect ( display ). toBe ( '0' ); expect ( _state ). toBe ( 'START' ); }) it ( 'case 13' , () => { const { _state , display } = click ( '/' ); expect ( display ). toBe ( '0' ); expect ( _state ). toBe ( 'START' ); }) it ( 'case 14' , () => { const { _state , display } = click ( '1+2=5' ); expect ( display ). toBe ( '5' ); expect ( _state ). toBe ( 'FIRST_ARG' ); }) it ( 'case 15' , () => { const { _state , display } = click ( '1+2=/' ); expect ( display ). toBe ( '3' ); expect ( _state ). toBe ( 'OP' ); }) it ( 'case 16' , () => { const { _state , display } = click ( '1/+=' ); expect ( display ). toBe ( '1' ); expect ( _state ). toBe ( 'OP' ); }) it ( 'case 17' , () => { const { _state , display } = click ( '1+2=*3=' ); expect ( display ). toBe ( '9' ); expect ( _state ). toBe ( 'EQ' ); }) it ( 'case 18' , () => { const { _state , display , arg1 , arg2 } = click ( '1+2*3=' ); expect ( display ). toBe ( '7' ); expect ( arg1 ). toBe ( 1 ); expect ( arg2 ). toBe ( 6 ); expect ( _state ). toBe ( 'EQ' ); }) it ( 'case 19' , () => { const { _state , display , arg1 , arg2 } = click ( '1*2+3=' ); expect ( display ). toBe ( '5' ); expect ( arg1 ). toBe ( 2 ); expect ( arg2 ). toBe ( 3 ); expect ( _state ). toBe ( 'EQ' ); }) it ( 'case 20' , () => { const { _state , display } = click ( '1+2*3*' ); expect ( display ). toBe ( '6' ); expect ( _state ). toBe ( 'OP' ); }) }); Conclusion \u00b6 We have created a declarative and type-safe state machine. The state machine data structure is technology agnostic. You can try to use it in React or other frameworks you like. It can naturally fit into AppRun applications. AppRun is event-driven. Often I feel it is challenging to make events right. Sometimes we define too many events. Sometimes the events come out of order. By using the state machine, I can handle the events within limited state scopes. I have started to think of using more state machines to control the events. References \u00b6 There are many references online about the state machine. I got most of my inspiration from the following posts. I recommend you read the concept explanation of the posts and pay less attention to the implementations because using AppRun; you can do better. [1] Krasimir Tsonev explains Mealy and Moore in the post: The Rise Of The State Machines [2] Jon Bellah describes the paradigm shift from event-driven to the state machine in this post: A Complete Introduction to State Machines in JavaScript [3] Erik Mogensen explains state machine and introduced the statechart in this post: What is a state machine? Have fun coding!","title":"State Machine"},{"location":"architecture-ideas/state-machine/#introduction","text":"The state machine is the tool that developers must have in their toolbox. If you are new to the state machine, check out the reference section below. How can a state machine help? Typically, when building applications, we follow what's known as the event-driven \u2014 where an event happens in the application, we update the application state and render the state to the screen. Events can happen anytime during user interactions and system interactions, while the application can be in any state. Therefore, before we start to handle the events, we first have to determine the current state and then handle the event accordingly. Sometimes it can be challenging. The state machine provides a state-event-state mapping. Thus, before we start to handle the events, we know the current state and the future state, so that we only need to focus on the limited state-event scope. The specific state machine we are going to use is the Mealy machine . It has an initial state and then transitions to new states based on events and its current state. We are going to build a calculator application as an example. You will learn from this post: Model a state machine declaratively, Make the state machine type-safe Add the state machine to the AppRun application","title":"Introduction"},{"location":"architecture-ideas/state-machine/#model-a-calculator","text":"","title":"Model a Calculator"},{"location":"architecture-ideas/state-machine/#state-and-event","text":"The calculator application looks like this: const find_transition = ( state_machine , state , event ) => { const current_state = state_machine [ state ]; if ( ! current_state ) throw new Error ( `No state: ${ current_state } found in state machine` ); const event_tuple = current_state . find ( s => s [ 0 ] === event ); return event_tuple ? { next_state : event_tuple [ 1 ], transition : event_tuple [ 2 ] } : {} }; const state = { _state : 'START' , display : '0' , arg1 : 0 , arg2 : 0 , op : '' , stack : [] }; const view = ({ _state , op , arg1 , arg2 , display , stack }) => <> < style > { ` .calculator { width: 200px; } .buttons { display: grid; grid-template-columns: repeat(4, 1fr); grid-gap: 2px; } button { padding: 10px; width:100%; } button:nth-of-type(1) { grid-column: span 2; } button:nth-of-type(16) { grid-column: span 2; } ` } < /style> < div class = \"calculator\" > < h1 > { display } < /h1> < div class = \"buttons\" $onclick = { button_click } > < button > CE < /button> < button >+ /-</button> < button > /</button> < button > 7 < /button> < button > 8 < /button> < button > 9 < /button> < button >*< /button> < button > 4 < /button> < button > 5 < /button> < button > 6 < /button> < button >-< /button> < button > 1 < /button> < button > 2 < /button> < button > 3 < /button> < button >+< /button> < button > 0 < /button> < button > . < /button> < button >=< /button> < /div> < small > { stack . length > 0 && ` ${ stack [ 0 ][ 0 ] } ${ stack [ 0 ][ 1 ] } ` } { _state . startsWith ( \"FIRST_\" ) && ` ${ display } ` } { _state === \"OP\" && ` ${ arg1 } ${ op } ` } { _state . startsWith ( \"SECOND_\" ) && ` ${ arg1 } ${ op } ${ display } ` } { _state === \"EQ\" && ` ${ arg1 } ${ op } ${ arg2 } = ${ display } ` } < /small> < /div> < />; const button_click = ( state , e ) => { const priority = { '*' : 2 , '/' : 2 , '+' : 1 , '-' : 1 } const getEvent = c => { switch ( c ) { case '+/-' : return '+/-' ; case 'CE' : return 'CE' ; case '.' : return 'DOT' ; case '=' : return 'EQ' ; default : return /\\d/ . test ( c ) ? 'NUM' : 'OP' ; } }; const key = e . target ? . textContent || e ; const event = getEvent ( key ); let { _state , op , arg1 , arg2 , display , stack } = state ; const clear = () => { display = '0' ; arg1 = arg2 = 0 ; op = '' ; stack . length = 0 ; } const negative = () => { display = display . startsWith ( '-' ) ? display . substring ( 1 ) : '-' + display ; }; const calc = () => { display = eval ( ` ${ arg1 }${ op }${ arg2 } ` ). toString (); }; const op1 = () => { op = key ; arg1 = parseFloat ( display ); }; const op2 = () => { if ( priority [ key ] === priority [ op ]) { arg2 = parseFloat ( display ); calc (); op = key ; arg1 = parseFloat ( display ); } else if ( priority [ key ] < priority [ op ]) { arg2 = parseFloat ( display ); calc (); arg1 = parseFloat ( display ); op = key ; if ( stack . length ) { const f = stack . pop (); arg1 = eval ( ` ${ f [ 0 ] }${ f [ 1 ] }${ display } ` ); display = arg1 . toString (); } } else { stack . push ([ arg1 , op ]); arg1 = parseFloat ( display ); op = key ; } }; const eq0 = () => { arg1 = parseFloat ( display ); calc (); }; const eq2 = () => { arg2 = parseFloat ( display ); calc (); if ( stack . length ) { arg2 = parseFloat ( display ); const f = stack . pop (); display = eval ( ` ${ f [ 0 ] }${ f [ 1 ] }${ display } ` ). toString (); arg1 = f [ 0 ]; op = f [ 1 ]; } }; const state_machine = { START : [ [ 'NUM' , 'FIRST_ARG' , () => display = key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display = '0.' ] ], FIRST_ARG : [ [ '+/-' , 'FIRST_ARG' , negative ], [ 'NUM' , 'FIRST_ARG' , () => display += key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display += key ], [ 'OP' , 'OP' , op1 ], [ 'CE' , 'START' , clear ] ], FIRST_ARG_FLOAT : [ [ '+/-' , 'FIRST_ARG_FLOAT' , negative ], [ 'NUM' , 'FIRST_ARG_FLOAT' , () => display += key ], [ 'OP' , 'OP' , op1 ], [ 'CE' , 'START' , clear ] ], OP : [ [ 'NUM' , 'SECOND_ARG' , () => display = key ], [ 'DOT' , 'SECOND_ARG' , () => display = '0.' ], [ 'OP' , 'OP' , () => op = key ], [ 'CE' , 'START' , clear ] ], SECOND_ARG : [ [ '+/-' , 'SECOND_ARG' , negative ], [ 'NUM' , 'SECOND_ARG' , () => display += key ], [ 'DOT' , 'SECOND_ARG_FLOAT' , () => display += key ], [ 'EQ' , 'EQ' , eq2 ], [ 'OP' , 'OP' , op2 ], [ 'CE' , 'OP' , () => display = '0' ] ], SECOND_ARG_FLOAT : [ [ '+/-' , 'SECOND_ARG_FLOAT' , negative ], [ 'NUM' , 'SECOND_ARG_FLOAT' , () => display += key ], [ 'EQ' , 'EQ' , eq2 ], [ 'OP' , 'OP' , op2 ], [ 'CE' , 'OP' , () => display = '0' ] ], EQ : [ [ '+/-' , 'FIRST_ARG' , negative ], [ 'NUM' , 'FIRST_ARG' , () => display = key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display = '0.' ], [ 'EQ' , 'EQ' , eq0 ], [ 'OP' , 'OP' , op1 ], [ 'CE' , 'START' , clear ] ] }; const { next_state , transition } = find_transition ( state_machine , _state , event ); _state = next_state || _state ; transition && transition (); return { _state , op , arg1 , arg2 , display , stack }; } app . start ( document . body , state , view ); Click the 'Try the Code' button; you will see the source code. The calculator has a grid of buttons that users can click at any time. It also displays: The numbers that the user typed and the calculation result on top of the grid. The calculation formula includes the first argument, the operator, and the second argument, and the calculation result below the gird. Let's model the initial state of the calculator. const state = { display : '0' , arg1 : 0 , arg2 : 0 , op : '' , }; We handle the buttons' click events in the event handler, button___click . Because of the HTML event bubbling, we only need one event handler for all the buttons. const view = < div class = \"buttons\" $onclick = { button_click } > ...... < /div> const button_click = ( state , e ) => { } app . start ( document . body , state , view ); That's all we need to do to create an AppRun application, an initial state , a view , and event handlers . Next, we will add the state machine implementation.","title":"State and Event"},{"location":"architecture-ideas/state-machine/#state-machine","text":"We follow and extend the calculator state machine from David's post . The post also provides a diagram helpful to understand the state machine. We first define the states and events of the state machine using TypeScript Discriminated Unions . type Events = 'NUM' | 'OP' | 'DOT' | 'CE' | 'EQ' | '+/-' ; type States = 'START' | 'FIRST_ARG' | 'FIRST_ARG_FLOAT' | 'OP' | 'SECOND_ARG' | 'SECOND_ARG_FLOAT' | 'EQ' ; We then define the state machine. It is a collection of all the states . Each state has a list of available events and transitions in an array. The transition is the function to update the state . const state_machine = { START : [ [ 'NUM' , 'FIRST_ARG' , () => display = key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display = '0.' ] ], FIRST_ARG : [ [ '+/-' , 'FIRST_ARG' , negative ], [ 'NUM' , 'FIRST_ARG' , () => display += key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display += key ], [ 'OP' , 'OP' , op1 ], [ 'CE' , 'START' , clear ] ], ... } For example, when the current state is START, and the NUM event comes, the new state should be 'FIRST_ARG (waiting for 1st argument)'. The display property of the state should be the user's input. Another example, when the current state is FIRST_ARG, and the +/- event comes, the display property should toggle between positive and negative. So on and so forth. It is straightforward to create the state machine object according to the diagram. Next, we make the state machine type-safe by adding more types. export type Transition = () => void ; export type EventStateTransition < E , S > = [ E , S , Transition ]; export type StateMachine < S extends string , E > = { [ key in S ] : EventStateTransition < E , S > []; }; The Tansition is a function to update the application state. The EventStateTransition is a TypeScript Tuple . It describes which event leads to which new state. The StateMachine is an object that uses the _States as the index key. Now, the state machine is type-safe. The TypeScript compiler only allows you to use the states and events defined in States and Events . const state_machine : StateMachine < States , Events > = { START0 : [ // Error on START0 [ 'NUM0' , 'FIRST_ARG' , () => {}], // Error on NUM0 [ 'DOT' , 'FIRST_ARG_FLOAT0' , () => {}] // Error on FIRST_ARG_FLOAT0 ], } Also, the compiler makes sure all States have their relevant entries in the state machine. const state_machine : StateMachine < States , Events > = { START : [], FIRST_ARG : [], FIRST_ARG_FLOAT : [], OP : [], SECOND_ARG : [], SECOND_ARG_FLOAT : [], //EQ:[] // Error on missing EQ state, if we commented it out } You can see the state machine is just a simple data structure.","title":"State Machine"},{"location":"architecture-ideas/state-machine/#add-state-machine-state","text":"We add a new property for tracking the state-machine state, called _state , into the initial state. const state = { _state : 'START' as States , display : '0' , arg1 : 0 , arg2 : 0 , op : '' , }; export type State = typeof state ;","title":"Add State-Machine State"},{"location":"architecture-ideas/state-machine/#convert-ui-events","text":"All button clicks use the button___click event handler. We convert UI events into different state-machine events. export const button_click = ( state : State , e : any ) => { const getEvent = ( c : string ) : Events => { switch ( c ) { case '+/-' : return '+/-' ; case 'CE' : return 'CE' ; case '.' : return 'DOT' ; case '=' : return 'EQ' ; default : return / \\ d / . test ( c ) ? 'NUM' : 'OP' ; } }; const key = e . target ? . textContent || e ; const event = getEvent ( key ); }","title":"Convert UI Events"},{"location":"architecture-ideas/state-machine/#use-state-machine","text":"Now that we know the current state-machine state from the _state property of the application state. We also know which state-machine event we are in. We now can use the state___machine to find the matching transition . Finding transitions from the state___machine is straightforward. const find_transition = < S extends string , E > ( state_machine : StateMachine < S , E > , state : S , event : E ) : { next_state? : S , transition? : Transition } => { const current_state = state_machine [ state ]; if ( ! current_state ) throw new Error ( `No state: ${ current_state } found in state machine` ); const event_tuple = current_state . find ( s => s [ 0 ] === event ); return event_tuple ? { next_state : event_tuple [ 1 ], transition : event_tuple [ 2 ] } : {} }; If we found the transition , we run the transition function. It updates the destructed application state properties, such as op , arg1 , arg2 , and display accordingly. We then update the application state to be the next state . const button_click = ( state , e ) => { let { _state , op , arg1 , arg2 , display } = state ; const event = getEvent ( s ); const state_machine = { }; const { next_state , transition } = find_transition ( state_machine , _state , event ); transition && transition (); _state = next_state || _state ; return { _state , op , arg1 , arg2 , display }; } If no transition found, nothing will happen. Finally, we return a new state from the event handler; AppRun will render the screen accordingly. Now, we have successfully created the calculator application. You can see the calculator in TypeScript below. Source state machine export type Transition < T = any > = ( state? : T ) => void ; export type EventStateTransition < E , S > = [ E , S , Transition ]; export type StateMachine < S extends string , E > = { [ key in S ] : EventStateTransition < E , S > []; }; export const find_transition = < S extends string , E > ( state_machine : StateMachine < S , E > , state : S , event : E ) : { next_state? : S , transition? : Transition } => { const current_state = state_machine [ state ]; if ( ! current_state ) throw new Error ( `No state: ${ current_state } found in state machine` ); const event_tuple = current_state . find ( s => s [ 0 ] === event ); return event_tuple ? { next_state : event_tuple [ 1 ], transition : event_tuple [ 2 ] } : {} }; calculator app import app , { Component } from '../../src/apprun' ; import { StateMachine , find_transition } from './state-machine' ; type Events = 'NUM' | 'OP' | 'DOT' | 'CE' | 'EQ' | '+/-' ; type States = 'START' | 'FIRST_ARG' | 'FIRST_ARG_FLOAT' | 'OP' | 'SECOND_ARG' | 'SECOND_ARG_FLOAT' | 'EQ' ; const state = { _state : 'START' as States , display : '0' , arg1 : 0 , arg2 : 0 , op : '' , stack : [] }; export type State = typeof state ; const view = ({ _state , op , arg1 , arg2 , display , stack } : State ) => <> < style > { ` .calculator { width: 200px; } .buttons { display: grid; grid-template-columns: repeat(4, 1fr); grid-gap: 2px; } button { padding: 10px; width:100%; } button:nth-of-type(1) { grid-column: span 2; } button:nth-of-type(16) { grid-column: span 2; } ` } < /style> < div class = \"calculator\" > < h1 > { display } < /h1> < div class = \"buttons\" $onclick = { button_click } > < button > CE < /button> < button >+ /-</button> < button > /</button> < button > 7 < /button> < button > 8 < /button> < button > 9 < /button> < button >*< /button> < button > 4 < /button> < button > 5 < /button> < button > 6 < /button> < button >-< /button> < button > 1 < /button> < button > 2 < /button> < button > 3 < /button> < button >+< /button> < button > 0 < /button> < button > . < /button> < button >=< /button> < /div> < small > { stack . length > 0 && ` ${ stack [ 0 ][ 0 ] } ${ stack [ 0 ][ 1 ] } ` } { _state . startsWith ( \"FIRST_\" ) && ` ${ display } ` } { _state === \"OP\" && ` ${ arg1 } ${ op } ` } { _state . startsWith ( \"SECOND_\" ) && ` ${ arg1 } ${ op } ${ display } ` } { _state === \"EQ\" && ` ${ arg1 } ${ op } ${ arg2 } = ${ display } ` } < /small> < /div> < />; export const button_click = ( state : State , e : any ) => { const priority = { '*' : 2 , '/' : 2 , '+' : 1 , '-' : 1 } const getEvent = ( c : string ) : Events => { switch ( c ) { case '+/-' : return '+/-' ; case 'CE' : return 'CE' ; case '.' : return 'DOT' ; case '=' : return 'EQ' ; default : return / \\ d / . test ( c ) ? 'NUM' : 'OP' ; } }; const key = e . target ? . textContent || e ; const event = getEvent ( key ); let { _state , op , arg1 , arg2 , display , stack } = state ; const clear = () => { display = '0' ; arg1 = arg2 = 0 ; op = '' ; stack . length = 0 ; } const negative = () => { display = display . startsWith ( '-' ) ? display . substring ( 1 ) : '-' + display ; }; const calc = () => { display = eval ( ` ${ arg1 }${ op }${ arg2 } ` ). toString (); }; const op1 = () => { op = key ; arg1 = parseFloat ( display ); }; const op2 = () => { if ( priority [ key ] === priority [ op ]) { arg2 = parseFloat ( display ); calc (); op = key ; arg1 = parseFloat ( display ); } else if ( priority [ key ] < priority [ op ]) { arg2 = parseFloat ( display ); calc (); arg1 = parseFloat ( display ); op = key ; if ( stack . length ) { const f = stack . pop (); arg1 = eval ( ` ${ f [ 0 ] }${ f [ 1 ] }${ display } ` ); display = arg1 . toString (); } } else { stack . push ([ arg1 , op ]); arg1 = parseFloat ( display ); op = key ; } }; const eq0 = () => { arg1 = parseFloat ( display ); calc (); }; const eq2 = () => { arg2 = parseFloat ( display ); calc (); if ( stack . length ) { arg2 = parseFloat ( display ); const f = stack . pop (); display = eval ( ` ${ f [ 0 ] }${ f [ 1 ] }${ display } ` ). toString (); arg1 = f [ 0 ]; op = f [ 1 ]; } }; const state_machine : StateMachine < States , Events > = { START : [ [ 'NUM' , 'FIRST_ARG' , () => display = key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display = '0.' ] ], FIRST_ARG : [ [ '+/-' , 'FIRST_ARG' , negative ], [ 'NUM' , 'FIRST_ARG' , () => display += key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display += key ], [ 'OP' , 'OP' , op1 ], [ 'CE' , 'START' , clear ] ], FIRST_ARG_FLOAT : [ [ '+/-' , 'FIRST_ARG_FLOAT' , negative ], [ 'NUM' , 'FIRST_ARG_FLOAT' , () => display += key ], [ 'OP' , 'OP' , op1 ], [ 'CE' , 'START' , clear ] ], OP : [ [ 'NUM' , 'SECOND_ARG' , () => display = key ], [ 'DOT' , 'SECOND_ARG' , () => display = '0.' ], [ 'OP' , 'OP' , () => op = key ], [ 'CE' , 'START' , clear ] ], SECOND_ARG : [ [ '+/-' , 'SECOND_ARG' , negative ], [ 'NUM' , 'SECOND_ARG' , () => display += key ], [ 'DOT' , 'SECOND_ARG_FLOAT' , () => display += key ], [ 'EQ' , 'EQ' , eq2 ], [ 'OP' , 'OP' , op2 ], [ 'CE' , 'OP' , () => display = '0' ] ], SECOND_ARG_FLOAT : [ [ '+/-' , 'SECOND_ARG_FLOAT' , negative ], [ 'NUM' , 'SECOND_ARG_FLOAT' , () => display += key ], [ 'EQ' , 'EQ' , eq2 ], [ 'OP' , 'OP' , op2 ], [ 'CE' , 'OP' , () => display = '0' ] ], EQ : [ [ '+/-' , 'FIRST_ARG' , negative ], [ 'NUM' , 'FIRST_ARG' , () => display = key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display = '0.' ], [ 'EQ' , 'EQ' , eq0 ], [ 'OP' , 'OP' , op1 ], [ 'CE' , 'START' , clear ] ] }; const { next_state , transition } = find_transition ( state_machine , _state , event ); _state = next_state || _state ; transition && transition (); return { _state , op , arg1 , arg2 , display , stack }; }; const update = { '#calculator' : state => state }; export default element => new Component ( state , view , update ). mount ( element ); calculator specs import { button_click , State } from './calculator' ; const state : State = { _state : 'START' , display : '0' , arg1 : 0 , arg2 : 0 , op : '' , stack : [] }; const click = ( input : string ) => { const keys = [... input ]; let s = state ; keys . forEach ( key => { const new_state = button_click ( s , key ); s = new_state }) return s ; } describe ( 'calculator' , () => { it ( 'case 1' , () => { const { _state , display } = click ( '1' ); expect ( display ). toBe ( '1' ); expect ( _state ). toBe ( 'FIRST_ARG' ); }) it ( 'case 2' , () => { const { _state , display } = click ( '12' ); expect ( display ). toBe ( '12' ); expect ( _state ). toBe ( 'FIRST_ARG' ); }) it ( 'case 3' , () => { const { _state , display , arg1 , arg2 } = click ( '1+2=' ); expect ( display ). toBe ( '3' ); expect ( arg1 ). toBe ( 1 ); expect ( arg2 ). toBe ( 2 ); expect ( _state ). toBe ( 'EQ' ); }) it ( 'case 4' , () => { const { _state , display } = click ( '1/' ); expect ( display ). toBe ( '1' ); expect ( _state ). toBe ( 'OP' ); }) it ( 'case 5' , () => { const { _state , display } = click ( '1/2' ); expect ( display ). toBe ( '2' ); expect ( _state ). toBe ( 'SECOND_ARG' ); }) it ( 'case 6' , () => { const { _state , display , op } = click ( '1//' ); expect ( display ). toBe ( '1' ); expect ( op ). toBe ( '/' ); expect ( _state ). toBe ( 'OP' ); }) it ( 'case 7' , () => { const { _state , display , op } = click ( '1/=' ); expect ( display ). toBe ( '1' ); expect ( op ). toBe ( '/' ); expect ( _state ). toBe ( 'OP' ); }) it ( 'case 8' , () => { const { _state , display , op } = click ( '1/+' ); expect ( display ). toBe ( '1' ); expect ( op ). toBe ( '+' ); expect ( _state ). toBe ( 'OP' ); }) it ( 'case 9' , () => { const { _state , display } = click ( '1/10' ); expect ( display ). toBe ( '10' ); expect ( _state ). toBe ( 'SECOND_ARG' ); }) it ( 'case 10' , () => { const { _state , display } = click ( '1+1.' ); expect ( display ). toBe ( '1.' ); expect ( _state ). toBe ( 'SECOND_ARG_FLOAT' ); }) it ( 'case 11' , () => { const { _state , display } = click ( '0.' ); expect ( display ). toBe ( '0.' ); expect ( _state ). toBe ( 'FIRST_ARG_FLOAT' ); }) it ( 'case 12' , () => { const { _state , display } = click ( '=' ); expect ( display ). toBe ( '0' ); expect ( _state ). toBe ( 'START' ); }) it ( 'case 13' , () => { const { _state , display } = click ( '/' ); expect ( display ). toBe ( '0' ); expect ( _state ). toBe ( 'START' ); }) it ( 'case 14' , () => { const { _state , display } = click ( '1+2=5' ); expect ( display ). toBe ( '5' ); expect ( _state ). toBe ( 'FIRST_ARG' ); }) it ( 'case 15' , () => { const { _state , display } = click ( '1+2=/' ); expect ( display ). toBe ( '3' ); expect ( _state ). toBe ( 'OP' ); }) it ( 'case 16' , () => { const { _state , display } = click ( '1/+=' ); expect ( display ). toBe ( '1' ); expect ( _state ). toBe ( 'OP' ); }) it ( 'case 17' , () => { const { _state , display } = click ( '1+2=*3=' ); expect ( display ). toBe ( '9' ); expect ( _state ). toBe ( 'EQ' ); }) it ( 'case 18' , () => { const { _state , display , arg1 , arg2 } = click ( '1+2*3=' ); expect ( display ). toBe ( '7' ); expect ( arg1 ). toBe ( 1 ); expect ( arg2 ). toBe ( 6 ); expect ( _state ). toBe ( 'EQ' ); }) it ( 'case 19' , () => { const { _state , display , arg1 , arg2 } = click ( '1*2+3=' ); expect ( display ). toBe ( '5' ); expect ( arg1 ). toBe ( 2 ); expect ( arg2 ). toBe ( 3 ); expect ( _state ). toBe ( 'EQ' ); }) it ( 'case 20' , () => { const { _state , display } = click ( '1+2*3*' ); expect ( display ). toBe ( '6' ); expect ( _state ). toBe ( 'OP' ); }) });","title":"Use State Machine"},{"location":"architecture-ideas/state-machine/#conclusion","text":"We have created a declarative and type-safe state machine. The state machine data structure is technology agnostic. You can try to use it in React or other frameworks you like. It can naturally fit into AppRun applications. AppRun is event-driven. Often I feel it is challenging to make events right. Sometimes we define too many events. Sometimes the events come out of order. By using the state machine, I can handle the events within limited state scopes. I have started to think of using more state machines to control the events.","title":"Conclusion"},{"location":"architecture-ideas/state-machine/#references","text":"There are many references online about the state machine. I got most of my inspiration from the following posts. I recommend you read the concept explanation of the posts and pay less attention to the implementations because using AppRun; you can do better. [1] Krasimir Tsonev explains Mealy and Moore in the post: The Rise Of The State Machines [2] Jon Bellah describes the paradigm shift from event-driven to the state machine in this post: A Complete Introduction to State Machines in JavaScript [3] Erik Mogensen explains state machine and introduced the statechart in this post: What is a state machine? Have fun coding!","title":"References"}]}