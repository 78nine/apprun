{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to AppRun Docs \u00b6 Welcome to the AppRun user guide! This guide shows you how to get started creating web applications using AppRun . What is AppRun? \u00b6 AppRun is a JavaScript library for building applications. But, you may ask, there are many successful Javascript frameworks and libraries like Angular, React, Vue, and Svelte already; why AppRun? AppRun provides the elm inspired architecture and embraces the event-driven programming pattern, making AppRun different from other frameworks and libraries. AppRun has the following benefits overall. You can write quality code with less code You can use just standard JavaScript without learning proprietary syntax You can use AppRun in the browser as a small library (less than 6K gzipped) You can use AppRun with Typescript to make your codebase type-safe AppRun includes State management and routing AppRun makes Web Components development straightforward AppRun Works well with other libraries, such as jQuery, chart.js, D3, lit-html ... Is AppRun for me? \u00b6 If you are a beginner developer, you will learn how to build web applications with really good architecture quickly. Also, what you learned in AppRun will help you to understand other frameworks and libraries. If you are an experienced developer, you will learn AppRun is a lightweight alternative to other frameworks and libraries. As a result, you will have one more good tool in your toolbox to meet your clients' needs. Ready to try it yourself? Head over to Getting Started .","title":"Welcome to AppRun Docs"},{"location":"#welcome-to-apprun-docs","text":"Welcome to the AppRun user guide! This guide shows you how to get started creating web applications using AppRun .","title":"Welcome to AppRun Docs"},{"location":"#what-is-apprun","text":"AppRun is a JavaScript library for building applications. But, you may ask, there are many successful Javascript frameworks and libraries like Angular, React, Vue, and Svelte already; why AppRun? AppRun provides the elm inspired architecture and embraces the event-driven programming pattern, making AppRun different from other frameworks and libraries. AppRun has the following benefits overall. You can write quality code with less code You can use just standard JavaScript without learning proprietary syntax You can use AppRun in the browser as a small library (less than 6K gzipped) You can use AppRun with Typescript to make your codebase type-safe AppRun includes State management and routing AppRun makes Web Components development straightforward AppRun Works well with other libraries, such as jQuery, chart.js, D3, lit-html ...","title":"What is AppRun?"},{"location":"#is-apprun-for-me","text":"If you are a beginner developer, you will learn how to build web applications with really good architecture quickly. Also, what you learned in AppRun will help you to understand other frameworks and libraries. If you are an experienced developer, you will learn AppRun is a lightweight alternative to other frameworks and libraries. As a result, you will have one more good tool in your toolbox to meet your clients' needs. Ready to try it yourself? Head over to Getting Started .","title":"Is AppRun for me?"},{"location":"3rd-party-libs/","text":"3rd Party Libraries \u00b6 Using jQuery and jQuery plugins is not an anti-pattern. It is welcomed and encouraged. AppRun embraces 3rd libraries and recommends you to use them in your AppRun application development. AppRun was designed to support 3rd party libraries in mind. The AppRun VDOM is resilient to allow other libraries to change to DOM. The AppRun also has event life cycle callback functions to allow other libraries in AppRun applications. You can embed a DOM element into JSX or use the JSX ref attribute. Embed Element \u00b6 It is straightforward to create a DOM element and modify it using the 3rd party library. The DOM element can be embedded into JSX directly. e.g., the example of using chart.js below. The chart.js example above also demonstrates using the unload function to destroy the Chart object. export default class extends Component { state = { data : { /* ... */ } }; view = state => { const canvas = document . createElement ( 'canvas' ); const ctx = canvas . getContext ( '2d' ); state . chart = new Chart ( ctx , state . data ); return ( < Card header = \"Chart JS\" > { canvas } < /Card> ); }; unload = state => { state . chart ? . destroy (); console . log ( 'chart destroyed' ); } } Ref Attribute \u00b6 The JSX ref attribute is a call back function called when the specific DOM element is rendered. The DOM element can be any element in JSX. e.g., the d3 example below. The d3 example also demonstrates using the mounted function to initialize the state as a Promise . const map = ( element , features ) => { /*...*/ } export default class extends Component { state = {}; view = features => ( < Card header = { < div id = \"map-text\" > D3 Map < /div>}> < svg ref = { el => map ( el , features )} >< /svg> < /Card> ); mounted = () => new Promise (( resolve , reject ) => { d3 . json ( './world-110m.json' , ( error , topo ) => { if ( error ) throw reject ( error ); const features = topojson . feature ( topo , topo . objects . countries ) . features ; resolve ( features ); }); }); } Combing component life cycle events and embed DOM and the ref attribute provides a convenient way to use 3rd party libraries in the AppRun application. You can find out more from the following examples. Bootstrap Admin Dashboard \u00b6 The bootstrap admin dashboard uses Bootstrap layout. It also uses jQuery plugin DataTables and FullCalendar and chart.js and D3. CoreUI Admin Template \u00b6 Another example is using the CoreUI for AppRun application .","title":"3rd Party Intergration"},{"location":"3rd-party-libs/#3rd-party-libraries","text":"Using jQuery and jQuery plugins is not an anti-pattern. It is welcomed and encouraged. AppRun embraces 3rd libraries and recommends you to use them in your AppRun application development. AppRun was designed to support 3rd party libraries in mind. The AppRun VDOM is resilient to allow other libraries to change to DOM. The AppRun also has event life cycle callback functions to allow other libraries in AppRun applications. You can embed a DOM element into JSX or use the JSX ref attribute.","title":"3rd Party Libraries"},{"location":"3rd-party-libs/#embed-element","text":"It is straightforward to create a DOM element and modify it using the 3rd party library. The DOM element can be embedded into JSX directly. e.g., the example of using chart.js below. The chart.js example above also demonstrates using the unload function to destroy the Chart object. export default class extends Component { state = { data : { /* ... */ } }; view = state => { const canvas = document . createElement ( 'canvas' ); const ctx = canvas . getContext ( '2d' ); state . chart = new Chart ( ctx , state . data ); return ( < Card header = \"Chart JS\" > { canvas } < /Card> ); }; unload = state => { state . chart ? . destroy (); console . log ( 'chart destroyed' ); } }","title":"Embed Element"},{"location":"3rd-party-libs/#ref-attribute","text":"The JSX ref attribute is a call back function called when the specific DOM element is rendered. The DOM element can be any element in JSX. e.g., the d3 example below. The d3 example also demonstrates using the mounted function to initialize the state as a Promise . const map = ( element , features ) => { /*...*/ } export default class extends Component { state = {}; view = features => ( < Card header = { < div id = \"map-text\" > D3 Map < /div>}> < svg ref = { el => map ( el , features )} >< /svg> < /Card> ); mounted = () => new Promise (( resolve , reject ) => { d3 . json ( './world-110m.json' , ( error , topo ) => { if ( error ) throw reject ( error ); const features = topojson . feature ( topo , topo . objects . countries ) . features ; resolve ( features ); }); }); } Combing component life cycle events and embed DOM and the ref attribute provides a convenient way to use 3rd party libraries in the AppRun application. You can find out more from the following examples.","title":"Ref Attribute"},{"location":"3rd-party-libs/#bootstrap-admin-dashboard","text":"The bootstrap admin dashboard uses Bootstrap layout. It also uses jQuery plugin DataTables and FullCalendar and chart.js and D3.","title":"Bootstrap Admin Dashboard"},{"location":"3rd-party-libs/#coreui-admin-template","text":"Another example is using the CoreUI for AppRun application .","title":"CoreUI Admin Template"},{"location":"architecture/","text":"Architecture Overview \u00b6 Application logic is broken down into three separated parts in the AppRun architecture. State (a.k.a. Model) \u2014 the state of your application View \u2014 a function to display the state Update \u2014 a collection of event handlers to update the state Use a Counter as an example. const state = 0 ; const view = state => < div > < h1 > { state } < /h1> < button onclick = {()=> app . run ( '-1' )} >- 1 < /button> < button onclick = {()=> app . run ( '+1' )} >+ 1 < /button> < /div>; const update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; app . start ( document . body , state , view , update ); State \u00b6 The state can be any data structure, a number, an array, or an object that reflects the state of the application. In the Counter example, it is a number. const state = 0 ; Note You define the initial state. AppRun manages the state. Therefore the initial state is an immutable constant. View \u00b6 The view generates Virtual DOM based on the state. AppRun calculates the differences against the web page element and renders the changes. const view = state => < div > < h1 > $ { state } < /h1> < button $onclick = \"-1\" >- 1 < /button> < button $onclick = \"+1\" >+ 1 < /button> < /div>; Note AppRun allows you to choose your favorite virtual DOM technology in the view function. The example above uses JSX. You can also use lit-html, uhtml, and etc. Update \u00b6 The update is a collection of named event handlers, or a dictionary of event handlers. Each event handler creates a new state from the current state. const update = { '+1' : state => state + 1 , '-1' : state => state - 1 } Note There are a few other ways to define event handlers. When the three parts, the state , view , and update are provided to AppRun to start an application, AppRun registers the event handlers defined in the update and waits for AppRun events. app . start ( document . body , state , view , update );","title":"Overview"},{"location":"architecture/#architecture-overview","text":"Application logic is broken down into three separated parts in the AppRun architecture. State (a.k.a. Model) \u2014 the state of your application View \u2014 a function to display the state Update \u2014 a collection of event handlers to update the state Use a Counter as an example. const state = 0 ; const view = state => < div > < h1 > { state } < /h1> < button onclick = {()=> app . run ( '-1' )} >- 1 < /button> < button onclick = {()=> app . run ( '+1' )} >+ 1 < /button> < /div>; const update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; app . start ( document . body , state , view , update );","title":"Architecture Overview"},{"location":"architecture/#state","text":"The state can be any data structure, a number, an array, or an object that reflects the state of the application. In the Counter example, it is a number. const state = 0 ; Note You define the initial state. AppRun manages the state. Therefore the initial state is an immutable constant.","title":"State"},{"location":"architecture/#view","text":"The view generates Virtual DOM based on the state. AppRun calculates the differences against the web page element and renders the changes. const view = state => < div > < h1 > $ { state } < /h1> < button $onclick = \"-1\" >- 1 < /button> < button $onclick = \"+1\" >+ 1 < /button> < /div>; Note AppRun allows you to choose your favorite virtual DOM technology in the view function. The example above uses JSX. You can also use lit-html, uhtml, and etc.","title":"View"},{"location":"architecture/#update","text":"The update is a collection of named event handlers, or a dictionary of event handlers. Each event handler creates a new state from the current state. const update = { '+1' : state => state + 1 , '-1' : state => state - 1 } Note There are a few other ways to define event handlers. When the three parts, the state , view , and update are provided to AppRun to start an application, AppRun registers the event handlers defined in the update and waits for AppRun events. app . start ( document . body , state , view , update );","title":"Update"},{"location":"cli-in-console/","text":"AppRun CLI in Console \u00b6 We have been using the command-line interface (CLI) in the terminal window and the command prompt. Have you thought of a CLI in the console of the browser's developer tool? How does it work? \u00b6 In the console of the browser's developer tool (F12), you can type the command. _apprun `<command> [options]` Just like many other CLI, the help command lists all available commands. You can see three commands in the screenshot components , events and log . Why do we need a CLI in the console? \u00b6 CLI in the console is convenient for watching runtime data. For example, during application development, we often need to debug and exam the internal data of the application. Using the console.log function is the easiest yet very powerful way to display the data because the console lets us drill down into the nested array and object structure. With a CLI in the console, The app codebase stays clear of console.log . The CLI provides a non-destructive way of watching the runtime data. We can include the CLI script in the development environment and remove it from the production environment. How is it made? \u00b6 It is relatively easy to create a CLI in the console than to create a dev-tool as the browser extension. It is based on the JavaScript tagged templates . We create the _apprun function in the window object. window [ '_apprun' ] = ( strings ) => { } The _apprun function is called when we type the AppRun commands in the console. The command and the command parameters are passed into the _apprun function as the function parameter strings , which we can parse and then invoke the command functions. window [ '_apprun' ] = ( strings ) => { const [ cmd , ... p ] = strings [ 0 ]. split ( ' ' ). filter ( c => !! c ); const command = window [ `_apprun- ${ cmd } ` ]; if ( command ) command [ 1 ](... p ); else window [ '_apprun-help' ][ 1 ](); } It has an extensive architecture. We create the AppRun commands in the window object. The AppRun command is a tuple that includes the description of the command and the implementation function of the command. E.g. the help command look like this: window [ '_apprun-help' ] = [ '' , () => { Object . keys ( window ). forEach ( cmd => { if ( cmd . startsWith ( '_apprun-' )) { cmd === '_apprun-help' ? console . log ( 'AppRun Commands:' ) : console . log ( `* ${ cmd . substring ( 8 ) } : ${ window [ cmd ][ 0 ] } ` ); } }); }]; The help command searches for the tuples stored in the window object and prints the description of other AppRun commands. That's all the infrastructure code we need to create CLI commands in the console. Let's see an example. Live Demo \u00b6 The AppRun CLI in the console is one of the developer tools includes in the AppRun library. You can visit the AppRun RealWorld Example App https://gothinkster.github.io/apprun-realworld-example-app to see the CLI in actions. The components command logs the DOM elements that have AppRun components The events command logs the event subscription of the app The log command logs the runtime events publication of the app The create-event-tests command creates unit tests for the app The create-state-tests command creates Jest snapshot tests for the app Conclusion \u00b6 Developers like CLI. CLI in the console is useful for getting runtime events and messages hard for the traditional CLI in the terminal. The AppRun CLI in the console even extended the CLI beyond watching the data to generate tests. Thus, it increases the development productivity for debugging and testing.","title":"CLI in Console"},{"location":"cli-in-console/#apprun-cli-in-console","text":"We have been using the command-line interface (CLI) in the terminal window and the command prompt. Have you thought of a CLI in the console of the browser's developer tool?","title":"AppRun CLI in Console"},{"location":"cli-in-console/#how-does-it-work","text":"In the console of the browser's developer tool (F12), you can type the command. _apprun `<command> [options]` Just like many other CLI, the help command lists all available commands. You can see three commands in the screenshot components , events and log .","title":"How does it work?"},{"location":"cli-in-console/#why-do-we-need-a-cli-in-the-console","text":"CLI in the console is convenient for watching runtime data. For example, during application development, we often need to debug and exam the internal data of the application. Using the console.log function is the easiest yet very powerful way to display the data because the console lets us drill down into the nested array and object structure. With a CLI in the console, The app codebase stays clear of console.log . The CLI provides a non-destructive way of watching the runtime data. We can include the CLI script in the development environment and remove it from the production environment.","title":"Why do we need a CLI in the console?"},{"location":"cli-in-console/#how-is-it-made","text":"It is relatively easy to create a CLI in the console than to create a dev-tool as the browser extension. It is based on the JavaScript tagged templates . We create the _apprun function in the window object. window [ '_apprun' ] = ( strings ) => { } The _apprun function is called when we type the AppRun commands in the console. The command and the command parameters are passed into the _apprun function as the function parameter strings , which we can parse and then invoke the command functions. window [ '_apprun' ] = ( strings ) => { const [ cmd , ... p ] = strings [ 0 ]. split ( ' ' ). filter ( c => !! c ); const command = window [ `_apprun- ${ cmd } ` ]; if ( command ) command [ 1 ](... p ); else window [ '_apprun-help' ][ 1 ](); } It has an extensive architecture. We create the AppRun commands in the window object. The AppRun command is a tuple that includes the description of the command and the implementation function of the command. E.g. the help command look like this: window [ '_apprun-help' ] = [ '' , () => { Object . keys ( window ). forEach ( cmd => { if ( cmd . startsWith ( '_apprun-' )) { cmd === '_apprun-help' ? console . log ( 'AppRun Commands:' ) : console . log ( `* ${ cmd . substring ( 8 ) } : ${ window [ cmd ][ 0 ] } ` ); } }); }]; The help command searches for the tuples stored in the window object and prints the description of other AppRun commands. That's all the infrastructure code we need to create CLI commands in the console. Let's see an example.","title":"How is it made?"},{"location":"cli-in-console/#live-demo","text":"The AppRun CLI in the console is one of the developer tools includes in the AppRun library. You can visit the AppRun RealWorld Example App https://gothinkster.github.io/apprun-realworld-example-app to see the CLI in actions. The components command logs the DOM elements that have AppRun components The events command logs the event subscription of the app The log command logs the runtime events publication of the app The create-event-tests command creates unit tests for the app The create-state-tests command creates Jest snapshot tests for the app","title":"Live Demo"},{"location":"cli-in-console/#conclusion","text":"Developers like CLI. CLI in the console is useful for getting runtime events and messages hard for the traditional CLI in the terminal. The AppRun CLI in the console even extended the CLI beyond watching the data to generate tests. Thus, it increases the development productivity for debugging and testing.","title":"Conclusion"},{"location":"cli/","text":"AppRun CLI \u00b6 You can use the AppRun CLI to create a TypeScript and webpack configured project for real-world application development. You will get a productive development environment in Visual Studio Code. TypeScript and WebPack \u00b6 npx apprun --init esbuild \u00b6 You can initialize a project that uses esbuild . npx apprun --init --esbuild Run and Build \u00b6 AppRun applications use the following convention. Use npm start to start the dev server Use npm test to run unit tests Use npm run build to build for production","title":"AppRun CLI"},{"location":"cli/#apprun-cli","text":"You can use the AppRun CLI to create a TypeScript and webpack configured project for real-world application development. You will get a productive development environment in Visual Studio Code.","title":"AppRun CLI"},{"location":"cli/#typescript-and-webpack","text":"npx apprun --init","title":"TypeScript and WebPack"},{"location":"cli/#esbuild","text":"You can initialize a project that uses esbuild . npx apprun --init --esbuild","title":"esbuild"},{"location":"cli/#run-and-build","text":"AppRun applications use the following convention. Use npm start to start the dev server Use npm test to run unit tests Use npm run build to build for production","title":"Run and Build"},{"location":"component/","text":"Component \u00b6 The component is a technique to decompose the large system into smaller, manageable, and reusable pieces. The component is the basic building block. Usually, a component is an autonomous and reusable module that encapsulates a set of data and functions. An AppRun component is a mini-application that has the elm architecture, which means inside a component, there are state , view , and update . Components provide a local scope. Render the Component \u00b6 To use the components, you can render it to an element. const element = document . getElementById ( 'my-app' ); app . render ( element , < Counter /> ); When rendering the component, AppRun creates a component instance and renders it to the element. Mount and Start \u00b6 Or you can create the component using the constructor and mount the component instance to an element or to an element ID . When the component is mounted to an element ID , It will render the element only when it exists. const element = document . getElementById ( 'my-app' ); new Counter (). mount ( element ); You can also pass the initial state in to the component's constructor directly: new Counter ( 100 ). mount ( element ); When the component is mounted, by default it won't display until the events come. It is useful in the single page application (SPA) scenario where you can mount all components at once. Each component is activated by the routing events. If you need the component to display the initial state, you can use the start function. new Counter (). start ( document . body ); // mount and display You can render, mount, or start the component to document.body . // app . render ( document . body , < Counter /> ); // new Counter (). mount ( document . body ); // new Counter (). start ( document . body ); Child Component \u00b6 Components can have child components. class Child extends Component { state = {} view = state => < div >< /div> update = {} } class Parent extends Component { state = {} view = state => < div > < Child /> < /div> update = {} } But, you are not forced into the nested component structure. Sometimes, mounting components are more flexible. Please read this post, Redux vs. The React Context API vs. AppRun . Component Events \u00b6 A Component provides a local scope for events. The update registers the local events in the component. The this.run function fires local events that can only be picked up inside the component. You can prefix the event name with #, / or @ to make it global. class Counter extends Component { update = { '+1' : state => state + 1 , // local event '#+1' : state => state + 1 , // global event } } The app.run fires the global events that can be picked up by all components. In addition to use the update for defining event handlers, you can also use the @on decoratot or the $on directive. Event Handler Decorator \u00b6 In the component class we can use the TypeScript to compile the @on decorators to create the event handlers without using the update object. import app , { Component , on } from 'apprun' ; class Counter extends Component { state = 0 ; view = state => <> < h1 > { state } < /h1> < button onclick = {()=> this . run ( '-1' )} >- 1 < /button> < button onclick = {()=> this . run ( '+1' )} >+ 1 < /button> < />; @ on ( '-1' ) decrease = state => state - 1 ; @ on ( '+1' ) increase = state => state + 1 ; } Event Directive \u00b6 We can also use the directive to simplify the event handling. import { app , Component } from 'apprun' ; class Counter extends Component { state = 0 ; view = state => < div > < h1 > { state } < /h1> < button $onclick = { state => state - 1 } >- 1 < /button> < button $onclick = { state => state + 1 } >+ 1 < /button> < /div>; } Life Cycle Functions \u00b6 Life Cycle Functions are call back functions that AppRun calls during the component life cycle. They are mounted , rendered , and unload . import { app , Component } from 'apprun' ; class MyApp extends Component { state = {}; view = state => < div >< /div>; update = {}; //life cycle functions mounted = ( props , children , state ) => state ; rendered = state => {}; unload = state => {}; } app . render ( document . body , < MyApp /> ); mounted \u00b6 The mounted function is called after the component instance is mounted to a DOM element. The mounted function can be used to set the initialize the state. mounted : ( props : any , children : any [], state : T ) => T | void ; Note: the mounted function is only called in the child component. class Child extends Component { state = {} // you can define the initial state view = state => < div >< /div> update = {} mounted = ( props , children ) => { ... state , ... props } // this will be called, you can merge props into the state } class Parent extends Component { state = {} // you can define the initial state view = state => < div > < Child /> < /div> update = {} mounted = () => { } // this will NOT be called when component is created using the constructor } new Parent (). start ( document . body ); rendered \u00b6 The rendered function is called after AppRun renders the result of the view function. The rendered function can be used to modify the DOM element using 3rd party libraries. rendered : ( state : T , props ?: any []) => void ; unload \u00b6 The _unload function is called when the DOM element that component is mounted to is removed or reused by other components. The _unload function can be used to clean by the resources created by the 3rd party libraries. unload : ( state : T ) => void ; You can see, the component life cycle functions are useful for integrating 3rd party libraries . Web Components \u00b6 You can convert AppRun components into web components/custom elements . AppRun components become the custom elements that also can handle AppRun events ( Online Demo ). < html > < head > < meta charset = \"utf-8\" > < title > Counter as web component </ title > </ head > < body > < my-app id = 'counter' ></ my-app > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/custom-elements/1.1.2/custom-elements.min.js\" ></ script > < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" ></ script > < script > class Counter extends Component { constructor () { super (); this . state = 0 ; this . view = state => `<div> <h1> ${ state } </h1> <button onclick='counter.run(\"-1\")'>-1</button> <button onclick='counter.run(\"+1\")'>+1</button> </div>` ; this . update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; } } app . webComponent ( 'my-app' , Counter ); </ script > </ body > </ html > We have started to mention JSX. Next, you will learn about the view patterns of using JSX to create a rich user interface.","title":"Component"},{"location":"component/#component","text":"The component is a technique to decompose the large system into smaller, manageable, and reusable pieces. The component is the basic building block. Usually, a component is an autonomous and reusable module that encapsulates a set of data and functions. An AppRun component is a mini-application that has the elm architecture, which means inside a component, there are state , view , and update . Components provide a local scope.","title":"Component"},{"location":"component/#render-the-component","text":"To use the components, you can render it to an element. const element = document . getElementById ( 'my-app' ); app . render ( element , < Counter /> ); When rendering the component, AppRun creates a component instance and renders it to the element.","title":"Render the Component"},{"location":"component/#mount-and-start","text":"Or you can create the component using the constructor and mount the component instance to an element or to an element ID . When the component is mounted to an element ID , It will render the element only when it exists. const element = document . getElementById ( 'my-app' ); new Counter (). mount ( element ); You can also pass the initial state in to the component's constructor directly: new Counter ( 100 ). mount ( element ); When the component is mounted, by default it won't display until the events come. It is useful in the single page application (SPA) scenario where you can mount all components at once. Each component is activated by the routing events. If you need the component to display the initial state, you can use the start function. new Counter (). start ( document . body ); // mount and display You can render, mount, or start the component to document.body . // app . render ( document . body , < Counter /> ); // new Counter (). mount ( document . body ); // new Counter (). start ( document . body );","title":"Mount and Start"},{"location":"component/#child-component","text":"Components can have child components. class Child extends Component { state = {} view = state => < div >< /div> update = {} } class Parent extends Component { state = {} view = state => < div > < Child /> < /div> update = {} } But, you are not forced into the nested component structure. Sometimes, mounting components are more flexible. Please read this post, Redux vs. The React Context API vs. AppRun .","title":"Child Component"},{"location":"component/#component-events","text":"A Component provides a local scope for events. The update registers the local events in the component. The this.run function fires local events that can only be picked up inside the component. You can prefix the event name with #, / or @ to make it global. class Counter extends Component { update = { '+1' : state => state + 1 , // local event '#+1' : state => state + 1 , // global event } } The app.run fires the global events that can be picked up by all components. In addition to use the update for defining event handlers, you can also use the @on decoratot or the $on directive.","title":"Component Events"},{"location":"component/#event-handler-decorator","text":"In the component class we can use the TypeScript to compile the @on decorators to create the event handlers without using the update object. import app , { Component , on } from 'apprun' ; class Counter extends Component { state = 0 ; view = state => <> < h1 > { state } < /h1> < button onclick = {()=> this . run ( '-1' )} >- 1 < /button> < button onclick = {()=> this . run ( '+1' )} >+ 1 < /button> < />; @ on ( '-1' ) decrease = state => state - 1 ; @ on ( '+1' ) increase = state => state + 1 ; }","title":"Event Handler Decorator"},{"location":"component/#event-directive","text":"We can also use the directive to simplify the event handling. import { app , Component } from 'apprun' ; class Counter extends Component { state = 0 ; view = state => < div > < h1 > { state } < /h1> < button $onclick = { state => state - 1 } >- 1 < /button> < button $onclick = { state => state + 1 } >+ 1 < /button> < /div>; }","title":"Event Directive"},{"location":"component/#life-cycle-functions","text":"Life Cycle Functions are call back functions that AppRun calls during the component life cycle. They are mounted , rendered , and unload . import { app , Component } from 'apprun' ; class MyApp extends Component { state = {}; view = state => < div >< /div>; update = {}; //life cycle functions mounted = ( props , children , state ) => state ; rendered = state => {}; unload = state => {}; } app . render ( document . body , < MyApp /> );","title":"Life Cycle Functions"},{"location":"component/#mounted","text":"The mounted function is called after the component instance is mounted to a DOM element. The mounted function can be used to set the initialize the state. mounted : ( props : any , children : any [], state : T ) => T | void ; Note: the mounted function is only called in the child component. class Child extends Component { state = {} // you can define the initial state view = state => < div >< /div> update = {} mounted = ( props , children ) => { ... state , ... props } // this will be called, you can merge props into the state } class Parent extends Component { state = {} // you can define the initial state view = state => < div > < Child /> < /div> update = {} mounted = () => { } // this will NOT be called when component is created using the constructor } new Parent (). start ( document . body );","title":"mounted"},{"location":"component/#rendered","text":"The rendered function is called after AppRun renders the result of the view function. The rendered function can be used to modify the DOM element using 3rd party libraries. rendered : ( state : T , props ?: any []) => void ;","title":"rendered"},{"location":"component/#unload","text":"The _unload function is called when the DOM element that component is mounted to is removed or reused by other components. The _unload function can be used to clean by the resources created by the 3rd party libraries. unload : ( state : T ) => void ; You can see, the component life cycle functions are useful for integrating 3rd party libraries .","title":"unload"},{"location":"component/#web-components","text":"You can convert AppRun components into web components/custom elements . AppRun components become the custom elements that also can handle AppRun events ( Online Demo ). < html > < head > < meta charset = \"utf-8\" > < title > Counter as web component </ title > </ head > < body > < my-app id = 'counter' ></ my-app > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/custom-elements/1.1.2/custom-elements.min.js\" ></ script > < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" ></ script > < script > class Counter extends Component { constructor () { super (); this . state = 0 ; this . view = state => `<div> <h1> ${ state } </h1> <button onclick='counter.run(\"-1\")'>-1</button> <button onclick='counter.run(\"+1\")'>+1</button> </div>` ; this . update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; } } app . webComponent ( 'my-app' , Counter ); </ script > </ body > </ html > We have started to mention JSX. Next, you will learn about the view patterns of using JSX to create a rich user interface.","title":"Web Components"},{"location":"dev-server/","text":"Introduction \u00b6 We use the JavaScript modules (ESM) extensively while coding nowadays. But we still cannot deploy the module-based code yet. It is because the browsers don't know how to handle global modules. E.g., When developing applications using AppRun , we need a globe module of apprun . import app from 'apprun' The browsers don't know how to import apprun . Therefore, We still need to use JavaScript bundlers such as webpack, rollup, or parcel to bundle the modules. But at least now, we can use the modules to speed up the development process. Recently, the Snowpack team introduced the concept of Unbundled Development , which is to leverage modules for speeding up the development process. In the past, I was thinking of building a tool to convert the global modules to the modules links on unpkg after compilation. The npm package CDN , unpkg.com supports delivering modules for along time. We can load apprun as a module from unpkg . import app from 'https://unpkg.com/apprun?module' Now, it seems that a development server is a different and better idea. So, I forked the live-server and made a development server for AppRun. This post is to introduce the AppRun development server, called apprun-dev-server . apprun-dev-server \u00b6 This is a static web server for developing JavaScript/TypeScript using ES modules following the concept of Unbundled Development . It serves the ES Modules from unpkg.com. Based on live-server , so it reloads the page automatically Also, it detects AppRun and can replace the module/Component while keeping the application state . The best part of the apprun-dev-server is that it does NOT require any code in our components to handle the hot module replacement. It retains the component state; replaces the module; and then puts the state back. All done automatically. If you want to refresh the state, you can reload the page in the browser by pressing F5 (on Windows) or Command+R (on Mac). How to Use \u00b6 You export Component as the default module export. import { app , Component } from 'apprun' ; export default class AboutComponent extends Component { state = 'About' ; view = state => < div > < h1 > { state } < /h1> < /div>; update = { '#About' : state => state , }; } Then, you use the Component in the main file. import About from './About' ; new About (). start ( 'my-app' ); Then, you use a module-type script tag in HTML. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > AppRun SPA </ title > </ head > < body > < script type = \"module\" src = \"/dist/main.js\" ></ script > </ body > </ html > Turn on the compiler, TypeScript, or Babel in watch mode. And then, start the apprun-dev-server using npx. npx apprun-dev-server Apprun-dev-server monitors the file changes. If the changed JavaScript files (*.js) file have global modules. Apprun-dev-server replaces the global module's references to unpkg . In the server console, if you see the file names that have some dots '......' in front, they are the files modified. Apprun-dev-server injects JavaScript code snippets in the index.html just like live-server. Also, Apprun-dev-server adds logic to detect AppRun and replace AppRun components. You can download an example app to give it a try. npx degit yysun/apprun-esm-server my-app Configuration \u00b6 Create a apprun-dev-server.config.js in your project: module . exports = { port : 8181 , // Set the server port. Defaults to 8080. host : \"0.0.0.0\" , // Set the address to bind to. Defaults to 0.0.0.0 or process.env.IP. root : \"public\" , // Set root directory that's being served. Defaults to cwd. open : false , // When false, it won't load your browser by default. ignore : '' , // comma-separated string for paths to ignore file : \"index.html\" , // When set, serve this file (server root relative) for every 404 (useful for single-page applications) wait : 1000 , // Waits for all changes, before reloading. Defaults to 0 sec. mount : [], // Mount a directory to a route. logLevel : 2 , // } Use with esbuild \u00b6 Give it a try and send pull requests. https://github.com/yysun/apprun-dev-server","title":"Dev Server"},{"location":"dev-server/#introduction","text":"We use the JavaScript modules (ESM) extensively while coding nowadays. But we still cannot deploy the module-based code yet. It is because the browsers don't know how to handle global modules. E.g., When developing applications using AppRun , we need a globe module of apprun . import app from 'apprun' The browsers don't know how to import apprun . Therefore, We still need to use JavaScript bundlers such as webpack, rollup, or parcel to bundle the modules. But at least now, we can use the modules to speed up the development process. Recently, the Snowpack team introduced the concept of Unbundled Development , which is to leverage modules for speeding up the development process. In the past, I was thinking of building a tool to convert the global modules to the modules links on unpkg after compilation. The npm package CDN , unpkg.com supports delivering modules for along time. We can load apprun as a module from unpkg . import app from 'https://unpkg.com/apprun?module' Now, it seems that a development server is a different and better idea. So, I forked the live-server and made a development server for AppRun. This post is to introduce the AppRun development server, called apprun-dev-server .","title":"Introduction"},{"location":"dev-server/#apprun-dev-server","text":"This is a static web server for developing JavaScript/TypeScript using ES modules following the concept of Unbundled Development . It serves the ES Modules from unpkg.com. Based on live-server , so it reloads the page automatically Also, it detects AppRun and can replace the module/Component while keeping the application state . The best part of the apprun-dev-server is that it does NOT require any code in our components to handle the hot module replacement. It retains the component state; replaces the module; and then puts the state back. All done automatically. If you want to refresh the state, you can reload the page in the browser by pressing F5 (on Windows) or Command+R (on Mac).","title":"apprun-dev-server"},{"location":"dev-server/#how-to-use","text":"You export Component as the default module export. import { app , Component } from 'apprun' ; export default class AboutComponent extends Component { state = 'About' ; view = state => < div > < h1 > { state } < /h1> < /div>; update = { '#About' : state => state , }; } Then, you use the Component in the main file. import About from './About' ; new About (). start ( 'my-app' ); Then, you use a module-type script tag in HTML. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > AppRun SPA </ title > </ head > < body > < script type = \"module\" src = \"/dist/main.js\" ></ script > </ body > </ html > Turn on the compiler, TypeScript, or Babel in watch mode. And then, start the apprun-dev-server using npx. npx apprun-dev-server Apprun-dev-server monitors the file changes. If the changed JavaScript files (*.js) file have global modules. Apprun-dev-server replaces the global module's references to unpkg . In the server console, if you see the file names that have some dots '......' in front, they are the files modified. Apprun-dev-server injects JavaScript code snippets in the index.html just like live-server. Also, Apprun-dev-server adds logic to detect AppRun and replace AppRun components. You can download an example app to give it a try. npx degit yysun/apprun-esm-server my-app","title":"How to Use"},{"location":"dev-server/#configuration","text":"Create a apprun-dev-server.config.js in your project: module . exports = { port : 8181 , // Set the server port. Defaults to 8080. host : \"0.0.0.0\" , // Set the address to bind to. Defaults to 0.0.0.0 or process.env.IP. root : \"public\" , // Set root directory that's being served. Defaults to cwd. open : false , // When false, it won't load your browser by default. ignore : '' , // comma-separated string for paths to ignore file : \"index.html\" , // When set, serve this file (server root relative) for every 404 (useful for single-page applications) wait : 1000 , // Waits for all changes, before reloading. Defaults to 0 sec. mount : [], // Mount a directory to a route. logLevel : 2 , // }","title":"Configuration"},{"location":"dev-server/#use-with-esbuild","text":"Give it a try and send pull requests. https://github.com/yysun/apprun-dev-server","title":"Use with esbuild"},{"location":"directive/","text":"Directives \u00b6 AppRun directives are syntax sugars that help simplify the code. They are custom attributes in JSX that have names starting with $. AppRun two out of the box directives: $on and $bind. $on... \u00b6 The $on directive simplifies the code to convert the DOM events to AppRun events. Convert Events \u00b6 class Counter extends Component { state = 0 ; view = state => <> < h1 > { state } < /h1> < button $onclick = '-1' >- 1 < /button> < button $onclick = '+1' >+ 1 < /button> < />; update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; } Invoke Functions \u00b6 The $on directive can also invoke functions. class Counter extends Component { state = 0 ; view = state => < div > < h1 > { state } < /h1> < button $onclick = { state => state - 1 } >- 1 < /button> < button $onclick = { state => state + 1 } >+ 1 < /button> < /div>; } You can see more $on example from the AppRun playground . $bind \u00b6 The $bind directive synchronizes the HTML input value to the state . You can see the $bind example from the AppRun playground . Custom directive \u00b6 When AppRun is processing the JSX code, it publishes the $ event when it finds the custom attributes named like $X. You can subscribe to the $ event to provide your directives. E.g., if you create the $animation directive to attach the animation classes from the animation library, animation.css . app . on ( '$' , ({ key , props }) => { if ( key === '$animation' ) { const value = props [ key ]; if ( typeof value === 'string' ) { props . class = \\ `animated \\ ${ value } \\`; } } }); You can see the $animation example from the AppRun playground .","title":"Directive"},{"location":"directive/#directives","text":"AppRun directives are syntax sugars that help simplify the code. They are custom attributes in JSX that have names starting with $. AppRun two out of the box directives: $on and $bind.","title":"Directives"},{"location":"directive/#on","text":"The $on directive simplifies the code to convert the DOM events to AppRun events.","title":"$on..."},{"location":"directive/#convert-events","text":"class Counter extends Component { state = 0 ; view = state => <> < h1 > { state } < /h1> < button $onclick = '-1' >- 1 < /button> < button $onclick = '+1' >+ 1 < /button> < />; update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; }","title":"Convert Events"},{"location":"directive/#invoke-functions","text":"The $on directive can also invoke functions. class Counter extends Component { state = 0 ; view = state => < div > < h1 > { state } < /h1> < button $onclick = { state => state - 1 } >- 1 < /button> < button $onclick = { state => state + 1 } >+ 1 < /button> < /div>; } You can see more $on example from the AppRun playground .","title":"Invoke Functions"},{"location":"directive/#bind","text":"The $bind directive synchronizes the HTML input value to the state . You can see the $bind example from the AppRun playground .","title":"$bind"},{"location":"directive/#custom-directive","text":"When AppRun is processing the JSX code, it publishes the $ event when it finds the custom attributes named like $X. You can subscribe to the $ event to provide your directives. E.g., if you create the $animation directive to attach the animation classes from the animation library, animation.css . app . on ( '$' , ({ key , props }) => { if ( key === '$animation' ) { const value = props [ key ]; if ( typeof value === 'string' ) { props . class = \\ `animated \\ ${ value } \\`; } } }); You can see the $animation example from the AppRun playground .","title":"Custom directive"},{"location":"event-pubsub/","text":"Event Pub-Sub \u00b6 Event publication and subscription, also known as event emitter, is a commonly used pattern in JavaScript programming. Publishing an event means raising an event for some other code to handle. Publishing an event is also referred to as firing an event or triggering an event. Subscribing an event means registering an event handler function to the event. The event handler function executes when the correspondent event. At the core, AppRun is an event pub-sub system. Event Life Cycle \u00b6 When an AppRun event is published, the following steps take place: AppRun dispatches the events to the event handlers defined in the update along with the current state . The event handlers create a new state based on the current state . AppRun passes the new state to the view function. The view function creates HTML or a Virtual DOM. AppRun renders the HTML/Virtual DOM to the screen AppRun calls the optional rendered function to complete the AppRun event life cycle. AppRun Event Life Cycle connects the state , view , and update (event handlers) together. Take a look at the Counter example again. import app from 'apprun' ; const state = 0 ; const view = state => { return `<div> <h1> ${ state } </h1> <button onclick='app.run(\"-1\")'>-1</button> <button onclick='app.run(\"+1\")'>+1</button> </div>` ; }; const update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; app . start ( 'my-app' , state , view , update ); When one of the buttons is clicked, it publishes AppRun event +1 or -1. The event handlers increase or decreases the state and return a new state. The view function creates the virtual DOM using the new state. Finally, AppRun renders the virtual DOM. Asynchronous Events \u00b6 In the service/API oriented applications, the state is created by changed by the asynchronous operations. e.g., getting remote data from the server. It is easy to handle asynchronous operations in the AppRun event handlers. We only need to add the async keyword in front of the event handler and call the functions that return a Promise object with the await keyword. import app from 'apprun' ; const get = async ( url ) => { }; const state = {}; const view = ( state ) => < div > { state } < /div>; const update = { '#' : async ( state ) => { try { const data = await get ( 'https://...' ); return { ... state , data } } catch ( err ) { return { ... state , err } } } }; app . start ( 'my-app' , state , view , update ); Use Events for Everything \u00b6 Web programming is event-driven. All we have to do is to convert DOM events to AppRun events to trigger the AppRun event life cycle. DOM events => AppRun Events => (current state) => Update => (new state) => View => (HTML/Virtual DOM) => Render Web Page Events are not only used for handling user interactions. They are used for everything in AppRun. Routing is through event. Directive is through event. Event Types \u00b6 Events can be strongly typed using TypeScript Discriminated Unions. If you are interested, please read this post: Strong Typing in AppRun . Event Scope \u00b6 So far, the AppRun events we see are global events, which means that the events are published and handled globally by all modules. Sometime, you may want to limit the events to a certain scope. You then can use components .","title":"Event Pubsub"},{"location":"event-pubsub/#event-pub-sub","text":"Event publication and subscription, also known as event emitter, is a commonly used pattern in JavaScript programming. Publishing an event means raising an event for some other code to handle. Publishing an event is also referred to as firing an event or triggering an event. Subscribing an event means registering an event handler function to the event. The event handler function executes when the correspondent event. At the core, AppRun is an event pub-sub system.","title":"Event Pub-Sub"},{"location":"event-pubsub/#event-life-cycle","text":"When an AppRun event is published, the following steps take place: AppRun dispatches the events to the event handlers defined in the update along with the current state . The event handlers create a new state based on the current state . AppRun passes the new state to the view function. The view function creates HTML or a Virtual DOM. AppRun renders the HTML/Virtual DOM to the screen AppRun calls the optional rendered function to complete the AppRun event life cycle. AppRun Event Life Cycle connects the state , view , and update (event handlers) together. Take a look at the Counter example again. import app from 'apprun' ; const state = 0 ; const view = state => { return `<div> <h1> ${ state } </h1> <button onclick='app.run(\"-1\")'>-1</button> <button onclick='app.run(\"+1\")'>+1</button> </div>` ; }; const update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; app . start ( 'my-app' , state , view , update ); When one of the buttons is clicked, it publishes AppRun event +1 or -1. The event handlers increase or decreases the state and return a new state. The view function creates the virtual DOM using the new state. Finally, AppRun renders the virtual DOM.","title":"Event Life Cycle"},{"location":"event-pubsub/#asynchronous-events","text":"In the service/API oriented applications, the state is created by changed by the asynchronous operations. e.g., getting remote data from the server. It is easy to handle asynchronous operations in the AppRun event handlers. We only need to add the async keyword in front of the event handler and call the functions that return a Promise object with the await keyword. import app from 'apprun' ; const get = async ( url ) => { }; const state = {}; const view = ( state ) => < div > { state } < /div>; const update = { '#' : async ( state ) => { try { const data = await get ( 'https://...' ); return { ... state , data } } catch ( err ) { return { ... state , err } } } }; app . start ( 'my-app' , state , view , update );","title":"Asynchronous Events"},{"location":"event-pubsub/#use-events-for-everything","text":"Web programming is event-driven. All we have to do is to convert DOM events to AppRun events to trigger the AppRun event life cycle. DOM events => AppRun Events => (current state) => Update => (new state) => View => (HTML/Virtual DOM) => Render Web Page Events are not only used for handling user interactions. They are used for everything in AppRun. Routing is through event. Directive is through event.","title":"Use Events for Everything"},{"location":"event-pubsub/#event-types","text":"Events can be strongly typed using TypeScript Discriminated Unions. If you are interested, please read this post: Strong Typing in AppRun .","title":"Event Types"},{"location":"event-pubsub/#event-scope","text":"So far, the AppRun events we see are global events, which means that the events are published and handled globally by all modules. Sometime, you may want to limit the events to a certain scope. You then can use components .","title":"Event Scope"},{"location":"html/","text":"HTML \u00b6 AppRun supports creating the HTML string from the view function. Sometimes it may be easy for quick prototyping. const view = state => `<div> <h1> ${ state } </h1> <button onclick=\"app.run('-1')\">-1</button> <button onclick=\"app.run('+1')\">+1</button> </div>` ; Although HTML string is easy to understand and helpful in trying out ideas, it takes time to parse it into virtual DOM at run time, which may cause performance issues. You can use alternative rendering technologies such as: lit-html \u00b5html Use lit-html \u00b6 lit-html lets you write HTML templates in JavaScript with template literals. lit-HTML templates are plain JavaScript. lit-html takes care of rendering templates to DOM, including efficiently updating the DOM with new values. Below is the Counter code of using lit-html in the browser . <!DOCTYPE html> < html lang = \"en\" > < head > < title > Hello! </ title > < meta charset = \"utf-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1\" > </ head > < body > < script type = \"module\" > import app from 'https://unpkg.com/apprun?module' ; import { render , html } from 'https://unpkg.com/lit-html?module' ; app . render = ( e , vdom ) => render ( vdom , e ); class Counter extends Component { state = 0 ; view = ( state ) => html `<div> <h1> ${ state } </h1> <button @click= ${ ()=> this . run ( \"add\" , - 1 ) } >-1</button> <button @click= ${ ()=> this . run ( \"add\" , + 1 ) } >+1</button> </div>` ; update = [ [ 'add' , ( state , n ) => state + n ] ] } new Counter (). start ( document . body ); </ script > </ body > </ html > Use \u00b5html \u00b6 \u00b5html (micro html) is a ~2.5K lighterhtml subset to build declarative and reactive UI via template literals tags. < html lang = \"en\" > < head > < title > AppRun App </ title > </ head > < body > < script type = \"module\" > import app from 'https://unpkg.com/apprun?module' ; import { render , html } from 'https://unpkg.com/uhtml?module' ; app . render = render ; class Counter extends Component { state = 0 ; view = ( state ) => html `<div> <h1> ${ state } </h1> <button onclick= ${ () => this . run ( \"add\" , - 1 ) } >-1</button> <button onclick= ${ () => this . run ( \"add\" , + 1 ) } >+1</button> </div>` ; update = [ [ 'add' , ( state , n ) => state + n ] ] } new Counter (). start ( document . body ); </ script > </ body > </ html > Child Components \u00b6 Unlike JSX, you can embed component class into JSX; when using HTML string components, you will need to make a web component/custom element. Then you can embed the components. import app from 'apprun' ; import MyComponent from './MyComponent' ; app . webComponent ( 'my-component' , MyComponent ); const view = state => { return `<div> <my-component /> </div>` ; }; app . start ( 'my-app' , state , view );","title":"HTML"},{"location":"html/#html","text":"AppRun supports creating the HTML string from the view function. Sometimes it may be easy for quick prototyping. const view = state => `<div> <h1> ${ state } </h1> <button onclick=\"app.run('-1')\">-1</button> <button onclick=\"app.run('+1')\">+1</button> </div>` ; Although HTML string is easy to understand and helpful in trying out ideas, it takes time to parse it into virtual DOM at run time, which may cause performance issues. You can use alternative rendering technologies such as: lit-html \u00b5html","title":"HTML"},{"location":"html/#use-lit-html","text":"lit-html lets you write HTML templates in JavaScript with template literals. lit-HTML templates are plain JavaScript. lit-html takes care of rendering templates to DOM, including efficiently updating the DOM with new values. Below is the Counter code of using lit-html in the browser . <!DOCTYPE html> < html lang = \"en\" > < head > < title > Hello! </ title > < meta charset = \"utf-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1\" > </ head > < body > < script type = \"module\" > import app from 'https://unpkg.com/apprun?module' ; import { render , html } from 'https://unpkg.com/lit-html?module' ; app . render = ( e , vdom ) => render ( vdom , e ); class Counter extends Component { state = 0 ; view = ( state ) => html `<div> <h1> ${ state } </h1> <button @click= ${ ()=> this . run ( \"add\" , - 1 ) } >-1</button> <button @click= ${ ()=> this . run ( \"add\" , + 1 ) } >+1</button> </div>` ; update = [ [ 'add' , ( state , n ) => state + n ] ] } new Counter (). start ( document . body ); </ script > </ body > </ html >","title":"Use lit-html"},{"location":"html/#use-html","text":"\u00b5html (micro html) is a ~2.5K lighterhtml subset to build declarative and reactive UI via template literals tags. < html lang = \"en\" > < head > < title > AppRun App </ title > </ head > < body > < script type = \"module\" > import app from 'https://unpkg.com/apprun?module' ; import { render , html } from 'https://unpkg.com/uhtml?module' ; app . render = render ; class Counter extends Component { state = 0 ; view = ( state ) => html `<div> <h1> ${ state } </h1> <button onclick= ${ () => this . run ( \"add\" , - 1 ) } >-1</button> <button onclick= ${ () => this . run ( \"add\" , + 1 ) } >+1</button> </div>` ; update = [ [ 'add' , ( state , n ) => state + n ] ] } new Counter (). start ( document . body ); </ script > </ body > </ html >","title":"Use \u00b5html"},{"location":"html/#child-components","text":"Unlike JSX, you can embed component class into JSX; when using HTML string components, you will need to make a web component/custom element. Then you can embed the components. import app from 'apprun' ; import MyComponent from './MyComponent' ; app . webComponent ( 'my-component' , MyComponent ); const view = state => { return `<div> <my-component /> </div>` ; }; app . start ( 'my-app' , state , view );","title":"Child Components"},{"location":"installation/","text":"Getting Started \u00b6 This guide describes how to get up and running with AppRun in minutes AppRun Concepts If you are looking for an introductory overview of AppRun technology, it is recommended to visit the concepts section. Installation \u00b6 AppRun is distributed on npm. npm install apprun You can also load AppRun directly from the unpkg.com CDN: < script src = \"https://unpkg.com/apprun\" >< /script> Or when you need HTML or lit-HTML: < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" >< /script> Use in Browser \u00b6 Use CDN \u00b6 < html lang = \"en\" > < head > < title > AppRun App </ title > < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" ></ script > </ head > < body > < script > const view = state => `<div> ${ state } </div>` ; app . start ( document . body , 'hello world' , view ); </ script > </ body > </ html > Use ES Module \u00b6 < html lang = \"en\" > < head > < title > AppRun App </ title > </ head > < body > < script type = \"module\" > import { app } from 'https://unpkg.com/apprun/esm/apprun-html?module' ; const view = state => `<div> ${ state } </div>` ; app . start ( document . body , 'hello ESM' , view ); </ script > </ body > </ html > Use lit-html \u00b6 lit-html is an efficient, expressive, extensible HTML templating library for JavaScript from the Polumer project. AppRun has included lit-html. < html lang = \"en\" > < head > < title > AppRun App </ title > </ head > < body > < script type = \"module\" > import { app } from 'https://unpkg.com/apprun/esm/apprun-html?module' const view = state => html `<div> ${ state } </div>` ; app . start ( document . body , 'hello lit-html' , view ); </ script > </ body > </ html > Use \u00b5html \u00b6 \u00b5html (micro html) is a ~2.5K lighterhtml subset to build declarative and reactive UI via template literals tags. AppRun allows you to use different rendering technology like \u00b5html. < html lang = \"en\" > < head > < title > AppRun App </ title > </ head > < body > < script type = \"module\" > import app from 'https://unpkg.com/apprun?module' ; import { render , html } from 'https://unpkg.com/uhtml?module' ; app . render = render ; const view = state => html `<div> ${ state } </div>` ; app . start ( document . body , 'hello uhtml' , view ); </ script > </ body > </ html > Use JSX \u00b6 JSX is a syntax exntension to JavaScript. It makes JavaScript functions look like HTML. You can use JSX in the browser or compile JSX ahead of time. See AppRun CLI below. < html lang = \"en\" > < head > < title > AppRun App </ title > < script src = \"https://unpkg.com/@babel/standalone/babel.min.js\" ></ script > < script src = \"https://unpkg.com/apprun\" ></ script > </ head > < body > < script type = \"text/babel\" data-presets = \"es2017, react\" > const view = state => < div > { state } < /div>; app . start ( document . body , 'hello JSX' , view ); </ script > </ body > </ html > Compile/Transpile and Bundle \u00b6 TypeScript and webpack \u00b6 AppRun includes a command-line tool (CLI) for creating a TypeScript and webpack configured project. npx apprun --init esbuild \u00b6 You can initialize a project that uses esbuild . npx apprun --init --esbuild After the command finishes execution, you can start the application and then navigate to https://localhost:8080 in a browser. npm start Starter Template \u00b6 Optionally, if not using the CLI you can directly scaffold AppRun project from the AppRun starter templates. npx degit apprunjs/apprun-esbuild my-app npx degit apprunjs/apprun-rollup my-app npx degit apprunjs/apprun-rollup-lit-html my-app npx degit apprunjs/apprun-webpack my-app npx degit apprunjs/apprun-parcel my-app npx degit apprunjs/apprun-web-components my-app npx degit apprunjs/apprun-bootstrap my-app npx degit apprunjs/apprun-coreui my-app npx degit apprunjs/apprun-pwa my-app npx degit apprunjs/apprun-pwa-workbox my-app npx degit yysun/apprun-d3 my-app npx degit yysun/apprun-electron my-app npx degit yysun/apprun-electron-forge my-app npx degit yysun/apprun-websockets my-app AppRun is so flexible that you can choose your favorite ways of using it. Next, you will see the quick-start tutorial on creating AppRun apps.","title":"Installation"},{"location":"installation/#getting-started","text":"This guide describes how to get up and running with AppRun in minutes AppRun Concepts If you are looking for an introductory overview of AppRun technology, it is recommended to visit the concepts section.","title":"Getting Started"},{"location":"installation/#installation","text":"AppRun is distributed on npm. npm install apprun You can also load AppRun directly from the unpkg.com CDN: < script src = \"https://unpkg.com/apprun\" >< /script> Or when you need HTML or lit-HTML: < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" >< /script>","title":"Installation"},{"location":"installation/#use-in-browser","text":"","title":"Use in Browser"},{"location":"installation/#use-cdn","text":"< html lang = \"en\" > < head > < title > AppRun App </ title > < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" ></ script > </ head > < body > < script > const view = state => `<div> ${ state } </div>` ; app . start ( document . body , 'hello world' , view ); </ script > </ body > </ html >","title":"Use CDN"},{"location":"installation/#use-es-module","text":"< html lang = \"en\" > < head > < title > AppRun App </ title > </ head > < body > < script type = \"module\" > import { app } from 'https://unpkg.com/apprun/esm/apprun-html?module' ; const view = state => `<div> ${ state } </div>` ; app . start ( document . body , 'hello ESM' , view ); </ script > </ body > </ html >","title":"Use ES Module"},{"location":"installation/#use-lit-html","text":"lit-html is an efficient, expressive, extensible HTML templating library for JavaScript from the Polumer project. AppRun has included lit-html. < html lang = \"en\" > < head > < title > AppRun App </ title > </ head > < body > < script type = \"module\" > import { app } from 'https://unpkg.com/apprun/esm/apprun-html?module' const view = state => html `<div> ${ state } </div>` ; app . start ( document . body , 'hello lit-html' , view ); </ script > </ body > </ html >","title":"Use lit-html"},{"location":"installation/#use-html","text":"\u00b5html (micro html) is a ~2.5K lighterhtml subset to build declarative and reactive UI via template literals tags. AppRun allows you to use different rendering technology like \u00b5html. < html lang = \"en\" > < head > < title > AppRun App </ title > </ head > < body > < script type = \"module\" > import app from 'https://unpkg.com/apprun?module' ; import { render , html } from 'https://unpkg.com/uhtml?module' ; app . render = render ; const view = state => html `<div> ${ state } </div>` ; app . start ( document . body , 'hello uhtml' , view ); </ script > </ body > </ html >","title":"Use \u00b5html"},{"location":"installation/#use-jsx","text":"JSX is a syntax exntension to JavaScript. It makes JavaScript functions look like HTML. You can use JSX in the browser or compile JSX ahead of time. See AppRun CLI below. < html lang = \"en\" > < head > < title > AppRun App </ title > < script src = \"https://unpkg.com/@babel/standalone/babel.min.js\" ></ script > < script src = \"https://unpkg.com/apprun\" ></ script > </ head > < body > < script type = \"text/babel\" data-presets = \"es2017, react\" > const view = state => < div > { state } < /div>; app . start ( document . body , 'hello JSX' , view ); </ script > </ body > </ html >","title":"Use JSX"},{"location":"installation/#compiletranspile-and-bundle","text":"","title":"Compile/Transpile and Bundle"},{"location":"installation/#typescript-and-webpack","text":"AppRun includes a command-line tool (CLI) for creating a TypeScript and webpack configured project. npx apprun --init","title":"TypeScript and webpack"},{"location":"installation/#esbuild","text":"You can initialize a project that uses esbuild . npx apprun --init --esbuild After the command finishes execution, you can start the application and then navigate to https://localhost:8080 in a browser. npm start","title":"esbuild"},{"location":"installation/#starter-template","text":"Optionally, if not using the CLI you can directly scaffold AppRun project from the AppRun starter templates. npx degit apprunjs/apprun-esbuild my-app npx degit apprunjs/apprun-rollup my-app npx degit apprunjs/apprun-rollup-lit-html my-app npx degit apprunjs/apprun-webpack my-app npx degit apprunjs/apprun-parcel my-app npx degit apprunjs/apprun-web-components my-app npx degit apprunjs/apprun-bootstrap my-app npx degit apprunjs/apprun-coreui my-app npx degit apprunjs/apprun-pwa my-app npx degit apprunjs/apprun-pwa-workbox my-app npx degit yysun/apprun-d3 my-app npx degit yysun/apprun-electron my-app npx degit yysun/apprun-electron-forge my-app npx degit yysun/apprun-websockets my-app AppRun is so flexible that you can choose your favorite ways of using it. Next, you will see the quick-start tutorial on creating AppRun apps.","title":"Starter Template"},{"location":"online-ide/","text":"AppRun Playground \u00b6","title":"AppRun Playground"},{"location":"online-ide/#apprun-playground","text":"","title":"AppRun Playground"},{"location":"play/","text":"AppRun Playground \u00b6 const state = 0 ; const view = state => { return `<div> <h1> ${ state } </h1> <button onclick='app.run(\"-1\")'>-1</button> <button onclick='app.run(\"+1\")'>+1</button> </div>` ; }; const update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; app . start ( document . body , state , view , update ); const state = 0 ; const view = state => { return `<div> <h1> ${ state } </h1> <button onclick='app.run(\"-1\")'>-1</button> <button onclick='app.run(\"+1\")'>+1</button> </div>` ; }; const update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; app . start ( document . body , state , view , update );","title":"AppRun Playground"},{"location":"play/#apprun-playground","text":"const state = 0 ; const view = state => { return `<div> <h1> ${ state } </h1> <button onclick='app.run(\"-1\")'>-1</button> <button onclick='app.run(\"+1\")'>+1</button> </div>` ; }; const update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; app . start ( document . body , state , view , update ); const state = 0 ; const view = state => { return `<div> <h1> ${ state } </h1> <button onclick='app.run(\"-1\")'>-1</button> <button onclick='app.run(\"+1\")'>+1</button> </div>` ; }; const update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; app . start ( document . body , state , view , update );","title":"AppRun Playground"},{"location":"reactivity/","text":"Introduction \u00b6 Reactivity has been a hot buzz word for modern JavaScript UI frameworks in the past few years. Angular, Vue, and Svelte all have the reactivity builtin. They are famous and popular because of their reactivity features. Reactivity means that the changed application state will automatically reflect in the DOM. Don't be confuse the reactivity with another buzz word, reactive programming . Reactive programming is programming with asynchronous data streams. I will have another post to explain reactive programming . Reactivity is related to the data binding concept. Data binding is the process that establishes a connection between the application state and the application UI. There are two major types of data binding : one-way bing and two-binding . One-way binding means that changes of the application state cause changes to the application UI. Two-way binding means that changes of either application state or application UI (for example, with input-elements) automatically update the other. The reactivity also applies to the state object properties. E.g., if there is a person object that has the properties of first-name, last-name, and full-name, we want the full-name property to be reactive to the other two name properties. With the reactivity concept clarified, let's how we can have reactivity in AppRun. One-Way \u00b6 Many frameworks use the concept of \"variable assignments trigger UI updates\". E.g., Vue wires up the application state objects with a change detection mechanism to become a view model or Proxy. Then you can modify the view model to trigger the UI update. Svelte has a compiler to inject change detection around your application state object. You can also modify the state to trigger the UI update. Unlike other frameworks, AppRun uses the events to trigger UI updates following the event-driven web programming model naturally. During an AppRun event lifecycle : AppRun gives you the current state for you to create a new state AppRun calls your view function to create a virtual AppRun renders the virtual DOM if it is not null. You can feel the Hollywood Principle (Don't call us. We call you.) here, which usually means things are loosely coupled. We provide code pieces. The framework calls them when needed. In the example below, the AppRun $onclick directive calls the event handler, then calls the view function, and then renders the virtual DOM. const view = state => < div > < h1 > { state } < /h1> < button $onclick = { state => state - 1 } >+ 1 < /button> < button $onclick = { state => state + 1 } >+ 1 < /button> < /div>; app . start ( document . body , 0 , view ) See live demo: https://apprun.js.org/#play/8 Two-Way Binding \u00b6 AppRun $bind directive can update the state properties automatically when used with the input elements and the textarea element. It looks similar to Angular's ngModel , Vue' v-model , and Svelte's bind:value syntax. However, Angular, Vue, and Svelte have invented their own proprietary template language/syntax that you need to learn. AppRun uses the JSX that React also uses. const view = state => <> < div > { state . text } < /div> < input $bind = \"text\" placeholder = \"type something here ...\" /> < /> app . start ( document . body , {}, view ) See live demo: https://apprun.js.org/#play/0 Reactive State \u00b6 The state properties' reactivity is not a problem that the UI frameworks are to solve. But if the UI frameworks wrap or change the original state objects, they have to solve the reactivity problems. E.g., Vue uses the computed object . Svelte uses the reactive-declarations , the famous $: sign. I prefer to only use the native JavaScript/TypeScript features. Property Getter \u00b6 Like in languages like Java and C#, JavaScript has object property getter , which we can use to compute the property values dynamically. const state = ({ a : 1 , b : 2 , get c () { return this . a + this . b ; } }) Binding to the state object properties is straightforward. const view = ({ a , b , c }) => <> < input type = \"number\" $bind = \"a\" /> < input type = \"number\" $bind = \"b\" /> < p > { a } + { b } = { c } < /p> < /> app . start ( document . body , state , view ) See live demo: // Reactivity - getter const state = { a : 1 , b : 2 , get c () { return this . a + this . b ; } }; const view = ({ a , b , c }) => <> < input type = \"number\" $bind = \"a\" /> < input type = \"number\" $bind = \"b\" /> < p > { a } + { b } = { c } < /p> < />; app . start ( document . body , state , view ); ES2015 Proxy \u00b6 The Proxy is used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc.). Proxies enable you to intercept and customize operations performed on objects (such as getting properties). They are a metaprogramming feature. - from Metaprogramming with proxies To create a Proxy, we create a handler first. Then, we combine the object proxied with the handler. const handler = ({ get : ( target , name ) => { const text = target . text || '' ; switch ( name ) { case 'text' : return target . text ; case 'characters' : return text . replace ( /\\s/g , '' ). length ; case 'words' : return ! text ? 0 : text . split ( /\\s/ ). length ; case 'lines' : return text . split ( '\\n' ). length ; default : return null } } }) const state = new Proxy ( { text : \"let's count\" }, handler ) Proxy has almost no barrier to use. Anywhere accepts objects can use Proxy. AppRun can accept a state with Proxy. const view = state => < div > < textarea rows = \"10\" cols = \"50\" $bind = \"text\" >< /textarea> < div > { state . characters } { state . words } { state . lines } < /div> { state . text } < /div> app . start ( document . body , state , view ) See live demo: // Reactivity - Proxy const handler = { get : ( target , name ) => { const text = target . text || '' ; switch ( name ) { case 'text' : return target . text ; case 'characters' : return text . replace ( /\\s/g , '' ). length ; case 'words' : return ! text ? 0 : text . split ( /\\s/ ). length ; case 'lines' : return text . split ( '\\n' ). length ; default : return null } } }; const state = new Proxy ( { text : \"let's count\" }, handler ); const view = state => < div > < textarea rows = \"10\" cols = \"50\" $bind = \"text\" >< /textarea> < div > chars : { state . characters } words : { state . words } lines : { state . lines } < /div> < pre > { state . text } < /pre> < /div>; app . start ( document . body , state , view ); I like Proxy because it takes the property value calculation logic out of the state objects. The proxy handler is much easier to test and maintain. The state objects stay lean. I want the state to act like the data transfer object (DTO) in traditional multi-layered application architecture, where the DTO is an object that carries data between logical and physical layers. Conclusion \u00b6 AppRun has full reactivity support that provides us the one-way and two-way data binding as well as the reactive state . We only need to use the native JavaScript/TypeScript features. AppRun does not require you to learn a new language or a new templating syntax.","title":"Reactivity"},{"location":"reactivity/#introduction","text":"Reactivity has been a hot buzz word for modern JavaScript UI frameworks in the past few years. Angular, Vue, and Svelte all have the reactivity builtin. They are famous and popular because of their reactivity features. Reactivity means that the changed application state will automatically reflect in the DOM. Don't be confuse the reactivity with another buzz word, reactive programming . Reactive programming is programming with asynchronous data streams. I will have another post to explain reactive programming . Reactivity is related to the data binding concept. Data binding is the process that establishes a connection between the application state and the application UI. There are two major types of data binding : one-way bing and two-binding . One-way binding means that changes of the application state cause changes to the application UI. Two-way binding means that changes of either application state or application UI (for example, with input-elements) automatically update the other. The reactivity also applies to the state object properties. E.g., if there is a person object that has the properties of first-name, last-name, and full-name, we want the full-name property to be reactive to the other two name properties. With the reactivity concept clarified, let's how we can have reactivity in AppRun.","title":"Introduction"},{"location":"reactivity/#one-way","text":"Many frameworks use the concept of \"variable assignments trigger UI updates\". E.g., Vue wires up the application state objects with a change detection mechanism to become a view model or Proxy. Then you can modify the view model to trigger the UI update. Svelte has a compiler to inject change detection around your application state object. You can also modify the state to trigger the UI update. Unlike other frameworks, AppRun uses the events to trigger UI updates following the event-driven web programming model naturally. During an AppRun event lifecycle : AppRun gives you the current state for you to create a new state AppRun calls your view function to create a virtual AppRun renders the virtual DOM if it is not null. You can feel the Hollywood Principle (Don't call us. We call you.) here, which usually means things are loosely coupled. We provide code pieces. The framework calls them when needed. In the example below, the AppRun $onclick directive calls the event handler, then calls the view function, and then renders the virtual DOM. const view = state => < div > < h1 > { state } < /h1> < button $onclick = { state => state - 1 } >+ 1 < /button> < button $onclick = { state => state + 1 } >+ 1 < /button> < /div>; app . start ( document . body , 0 , view ) See live demo: https://apprun.js.org/#play/8","title":"One-Way"},{"location":"reactivity/#two-way-binding","text":"AppRun $bind directive can update the state properties automatically when used with the input elements and the textarea element. It looks similar to Angular's ngModel , Vue' v-model , and Svelte's bind:value syntax. However, Angular, Vue, and Svelte have invented their own proprietary template language/syntax that you need to learn. AppRun uses the JSX that React also uses. const view = state => <> < div > { state . text } < /div> < input $bind = \"text\" placeholder = \"type something here ...\" /> < /> app . start ( document . body , {}, view ) See live demo: https://apprun.js.org/#play/0","title":"Two-Way Binding"},{"location":"reactivity/#reactive-state","text":"The state properties' reactivity is not a problem that the UI frameworks are to solve. But if the UI frameworks wrap or change the original state objects, they have to solve the reactivity problems. E.g., Vue uses the computed object . Svelte uses the reactive-declarations , the famous $: sign. I prefer to only use the native JavaScript/TypeScript features.","title":"Reactive State"},{"location":"reactivity/#property-getter","text":"Like in languages like Java and C#, JavaScript has object property getter , which we can use to compute the property values dynamically. const state = ({ a : 1 , b : 2 , get c () { return this . a + this . b ; } }) Binding to the state object properties is straightforward. const view = ({ a , b , c }) => <> < input type = \"number\" $bind = \"a\" /> < input type = \"number\" $bind = \"b\" /> < p > { a } + { b } = { c } < /p> < /> app . start ( document . body , state , view ) See live demo: // Reactivity - getter const state = { a : 1 , b : 2 , get c () { return this . a + this . b ; } }; const view = ({ a , b , c }) => <> < input type = \"number\" $bind = \"a\" /> < input type = \"number\" $bind = \"b\" /> < p > { a } + { b } = { c } < /p> < />; app . start ( document . body , state , view );","title":"Property Getter"},{"location":"reactivity/#es2015-proxy","text":"The Proxy is used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc.). Proxies enable you to intercept and customize operations performed on objects (such as getting properties). They are a metaprogramming feature. - from Metaprogramming with proxies To create a Proxy, we create a handler first. Then, we combine the object proxied with the handler. const handler = ({ get : ( target , name ) => { const text = target . text || '' ; switch ( name ) { case 'text' : return target . text ; case 'characters' : return text . replace ( /\\s/g , '' ). length ; case 'words' : return ! text ? 0 : text . split ( /\\s/ ). length ; case 'lines' : return text . split ( '\\n' ). length ; default : return null } } }) const state = new Proxy ( { text : \"let's count\" }, handler ) Proxy has almost no barrier to use. Anywhere accepts objects can use Proxy. AppRun can accept a state with Proxy. const view = state => < div > < textarea rows = \"10\" cols = \"50\" $bind = \"text\" >< /textarea> < div > { state . characters } { state . words } { state . lines } < /div> { state . text } < /div> app . start ( document . body , state , view ) See live demo: // Reactivity - Proxy const handler = { get : ( target , name ) => { const text = target . text || '' ; switch ( name ) { case 'text' : return target . text ; case 'characters' : return text . replace ( /\\s/g , '' ). length ; case 'words' : return ! text ? 0 : text . split ( /\\s/ ). length ; case 'lines' : return text . split ( '\\n' ). length ; default : return null } } }; const state = new Proxy ( { text : \"let's count\" }, handler ); const view = state => < div > < textarea rows = \"10\" cols = \"50\" $bind = \"text\" >< /textarea> < div > chars : { state . characters } words : { state . words } lines : { state . lines } < /div> < pre > { state . text } < /pre> < /div>; app . start ( document . body , state , view ); I like Proxy because it takes the property value calculation logic out of the state objects. The proxy handler is much easier to test and maintain. The state objects stay lean. I want the state to act like the data transfer object (DTO) in traditional multi-layered application architecture, where the DTO is an object that carries data between logical and physical layers.","title":"ES2015 Proxy"},{"location":"reactivity/#conclusion","text":"AppRun has full reactivity support that provides us the one-way and two-way data binding as well as the reactive state . We only need to use the native JavaScript/TypeScript features. AppRun does not require you to learn a new language or a new templating syntax.","title":"Conclusion"},{"location":"resources/","text":"Books and Resources \u00b6 Book About AppRun \u00b6 AppRun book published by Apress. Order from Amazon Blogs and Demos \u00b6 https://dev.to/@yysun https://glitch.com/@yysun https://observablehq.com/@yysun https://apprun.js.org/#play Posts \u00b6 A Real-World Comparison of Front-End Frameworks with Benchmarks 2019 Update (2019) A Real-World Comparison of Front-End Frameworks with Benchmarks 2018 Update (2018) A Real-World Comparison of Front-End Frameworks with Benchmarks (2017) Performance Benchmark \u00b6 AppRun has also joined the js-framework-benchmark project. You can see its performance results compared to other frameworks and libraries.","title":"Resources"},{"location":"resources/#books-and-resources","text":"","title":"Books and Resources"},{"location":"resources/#book-about-apprun","text":"AppRun book published by Apress. Order from Amazon","title":"Book About AppRun"},{"location":"resources/#blogs-and-demos","text":"https://dev.to/@yysun https://glitch.com/@yysun https://observablehq.com/@yysun https://apprun.js.org/#play","title":"Blogs and Demos"},{"location":"resources/#posts","text":"A Real-World Comparison of Front-End Frameworks with Benchmarks 2019 Update (2019) A Real-World Comparison of Front-End Frameworks with Benchmarks 2018 Update (2018) A Real-World Comparison of Front-End Frameworks with Benchmarks (2017)","title":"Posts"},{"location":"resources/#performance-benchmark","text":"AppRun has also joined the js-framework-benchmark project. You can see its performance results compared to other frameworks and libraries.","title":"Performance Benchmark"},{"location":"routing/","text":"Routing \u00b6 Routing in AppRun is event-driven. Handling routing using events is straightforward. Routing Event \u00b6 AppRun router detects the hash changes in URL (by listening to the window's onpopstate event) and publishes the AppRun events using the hash as the event name. Components subscribe to the routing events. E.g., when URL in the browser address bar becomes http://..../#counter, it triggers the #counter event. The Counter component reacts to the #counter and renders itself to the screen. That's it. There is no other code for routing. Unhandled Routes \u00b6 When the AppRun router triggers an AppRun event with no listener for the route, the router will automatically generate a ROUTER_404_EVENT AppRun event giving the application a chance to degrade gracefully by, perhaps, displaying a 404 page. To bind to this event, here are a few examples of things you can do: import app , { Component , ROUTER_404_EVENT } from 'apprun' ; // Generate an error message when there's no handler for a URL. app . on ( ROUTER_404_EVENT , ( url , ... _rest ) => console . error ( 'No event handler for' , url )); // Alternatively, create a component that will display a message. class NoRouteComponent extends Component { state = {}; view = ( state ) => { return <>< h1 > PAGE NOT FOUND ! WE SUCK !< /h1></ > } // Handle the \"no route found\" events with this component update = { [ ROUTER_404_EVENT ] : state => state } } new NoRouteComponent (). mount ( on some element ); Pretty Links \u00b6 If you would prefer to use pretty links (i.e., non-hash links) and have HTML5 browser history, then you can implement a new router yourself or use the pretty router from the apprun-router package. This router also handles unknown routes via the ROUTER_404_EVENT and has a few other goodies to make life easier. Replacing Default Router \u00b6 Replacing AppRun's default router couldn't be easier. Just overwrite app.route , and you're off to the races. You'll also want to bind to the popstate events and trigger the first URL event (via the DOMContentLoaded event handler in the code example below): // A simplistic but not great router. function newRouter ( url : string ) { app . run ( url ); app . run ( ROUTER_EVENT , url ); } // Kick off the first URL event when the DOM is loaded. document . addEventListener ( \"DOMContentLoaded\" , () => { window . onpopstate = app [ \"route\" ]( location . pathname , true ); newRouter ( location . pathname ); }); app [ \"route\" ] = newRouter ; Disable Initial Route Event \u00b6","title":"Routing"},{"location":"routing/#routing","text":"Routing in AppRun is event-driven. Handling routing using events is straightforward.","title":"Routing"},{"location":"routing/#routing-event","text":"AppRun router detects the hash changes in URL (by listening to the window's onpopstate event) and publishes the AppRun events using the hash as the event name. Components subscribe to the routing events. E.g., when URL in the browser address bar becomes http://..../#counter, it triggers the #counter event. The Counter component reacts to the #counter and renders itself to the screen. That's it. There is no other code for routing.","title":"Routing Event"},{"location":"routing/#unhandled-routes","text":"When the AppRun router triggers an AppRun event with no listener for the route, the router will automatically generate a ROUTER_404_EVENT AppRun event giving the application a chance to degrade gracefully by, perhaps, displaying a 404 page. To bind to this event, here are a few examples of things you can do: import app , { Component , ROUTER_404_EVENT } from 'apprun' ; // Generate an error message when there's no handler for a URL. app . on ( ROUTER_404_EVENT , ( url , ... _rest ) => console . error ( 'No event handler for' , url )); // Alternatively, create a component that will display a message. class NoRouteComponent extends Component { state = {}; view = ( state ) => { return <>< h1 > PAGE NOT FOUND ! WE SUCK !< /h1></ > } // Handle the \"no route found\" events with this component update = { [ ROUTER_404_EVENT ] : state => state } } new NoRouteComponent (). mount ( on some element );","title":"Unhandled Routes"},{"location":"routing/#pretty-links","text":"If you would prefer to use pretty links (i.e., non-hash links) and have HTML5 browser history, then you can implement a new router yourself or use the pretty router from the apprun-router package. This router also handles unknown routes via the ROUTER_404_EVENT and has a few other goodies to make life easier.","title":"Pretty Links"},{"location":"routing/#replacing-default-router","text":"Replacing AppRun's default router couldn't be easier. Just overwrite app.route , and you're off to the races. You'll also want to bind to the popstate events and trigger the first URL event (via the DOMContentLoaded event handler in the code example below): // A simplistic but not great router. function newRouter ( url : string ) { app . run ( url ); app . run ( ROUTER_EVENT , url ); } // Kick off the first URL event when the DOM is loaded. document . addEventListener ( \"DOMContentLoaded\" , () => { window . onpopstate = app [ \"route\" ]( location . pathname , true ); newRouter ( location . pathname ); }); app [ \"route\" ] = newRouter ;","title":"Replacing Default Router"},{"location":"routing/#disable-initial-route-event","text":"","title":"Disable Initial Route Event"},{"location":"spa/","text":"Single Page Apps \u00b6 Create Project \u00b6 You can initialize a SPA project that uses TypeScript and WebPack. npx apprun --init --spa To initialize a project that targets ES5, use the AppRun CLI with the --es5 flag: npx apprun --init --spa --es5 You can initialize a SPA project that uses esbuild. npx apprun --init --spa --esbuild SPA Architecture \u00b6 AppRun SPA usually includes an HTML file, the main program that renders the screen layout, and page components that render the pages. AppRun SPA uses the events to route user interaction to the components. Treating routing like other web events is the smart idea of AppRun. All web events are unified under the event pub-sub pattern. Routing does not require special treatment. AppRun components are modularized using the ECMAScript module standard. We can import the modules statically and dynamically. We can also use the native module from the modern browsers. . \u251c\u2500 dist/ \u251c\u2500 src/ \u2502 \u251c\u2500 About.tsx \u2502 \u251c\u2500 Contact.tsx \u2502 \u251c\u2500 Home.tsx \u2502 \u251c\u2500 Layour.tsx \u2502 \u2514\u2500 main.tsx \u2514\u2500 index.html","title":"Creating Project"},{"location":"spa/#single-page-apps","text":"","title":"Single Page Apps"},{"location":"spa/#create-project","text":"You can initialize a SPA project that uses TypeScript and WebPack. npx apprun --init --spa To initialize a project that targets ES5, use the AppRun CLI with the --es5 flag: npx apprun --init --spa --es5 You can initialize a SPA project that uses esbuild. npx apprun --init --spa --esbuild","title":"Create Project"},{"location":"spa/#spa-architecture","text":"AppRun SPA usually includes an HTML file, the main program that renders the screen layout, and page components that render the pages. AppRun SPA uses the events to route user interaction to the components. Treating routing like other web events is the smart idea of AppRun. All web events are unified under the event pub-sub pattern. Routing does not require special treatment. AppRun components are modularized using the ECMAScript module standard. We can import the modules statically and dynamically. We can also use the native module from the modern browsers. . \u251c\u2500 dist/ \u251c\u2500 src/ \u2502 \u251c\u2500 About.tsx \u2502 \u251c\u2500 Contact.tsx \u2502 \u251c\u2500 Home.tsx \u2502 \u251c\u2500 Layour.tsx \u2502 \u2514\u2500 main.tsx \u2514\u2500 index.html","title":"SPA Architecture"},{"location":"ssr/","text":"Server-Side Rendering \u00b6 AppRun is a front-end library for developing SPA. It also supports to render the SPAs on the server-side, just like other frameworks. Furthermore, it also allows us to make existing traditional server-side rendered applications into SPAs. AppRun can make many existing applications built using the server-side model-view-control (MVC) architecture become SPAs quickly. SPA to SSR \u00b6 AppRun is isomorphic/universal. AppRun components can render on the client-side, as well as on the server-side using the AppRun server-side view engine. Included in the SSR AppRun application example , there are: The express.js server application (server.ts), The site layout (components/layout.tsx), The AppRun components (components/*.tsx) The client-side application (/public/spa.js). You can run the application on @glitch, https://apprun-ssr.glitch.me . SSR to SPA \u00b6 Please read this post, Making ASP.NET Core MVC Apps into Single Page Apps using AppRun","title":"Server Side Rendering"},{"location":"ssr/#server-side-rendering","text":"AppRun is a front-end library for developing SPA. It also supports to render the SPAs on the server-side, just like other frameworks. Furthermore, it also allows us to make existing traditional server-side rendered applications into SPAs. AppRun can make many existing applications built using the server-side model-view-control (MVC) architecture become SPAs quickly.","title":"Server-Side Rendering"},{"location":"ssr/#spa-to-ssr","text":"AppRun is isomorphic/universal. AppRun components can render on the client-side, as well as on the server-side using the AppRun server-side view engine. Included in the SSR AppRun application example , there are: The express.js server application (server.ts), The site layout (components/layout.tsx), The AppRun components (components/*.tsx) The client-side application (/public/spa.js). You can run the application on @glitch, https://apprun-ssr.glitch.me .","title":"SPA to SSR"},{"location":"ssr/#ssr-to-spa","text":"Please read this post, Making ASP.NET Core MVC Apps into Single Page Apps using AppRun","title":"SSR to SPA"},{"location":"state-management/","text":"State Management \u00b6 The State is the application state at any given time of your applications. The State is the data flow between Update and View. It acts as the data transfer object (DTO) in traditional multilayered application architecture, where the DTO is an object that carries data between logical and physical layers. The benefits of using events and DTO like the state is that there are no dependencies between the view and update (event handlers) . It makes the AppRun applications easier to develop, test, and maintain. You can get more information about unit testing later. State History \u00b6 The state can be stored in state history by AppRun. Once the state history is enabled, we can travel through the history back and forth to get the previous and next state. See the Counter example and Todo - undo-redo example .","title":"State Management"},{"location":"state-management/#state-management","text":"The State is the application state at any given time of your applications. The State is the data flow between Update and View. It acts as the data transfer object (DTO) in traditional multilayered application architecture, where the DTO is an object that carries data between logical and physical layers. The benefits of using events and DTO like the state is that there are no dependencies between the view and update (event handlers) . It makes the AppRun applications easier to develop, test, and maintain. You can get more information about unit testing later.","title":"State Management"},{"location":"state-management/#state-history","text":"The state can be stored in state history by AppRun. Once the state history is enabled, we can travel through the history back and forth to get the previous and next state. See the Counter example and Todo - undo-redo example .","title":"State History"},{"location":"strong-typing/","text":"Strong Typing \u00b6 AppRun is a JavaScript library for developing high-performance and reliable web applications using the elm inspired architecture, events, and components. You can write JavaScript code and use AppRun without strong typing. Strong typing is optional when using AppRun. However, if you choose to use strong typing, AppRun ships with a type definition file, apprun.d.ts since the first release. You can use the type definition file for strong typing with TypeScript. For those want to opted-in TypeScript and strong typing, please read this post Strong Typing in AppRun","title":"Strong Typing"},{"location":"strong-typing/#strong-typing","text":"AppRun is a JavaScript library for developing high-performance and reliable web applications using the elm inspired architecture, events, and components. You can write JavaScript code and use AppRun without strong typing. Strong typing is optional when using AppRun. However, if you choose to use strong typing, AppRun ships with a type definition file, apprun.d.ts since the first release. You can use the type definition file for strong typing with TypeScript. For those want to opted-in TypeScript and strong typing, please read this post Strong Typing in AppRun","title":"Strong Typing"},{"location":"tutorial/","text":"Quick Start Tutorial \u00b6 Create Your First App \u00b6 AppRun Application logic is broken down into three separated parts in the AppRun architecture. State (a.k.a. Model) \u2014 the state of your application View \u2014 a function to display the state Update \u2014 a collection of event handlers to update the state Let's use the Counter app as an example and code it directly in the HTML file. < html > < head > < meta charset = \"utf-8\" > < title > Counter </ title > </ head > < body > < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" ></ script > < script > const state = 0 ; const view = state => { return html `<div> <h1> ${ state } </h1> <button onclick='app.run(\"-1\")'>-1</button> <button onclick='app.run(\"+1\")'>+1</button> </div>` ; }; const update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; app . start ( document . body , state , view , update ); </ script > </ body > </ html > It is easy to have simple code in the HTML file. However, most of the time, we use external script files for complex app logic. < html > < head > < meta charset = \"utf-8\" > < title > Counter </ title > </ head > < body > < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" ></ script > < script src = \"app.js\" ></ script > </ body > </ html > Note We will use the script file from now on in this tutorial. Create Your First Component \u00b6 AppRun components are mini-applications that also have the state , view , and update architecture. To create a component, you can make the component class extends the AppRun Component class and define the state , view , and update properties/fields. class Counter extends Component { state = '' ; view = state => < div /> ; update = {}; } It is straightforward to re-create the Counter app as a component. //app.js class Counter extends Component { state = 0 ; view = state => { return html `<div> <h1> ${ state } </h1> <button @click= ${ ()=> this . run ( \"-1\" ) } >-1</button> <button @click= ${ ()=> this . run ( \"+1\" ) } >+1</button> </div>` ; }; update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; } new Counter (). start ( document . body ); Note Components have local event events. We use this.run instead of app.run to publish local events. Create a Web Component \u00b6 AppRun components can be defined as web components/custom elements and used in the HTML. < html > < head > < meta charset = \"utf-8\" > < title > Counter </ title > </ head > < body > < my-counter ></ my-counter > < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" ></ script > < script src = \"app.js\" ></ script > </ body > </ html > All we need to do is to give AppRun component a custom-element name. //app.js class Counter extends Component { state = 0 ; view = state => { return html `<div> <h1> ${ state } </h1> <button @click= ${ ()=> this . run ( \"-1\" ) } >-1</button> <button @click= ${ ()=> this . run ( \"+1\" ) } >+1</button> </div>` ; }; update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; } app . webComponent ( 'my-counter' , Counter ); document . body . insertAdjacentHTML ( 'beforeend' , `<my-counter></my-counter> <my-counter></my-counter>` ); Create a Single-Page App \u00b6 We can easily make a single-page page (SPA) using AppRun components. Each page is a component that can be activated by anchor links like #Home, #contact, and #about. class Home extends Component { view = () => < div > Home < /div>; update = { '#, #home' : state => state }; } class Contact extends Component { view = () => < div > Contact < /div>; update = { '#contact' : state => state }; } class About extends Component { view = () => < div > About < /div>; update = { '#about' : state => state }; } const App = () => <> < div id = \"menus\" > < a href = \"#home\" > Home < /a>{' | '} < a href = \"#contact\" > Contact < /a>{' | '} < a href = \"#about\" > About < /a></div> < div id = \"pages\" >< /div> < /> app . render ( document . body , < App /> ); [ About , Contact , Home ]. map ( C => new C (). start ( 'pages' )); Note We have just created a simple SPA using components. In a real-world scenario, usually, we create pages as modules and bundle them together or load them dynamically. Please continue to read the next section of this guide to learn more about SPA.","title":"Quick Start"},{"location":"tutorial/#quick-start-tutorial","text":"","title":"Quick Start Tutorial"},{"location":"tutorial/#create-your-first-app","text":"AppRun Application logic is broken down into three separated parts in the AppRun architecture. State (a.k.a. Model) \u2014 the state of your application View \u2014 a function to display the state Update \u2014 a collection of event handlers to update the state Let's use the Counter app as an example and code it directly in the HTML file. < html > < head > < meta charset = \"utf-8\" > < title > Counter </ title > </ head > < body > < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" ></ script > < script > const state = 0 ; const view = state => { return html `<div> <h1> ${ state } </h1> <button onclick='app.run(\"-1\")'>-1</button> <button onclick='app.run(\"+1\")'>+1</button> </div>` ; }; const update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; app . start ( document . body , state , view , update ); </ script > </ body > </ html > It is easy to have simple code in the HTML file. However, most of the time, we use external script files for complex app logic. < html > < head > < meta charset = \"utf-8\" > < title > Counter </ title > </ head > < body > < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" ></ script > < script src = \"app.js\" ></ script > </ body > </ html > Note We will use the script file from now on in this tutorial.","title":"Create Your First App"},{"location":"tutorial/#create-your-first-component","text":"AppRun components are mini-applications that also have the state , view , and update architecture. To create a component, you can make the component class extends the AppRun Component class and define the state , view , and update properties/fields. class Counter extends Component { state = '' ; view = state => < div /> ; update = {}; } It is straightforward to re-create the Counter app as a component. //app.js class Counter extends Component { state = 0 ; view = state => { return html `<div> <h1> ${ state } </h1> <button @click= ${ ()=> this . run ( \"-1\" ) } >-1</button> <button @click= ${ ()=> this . run ( \"+1\" ) } >+1</button> </div>` ; }; update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; } new Counter (). start ( document . body ); Note Components have local event events. We use this.run instead of app.run to publish local events.","title":"Create Your First Component"},{"location":"tutorial/#create-a-web-component","text":"AppRun components can be defined as web components/custom elements and used in the HTML. < html > < head > < meta charset = \"utf-8\" > < title > Counter </ title > </ head > < body > < my-counter ></ my-counter > < script src = \"https://unpkg.com/apprun/dist/apprun-html.js\" ></ script > < script src = \"app.js\" ></ script > </ body > </ html > All we need to do is to give AppRun component a custom-element name. //app.js class Counter extends Component { state = 0 ; view = state => { return html `<div> <h1> ${ state } </h1> <button @click= ${ ()=> this . run ( \"-1\" ) } >-1</button> <button @click= ${ ()=> this . run ( \"+1\" ) } >+1</button> </div>` ; }; update = { '+1' : state => state + 1 , '-1' : state => state - 1 }; } app . webComponent ( 'my-counter' , Counter ); document . body . insertAdjacentHTML ( 'beforeend' , `<my-counter></my-counter> <my-counter></my-counter>` );","title":"Create a Web Component"},{"location":"tutorial/#create-a-single-page-app","text":"We can easily make a single-page page (SPA) using AppRun components. Each page is a component that can be activated by anchor links like #Home, #contact, and #about. class Home extends Component { view = () => < div > Home < /div>; update = { '#, #home' : state => state }; } class Contact extends Component { view = () => < div > Contact < /div>; update = { '#contact' : state => state }; } class About extends Component { view = () => < div > About < /div>; update = { '#about' : state => state }; } const App = () => <> < div id = \"menus\" > < a href = \"#home\" > Home < /a>{' | '} < a href = \"#contact\" > Contact < /a>{' | '} < a href = \"#about\" > About < /a></div> < div id = \"pages\" >< /div> < /> app . render ( document . body , < App /> ); [ About , Contact , Home ]. map ( C => new C (). start ( 'pages' )); Note We have just created a simple SPA using components. In a real-world scenario, usually, we create pages as modules and bundle them together or load them dynamically. Please continue to read the next section of this guide to learn more about SPA.","title":"Create a Single-Page App"},{"location":"unit-testing/","text":"Unit Testing \u00b6 AppRun architecture is unit test-oriented. The three-architectural parts state , view , and update (event handlers) are decoupled. They are straightforward to test. AppRun development environment includes the Jest framework. The convention to run the tests is to use the npm script: npm run jest We can also runt the Jest testing interactive mode using the npm script: npm test Jest watches file changes and runs the test files only related to changed files. Jest also executes the tests in parallel. It is very fast to execute the tests. The interactive way for us to define which tests to be executed during the watch mode. Types of Testing \u00b6 There are two types of unit tests in the AppRun application. Test the events-states - publishing the events and asset the states. Test the state-vdom - set the states and asset the VDOM output of the view function. Create Tests using CLI \u00b6 Creating unit tests could be tedious, but you can use the AppRun CLI in Console to generate the tests. First, include the CLI scripts in your HTML. < script src = \"https://unpkg.com/apprun@latest/dist/apprun-dev-tools.js\" ></ script > Event-State Tests \u00b6 Use the create-event-tests command to create event-state tests. State-VDOM Tests \u00b6 Use the create-state-tests (start|stop) command to create state-view tests. Examples \u00b6 Please check out the unit tests from the AppRun RealWorld example application . You can find: How to mock the API calls Event-State Test State-VDOM Test","title":"Unit Testing"},{"location":"unit-testing/#unit-testing","text":"AppRun architecture is unit test-oriented. The three-architectural parts state , view , and update (event handlers) are decoupled. They are straightforward to test. AppRun development environment includes the Jest framework. The convention to run the tests is to use the npm script: npm run jest We can also runt the Jest testing interactive mode using the npm script: npm test Jest watches file changes and runs the test files only related to changed files. Jest also executes the tests in parallel. It is very fast to execute the tests. The interactive way for us to define which tests to be executed during the watch mode.","title":"Unit Testing"},{"location":"unit-testing/#types-of-testing","text":"There are two types of unit tests in the AppRun application. Test the events-states - publishing the events and asset the states. Test the state-vdom - set the states and asset the VDOM output of the view function.","title":"Types of Testing"},{"location":"unit-testing/#create-tests-using-cli","text":"Creating unit tests could be tedious, but you can use the AppRun CLI in Console to generate the tests. First, include the CLI scripts in your HTML. < script src = \"https://unpkg.com/apprun@latest/dist/apprun-dev-tools.js\" ></ script >","title":"Create Tests using CLI"},{"location":"unit-testing/#event-state-tests","text":"Use the create-event-tests command to create event-state tests.","title":"Event-State Tests"},{"location":"unit-testing/#state-vdom-tests","text":"Use the create-state-tests (start|stop) command to create state-view tests.","title":"State-VDOM Tests"},{"location":"unit-testing/#examples","text":"Please check out the unit tests from the AppRun RealWorld example application . You can find: How to mock the API calls Event-State Test State-VDOM Test","title":"Examples"},{"location":"view-patterns/","text":"JSX \u00b6 AppRun uses virtual DOM technology (VDOM). The VDOM is the data representing a DOM structure. AppRun compares the VDOM with the real DOM and updates only the changed elements and element properties. It provides high performance. AppRun allows you to choose your favorite virtual DOM technology to create user interfaces in the view function. We recommend using JSX. Some advanced features only apply to JSX. JSX \u00b6 JSX is a syntax sugar of function calls. You can compose the functions and apply dynamic and conditional rendering without the run-time cost of parsing the HTML string. You can use the JSX features described below. JSX fragments \u00b6 JSX Fragments let you group a list of children without adding extra root node. E.g., you can use <> for declaring fragments. E.g., const view = <> < h1 > title 1 < /h1> < h2 > title 2 < /h2> < /> Function Calls \u00b6 We can also use the capitalized JSX tag to call JavaScript functions with capitalized function names. The functions are also known as the Pure Function Component. E.g., To render the todo item list, You can call the Todo function in an array.map function. const Todo = ({ todo , idx }) => < li > { todo . title } < /li>; const view = state => < ul class = \"todo-list\" > { state . list . map (( todo , idx ) => < Todo todo = { todo } idx = { idx } /> ) } < /ul> De-structuring Properties \u00b6 The call to the Todo function passes two properties todo and idx. In the Todo function, you can retrieve the two properties by de-structuring the parameters. const Todo = ({ todo , idx }) => < li > { todo . title } < /li>; Set Class \u00b6 Each todo item should have class \u201cview\u201d represents that active or complete for a complete status of the todo item. You can use the ternary operator to toggle between two classes. const Todo = ({ todo , idx }) => < li class = { todo . done ? \"completed\" : \"view\" } > Please note that AppRun supports using the keyword class in JSX. Toggle Class \u00b6 Sometimes, you need to toggle classes based on the state. You can also use the ternary operator to toggle the class. E.g., toggle the selected class to a menu item. < li >< a class = { state . filter === 'All' ? 'selected' : '' } > All < /a></li> Show and Hide Element \u00b6 To show or hide an element dynamically, you can use the && operator. const countComplete = state . list . filter ( todo => todo . done ). length || 0 ; { countComplete && < button > Clear completed < /button>} ref \u00b6 ref is a special JSX property, which is a callback function that is called after the view function is executed. const view = < div ref = { el =>{...}} >< /div> We can use ref function to update the HTML element, e.g., set focus to an input box . ref is a better method to update the element than using the rendered lifecycle function. Please think of using the ref function before you use the rendered function. Element embedding \u00b6 Furthermore, AppRun allows embedding elements directly into JSX . view = state => { const canvas = document . createElement ( 'canvas' ); return < div > { canvas } < /div> }; A few use cases of the Element embedding are: Create special element, e.g. element has shadow root Create elements using 3rd libraries. Create and cache the element to avoid recreation in every event lifecycle Just create the HTML element and add it to the AppRun view . Please think of embedding the element before you use the ref function. Directive \u00b6 The directive is the special property that looks like $xxx. When AppRun is processing the JSX code and finds the properties of $xxx, it publishes the $ event. The event parameters contain the directive key, properties, and tag Name of the HTML element and component instance. const view = < div $myDirective >< /div>; app . on ( '$' , ({ key , props , tag , component }) => { if ( key === '$myDirective' ) { } } We can subscribe to the $ event and create custom directives to modify the properties of the HTML element, e.g., adding or removing classes . Next, you will need to learn how to handle users' navigation and activate the components, which is also known as routing .","title":"JSX"},{"location":"view-patterns/#jsx","text":"AppRun uses virtual DOM technology (VDOM). The VDOM is the data representing a DOM structure. AppRun compares the VDOM with the real DOM and updates only the changed elements and element properties. It provides high performance. AppRun allows you to choose your favorite virtual DOM technology to create user interfaces in the view function. We recommend using JSX. Some advanced features only apply to JSX.","title":"JSX"},{"location":"view-patterns/#jsx_1","text":"JSX is a syntax sugar of function calls. You can compose the functions and apply dynamic and conditional rendering without the run-time cost of parsing the HTML string. You can use the JSX features described below.","title":"JSX"},{"location":"view-patterns/#jsx-fragments","text":"JSX Fragments let you group a list of children without adding extra root node. E.g., you can use <> for declaring fragments. E.g., const view = <> < h1 > title 1 < /h1> < h2 > title 2 < /h2> < />","title":"JSX fragments"},{"location":"view-patterns/#function-calls","text":"We can also use the capitalized JSX tag to call JavaScript functions with capitalized function names. The functions are also known as the Pure Function Component. E.g., To render the todo item list, You can call the Todo function in an array.map function. const Todo = ({ todo , idx }) => < li > { todo . title } < /li>; const view = state => < ul class = \"todo-list\" > { state . list . map (( todo , idx ) => < Todo todo = { todo } idx = { idx } /> ) } < /ul>","title":"Function Calls"},{"location":"view-patterns/#de-structuring-properties","text":"The call to the Todo function passes two properties todo and idx. In the Todo function, you can retrieve the two properties by de-structuring the parameters. const Todo = ({ todo , idx }) => < li > { todo . title } < /li>;","title":"De-structuring Properties"},{"location":"view-patterns/#set-class","text":"Each todo item should have class \u201cview\u201d represents that active or complete for a complete status of the todo item. You can use the ternary operator to toggle between two classes. const Todo = ({ todo , idx }) => < li class = { todo . done ? \"completed\" : \"view\" } > Please note that AppRun supports using the keyword class in JSX.","title":"Set Class"},{"location":"view-patterns/#toggle-class","text":"Sometimes, you need to toggle classes based on the state. You can also use the ternary operator to toggle the class. E.g., toggle the selected class to a menu item. < li >< a class = { state . filter === 'All' ? 'selected' : '' } > All < /a></li>","title":"Toggle Class"},{"location":"view-patterns/#show-and-hide-element","text":"To show or hide an element dynamically, you can use the && operator. const countComplete = state . list . filter ( todo => todo . done ). length || 0 ; { countComplete && < button > Clear completed < /button>}","title":"Show and Hide Element"},{"location":"view-patterns/#ref","text":"ref is a special JSX property, which is a callback function that is called after the view function is executed. const view = < div ref = { el =>{...}} >< /div> We can use ref function to update the HTML element, e.g., set focus to an input box . ref is a better method to update the element than using the rendered lifecycle function. Please think of using the ref function before you use the rendered function.","title":"ref"},{"location":"view-patterns/#element-embedding","text":"Furthermore, AppRun allows embedding elements directly into JSX . view = state => { const canvas = document . createElement ( 'canvas' ); return < div > { canvas } < /div> }; A few use cases of the Element embedding are: Create special element, e.g. element has shadow root Create elements using 3rd libraries. Create and cache the element to avoid recreation in every event lifecycle Just create the HTML element and add it to the AppRun view . Please think of embedding the element before you use the ref function.","title":"Element embedding"},{"location":"view-patterns/#directive","text":"The directive is the special property that looks like $xxx. When AppRun is processing the JSX code and finds the properties of $xxx, it publishes the $ event. The event parameters contain the directive key, properties, and tag Name of the HTML element and component instance. const view = < div $myDirective >< /div>; app . on ( '$' , ({ key , props , tag , component }) => { if ( key === '$myDirective' ) { } } We can subscribe to the $ event and create custom directives to modify the properties of the HTML element, e.g., adding or removing classes . Next, you will need to learn how to handle users' navigation and activate the components, which is also known as routing .","title":"Directive"},{"location":"architecture-ideas/dapr/","text":"Use AppRun with Dapr \u00b6 Welcome to the world of AppRun, microservices, CQRS, and Dapr. Dapr is a portable, serverless, event-driven runtime for building resilient, stateless, and stateful microservices. We can connect AppRun events to Dapr PubSub through WebSockets to build microservices using CQRS, and Dapr. https://github.com/yysun/apprun-dapr/","title":"Microservice wirh Dapr"},{"location":"architecture-ideas/dapr/#use-apprun-with-dapr","text":"Welcome to the world of AppRun, microservices, CQRS, and Dapr. Dapr is a portable, serverless, event-driven runtime for building resilient, stateless, and stateful microservices. We can connect AppRun events to Dapr PubSub through WebSockets to build microservices using CQRS, and Dapr. https://github.com/yysun/apprun-dapr/","title":"Use AppRun with Dapr"},{"location":"architecture-ideas/db-websocket/","text":"Introduction \u00b6 The database is a specific technology for storing, managing, and processing data. In the real-world, web sites, mobile apps, and business applications that serve dynamic content all have a backend database. Started being popular in the web and mobile apps, moving to the business applications, nowadays most of the database-driven applications use a REST API based architecture. The REST API provides flexibility, scalability, and simplicity over other traditional web services architectures. However, the primary purpose of the REST API is to decouple the backend and frontend, which assumes backend and frontend know nothing about each other. Even in case we know and own both backend and frontend, such as in many business applications, we still have to develop the backend API endpoints first. And then, we develop the frontend API clients. Developing backend and frontend separately is tedious and error-prone. Also, If we want to publish events from the frontend to be handled in the backend business logic modules, we cannot do it directly. Furthermore, the REST API is not a duplex protocol. Only the frontend can call the API. The backend cannot call the frontend. Therefore sometimes, the REST API has become a barrier between frontend and backend that costs us extra time and effort to overcome. In this post, I will introduce a new application architecture that allows us to send events back and forth between the frontend apps to the backend business logic modules using the WebSocket API and AppRun without REST API. The WebSocket API is a duplex communication channel. It works well with an event-driven framework, such as AppRun. The Architecture \u00b6 The new architecture uses the WebSocket API and AppRun event system. AppRun has two important functions: app.run and app.on . app.run fires events. app.on handles events. E.g.: Module A handles the print event: import app from 'apprun' ; export default () => app . on ( 'print' , e => console . log ( e )); Module B fires the print event: import app from 'apprun' ; app . run ( 'print' , {}); Module B can invoke the function in Module A without knowing Module A. It works when Module A and Module B are both frontend modules. Can the business logic modules behind the webserver also subscribe to the frontend events? Yes, that's the exact idea of the new architecture. Let's see how it works. An Example Application \u00b6 We will create a database-driven todo application to demonstrate the new architecture. The project has the following files: The database: db/todo.db is a SQLite database The public folder has the frontend code: index.html dist/app.js The server folder has the backend code: db.js : the business logic server.js : the web server using the express and _websocket libraries The src folder has the frontend code: todo.tsx : the AppRun component for managing the todo list main.tsx : the main program Send Events to Server Through WebSocket \u00b6 First, we create a WebSocket in the frontend app ( main.tsx ). Then, We define a special AppRun global event called //ws: , which sends the events to the server. const ws = new WebSocket ( `wss:// ${ location . host } ` ); app . on ( '//ws:' , ( event , state ) => { const msg = { event , state }; ws . send ( JSON . stringify ( msg )); }); Receiving Events from Frontend \u00b6 We create the WebSockets on the webserver side ( index.js ). We listen to the WebSockets messages and convert them to AppRun events. AppRun runs on the webserver. Just like Module A and Module B example above, the AppRun events will be handled in the business logic module ( db.js ). const apprun = require ( 'apprun' ). app ; require ( './db' ); const path = require ( 'path' ); const express = require ( 'express' ); const { createServer } = require ( 'http' ); const webSocket = require ( 'ws' ); const app = express (); app . use ( express . static ( path . join ( __dirname , '../public' ))); const server = createServer ( app ); const wss = new webSocket . Server ({ server }); wss . on ( 'connection' , function ( ws ) { ws . on ( 'message' , function ( data ) { try { const json = JSON . parse ( data ); console . log ( '==>' , json ); apprun . run ( json . event , json , ws ); } catch ( e ) { ws . send ( e . toString ()); console . error ( e ); } }); }); Notice the webserver also adds the WebSocket reference, ws as the event parameter for the business logic module. Handle Events in Business Logic Module \u00b6 We handle AppRun events in the business logic module ( db.js ) to complete the CRUD operations against the database. const app = require ( 'apprun' ). app ; const sqlite3 = require ( 'sqlite3' ). verbose (); const dbFile = \"db/todo.db\" ; app . on ( '@get-all-todo' , ( json , ws ) => { const sql = 'select * from todo' ; db . all ( sql , function ( err , rows ) { json . state = rows || []; ws . send ( JSON . stringify ( json )); }); }); app . on ( '@get-todo' , ( json , ws ) => { }); app . on ( '@create-todo' , ( json , ws ) => { }); app . on ( '@update-todo' , ( json , ws ) => { }); app . on ( '@delete-todo' , ( json , ws ) => { }); app . on ( '@delete-all-todo' , ( json , ws ) => { }); Once completed the database operations, we use the WebSocket reference, ws , to send events back. Receiving Events from Backend \u00b6 Receiving events from the backend in the frontend app ( main.tsx ) is straightforward. const ws = new WebSocket ( `wss:// ${ location . host } ` ); ws . onmessage = function ( msg ) { const { event , state } = JSON . parse ( msg . data ); app . run ( event , state ); } You can see now we have 9 lines of client-side code in main.tsx and 11 lines of server-side code in index.js for transferring AppRun events between frontend and backend through WebSockets. We also have a business logic module that operates the database using AppRun events. They are ready to serve the frontend application. The Frontend Application \u00b6 The frontend Todo application is a typical AppRun application that has the Elm inspired architecture ( todo.tsx ). Listed below is the simplified code except. import app , { Component } from 'apprun' ; const state = { filter : 0 , todos : [] } const add = () => { app . run ( '//ws:' , '@create-todo' , { title : document . getElementById ( 'new_todo' ). value , done : 0 }) }; const toggle = ( _ , todo ) => { app . run ( '//ws:' , '@update-todo' , { ... }) }; const remove = ( _ , todo ) => { app . run ( '//ws:' , '@delete-todo' , todo ) }; const clear = () => { app . run ( '//ws:' , '@delete-all-todo' ) }; const search = ( state , filter ) => ({ ... state , filter }); const view = ( state ) => {...} const update = { '@get-all-todo' : ( state , todos ) => ({ ... state , todos }), '@create-todo' : ( state , todo ) => ({ ... }), '@update-todo' : ( state , todo ) => { ... }, '@delete-todo' : ( state , todo ) => { ... }, '@delete-all-todo' : state => ({ ... state , todos : [] }) } export default new Component ( state , view , update ); You can see we have state , view , and update to form an AppRun component. The local functions handle local events, such as add , toggle , remove , clear , and search . These functions fire the global event //ws: to the WebSocket. The update object contains the event handlers for the events fired from the backend. That's all the implementation plan. For details, please take a look at the live demo and the source code if you like. Run the Demo \u00b6 Live Demo: https://glitch.com/~apprun-websockets-sqlite Source Code: https://github.com/yysun/apprun-websockets-sqlite Conclusion \u00b6 The todo application has demonstrated the architecture of using events through WebSockets. The web server has no REST API endpoints. The frontend has only event handlings and has no REST API calls. The architecture is useful for database-driven applications, especially business applications. Furthermore, AppRun events are not limited to frontend and WebSockets. We can use AppRun events with the Web Workers API explained in the AppRun Book . We can also use AppRun in the Electron Apps , Firebase, Cloud Pub-Sub, and more ... Feel the power of event pub-sub pattern and learn more about building applications with AppRun.","title":"Database and Websocket"},{"location":"architecture-ideas/db-websocket/#introduction","text":"The database is a specific technology for storing, managing, and processing data. In the real-world, web sites, mobile apps, and business applications that serve dynamic content all have a backend database. Started being popular in the web and mobile apps, moving to the business applications, nowadays most of the database-driven applications use a REST API based architecture. The REST API provides flexibility, scalability, and simplicity over other traditional web services architectures. However, the primary purpose of the REST API is to decouple the backend and frontend, which assumes backend and frontend know nothing about each other. Even in case we know and own both backend and frontend, such as in many business applications, we still have to develop the backend API endpoints first. And then, we develop the frontend API clients. Developing backend and frontend separately is tedious and error-prone. Also, If we want to publish events from the frontend to be handled in the backend business logic modules, we cannot do it directly. Furthermore, the REST API is not a duplex protocol. Only the frontend can call the API. The backend cannot call the frontend. Therefore sometimes, the REST API has become a barrier between frontend and backend that costs us extra time and effort to overcome. In this post, I will introduce a new application architecture that allows us to send events back and forth between the frontend apps to the backend business logic modules using the WebSocket API and AppRun without REST API. The WebSocket API is a duplex communication channel. It works well with an event-driven framework, such as AppRun.","title":"Introduction"},{"location":"architecture-ideas/db-websocket/#the-architecture","text":"The new architecture uses the WebSocket API and AppRun event system. AppRun has two important functions: app.run and app.on . app.run fires events. app.on handles events. E.g.: Module A handles the print event: import app from 'apprun' ; export default () => app . on ( 'print' , e => console . log ( e )); Module B fires the print event: import app from 'apprun' ; app . run ( 'print' , {}); Module B can invoke the function in Module A without knowing Module A. It works when Module A and Module B are both frontend modules. Can the business logic modules behind the webserver also subscribe to the frontend events? Yes, that's the exact idea of the new architecture. Let's see how it works.","title":"The Architecture"},{"location":"architecture-ideas/db-websocket/#an-example-application","text":"We will create a database-driven todo application to demonstrate the new architecture. The project has the following files: The database: db/todo.db is a SQLite database The public folder has the frontend code: index.html dist/app.js The server folder has the backend code: db.js : the business logic server.js : the web server using the express and _websocket libraries The src folder has the frontend code: todo.tsx : the AppRun component for managing the todo list main.tsx : the main program","title":"An Example Application"},{"location":"architecture-ideas/db-websocket/#send-events-to-server-through-websocket","text":"First, we create a WebSocket in the frontend app ( main.tsx ). Then, We define a special AppRun global event called //ws: , which sends the events to the server. const ws = new WebSocket ( `wss:// ${ location . host } ` ); app . on ( '//ws:' , ( event , state ) => { const msg = { event , state }; ws . send ( JSON . stringify ( msg )); });","title":"Send Events to Server Through WebSocket"},{"location":"architecture-ideas/db-websocket/#receiving-events-from-frontend","text":"We create the WebSockets on the webserver side ( index.js ). We listen to the WebSockets messages and convert them to AppRun events. AppRun runs on the webserver. Just like Module A and Module B example above, the AppRun events will be handled in the business logic module ( db.js ). const apprun = require ( 'apprun' ). app ; require ( './db' ); const path = require ( 'path' ); const express = require ( 'express' ); const { createServer } = require ( 'http' ); const webSocket = require ( 'ws' ); const app = express (); app . use ( express . static ( path . join ( __dirname , '../public' ))); const server = createServer ( app ); const wss = new webSocket . Server ({ server }); wss . on ( 'connection' , function ( ws ) { ws . on ( 'message' , function ( data ) { try { const json = JSON . parse ( data ); console . log ( '==>' , json ); apprun . run ( json . event , json , ws ); } catch ( e ) { ws . send ( e . toString ()); console . error ( e ); } }); }); Notice the webserver also adds the WebSocket reference, ws as the event parameter for the business logic module.","title":"Receiving Events from Frontend"},{"location":"architecture-ideas/db-websocket/#handle-events-in-business-logic-module","text":"We handle AppRun events in the business logic module ( db.js ) to complete the CRUD operations against the database. const app = require ( 'apprun' ). app ; const sqlite3 = require ( 'sqlite3' ). verbose (); const dbFile = \"db/todo.db\" ; app . on ( '@get-all-todo' , ( json , ws ) => { const sql = 'select * from todo' ; db . all ( sql , function ( err , rows ) { json . state = rows || []; ws . send ( JSON . stringify ( json )); }); }); app . on ( '@get-todo' , ( json , ws ) => { }); app . on ( '@create-todo' , ( json , ws ) => { }); app . on ( '@update-todo' , ( json , ws ) => { }); app . on ( '@delete-todo' , ( json , ws ) => { }); app . on ( '@delete-all-todo' , ( json , ws ) => { }); Once completed the database operations, we use the WebSocket reference, ws , to send events back.","title":"Handle Events in Business Logic Module"},{"location":"architecture-ideas/db-websocket/#receiving-events-from-backend","text":"Receiving events from the backend in the frontend app ( main.tsx ) is straightforward. const ws = new WebSocket ( `wss:// ${ location . host } ` ); ws . onmessage = function ( msg ) { const { event , state } = JSON . parse ( msg . data ); app . run ( event , state ); } You can see now we have 9 lines of client-side code in main.tsx and 11 lines of server-side code in index.js for transferring AppRun events between frontend and backend through WebSockets. We also have a business logic module that operates the database using AppRun events. They are ready to serve the frontend application.","title":"Receiving Events from Backend"},{"location":"architecture-ideas/db-websocket/#the-frontend-application","text":"The frontend Todo application is a typical AppRun application that has the Elm inspired architecture ( todo.tsx ). Listed below is the simplified code except. import app , { Component } from 'apprun' ; const state = { filter : 0 , todos : [] } const add = () => { app . run ( '//ws:' , '@create-todo' , { title : document . getElementById ( 'new_todo' ). value , done : 0 }) }; const toggle = ( _ , todo ) => { app . run ( '//ws:' , '@update-todo' , { ... }) }; const remove = ( _ , todo ) => { app . run ( '//ws:' , '@delete-todo' , todo ) }; const clear = () => { app . run ( '//ws:' , '@delete-all-todo' ) }; const search = ( state , filter ) => ({ ... state , filter }); const view = ( state ) => {...} const update = { '@get-all-todo' : ( state , todos ) => ({ ... state , todos }), '@create-todo' : ( state , todo ) => ({ ... }), '@update-todo' : ( state , todo ) => { ... }, '@delete-todo' : ( state , todo ) => { ... }, '@delete-all-todo' : state => ({ ... state , todos : [] }) } export default new Component ( state , view , update ); You can see we have state , view , and update to form an AppRun component. The local functions handle local events, such as add , toggle , remove , clear , and search . These functions fire the global event //ws: to the WebSocket. The update object contains the event handlers for the events fired from the backend. That's all the implementation plan. For details, please take a look at the live demo and the source code if you like.","title":"The Frontend Application"},{"location":"architecture-ideas/db-websocket/#run-the-demo","text":"Live Demo: https://glitch.com/~apprun-websockets-sqlite Source Code: https://github.com/yysun/apprun-websockets-sqlite","title":"Run the Demo"},{"location":"architecture-ideas/db-websocket/#conclusion","text":"The todo application has demonstrated the architecture of using events through WebSockets. The web server has no REST API endpoints. The frontend has only event handlings and has no REST API calls. The architecture is useful for database-driven applications, especially business applications. Furthermore, AppRun events are not limited to frontend and WebSockets. We can use AppRun events with the Web Workers API explained in the AppRun Book . We can also use AppRun in the Electron Apps , Firebase, Cloud Pub-Sub, and more ... Feel the power of event pub-sub pattern and learn more about building applications with AppRun.","title":"Conclusion"},{"location":"architecture-ideas/firebase-app/","text":"Introduction \u00b6 I have been writing about the application architecture without REST, which includes the underlying architecture using WebSockets and the database-driven architecture . In this post, I will continue the journey to make a serverless application architecture using Firebase and AppRun . You will see how easy it is to use AppRun's event system with the Firebase stack to develop applications that have the full business logic process capabilities, such as authentication, authorization, request logging, and real-time database, and without REST layer. Finally, we can make the application a serverless deployment to Firebase. The Architecture \u00b6 The example application uses the following technologies: Firebase Cloud Firestore as the backend database Firebase Cloud Functions for business logic process Firebase Hosting to host the frontend Firebase Authentication Firebase is Google's mobile platform that helps you quickly develop high-quality apps and grow your business. I will focus on the architecture instead of step by step instructions. If you are not familiar with the Firebase suite of products, please visit the docs and search for the tutorials. The architecture can be summarized in the diagram below. Figure 1. Architecture Diagram Let's get into the details. Event Pub-Sub Using FireStore \u00b6 The center of the architecture is the Firebase Cloud Firestore. Firestore is a real-time database that keeps your data in-sync across client apps. When one client saves the data, FireStore pushes the data to all other clients. In the AppRun applications, we use app.on to publish events. If we save the events to FireStore, the events can be handled by other applications. It is the step (1) shown in Figure 1 above. Firestore also triggers Cloud Functions. Business Logic Process Using Cloud Functions \u00b6 Cloud Functions is Google Cloud's serverless compute platform. It runs on the server, not in the client apps. Therefore it is the best technology for business logic processing, authentication, and authorization. Functions are serverless. Functions run on Google's server, so we don't need to provision, manage, or upgrade the server. The Functions are event-driven (the magic word, I love). Firestore can trigger Functions upon data updates. When we save the events into FireStore, FireStore triggers the Function to handle the events automatically. It is the step (2) in Figure 1. Real-Time Data Sync Using FireStore. \u00b6 During the Functions event handling, it writes the updated data back to FireStore (step (3) in Figure 1). FireStore pushes the update to the frontend applications (step (4) in Figure 1). The frontend application listens to FireStore changes and publishes AppRun events for the frontend logic process to run. Now, the event handling cycle is completed. Let's see it in action with an example. Example \u00b6 The example is a ToDo application. Figure 2. ToDo Application Save Events to FireStore \u00b6 As usual, in the AppRun applications, we convert the DOM events into AppRun events. E.g., When users click the add button, we publish the //: event. // in JSX < button $onclick = {[ add ]} > Add < /button> const add = () => { app . run ( '//:' , '@create-todo' , { title : ( document . getElementById ( 'new_todo' ). value , done : 0 }) } The //: event handler saves the event into FireStore. const db = firebase . firestore (); app . on ( '//:' , ( event , data = {}) => { db . collection ( `events` ). add ({ uid , event , data }) }); There is a top-level collection, called events in FireStore. We save the user id (obtained using Firebase anonymous authentication), event name (@create-todo), and event parameters (the new to-do item). FireStore triggers our Function, which is monitoring the events collection. Handle Events in Functions \u00b6 exports . updateTodo = functions . firestore . document ( 'events/{Id}' ) . onWrite (( change , context ) => { const dat = change . after . data () as any ; const { uid , event , data } = dat ; const db = admin . firestore (); const todos = db . collection ( '/users/' + uid + '/todos' ); switch ( event ) { case '@create-todo' : return todos . add ( data ); case '@update-todo' : ... case '@delete-todo' : ... case '@delete-all-todo' : ... default : return ; } }); The Function destructs the user id, event name, and event parameters and handles it accordingly, e.g., it adds a new Todo item data into FireStore upon the '@create-todo' event. And so on so forth. FireStore then pushes the data change to the frontend. Real-Time Data in Frontend \u00b6 In the frontend, we subscribe to the onSnapshot of FireStore and publish the AppRun event, '@show-all'. const db = firebase . firestore (); db . collection ( `users/ ${ uid } /todos` ). onSnapshot ( snapshot => { app . run ( '@show-all' , snapshot . docs . map ( d => ({ id : d . id , ... d . data () }))) }); Now, we are back to our AppRun application world, in which you can see the three familiar parts: state , view , and update . import app , { Component } from 'apprun' ; const state = { filter : 0 , todos : [] } const add = () => { app . run ( '//:' , '@create-todo' , { title : ( document . getElementById ( 'new_todo' ). value , done : 0 }) }; const toggle = ( _ , todo ) => { app . run ( '//:' , '@update-todo' , { ... todo , done : ! todo . done }) }; const remove = ( _ , todo ) => { app . run ( '//:' , '@delete-todo' , todo ) }; const clear = () => { app . run ( '//:' , '@delete-all-todo' ) }; const view = ({ todos }) => {...} const update = { '@show-all' : ( state , todos ) => ({ ... state , todos }) } The Firebase ToDo application shares the same architecture as in the Database-Driven Application Post . They are only different in events. The Firebase ToDo application saves the events to FireStore. The Database-Driven Application sends and receives the events through the WebSockets. If you are new to AppRun, read the AppRun Book or visit AppRun Docs . Live Demo and Source Code \u00b6 You can play with the live demo at https://apprun-demo.firebaseapp.com . Source Code: https://github.com/yysun/apprun-firebase Conclusion \u00b6 The AppRun event pub-sub pattern looks so simple (just app.run and app.on ), yet so powerful. It is not only useful inside the frontend app. It shines more in crossing process boundaries, such as in the cases of WebSockets , Web Workers , Electron Apps , Firebase of course, and more ...","title":"Serverless App Using Firebase"},{"location":"architecture-ideas/firebase-app/#introduction","text":"I have been writing about the application architecture without REST, which includes the underlying architecture using WebSockets and the database-driven architecture . In this post, I will continue the journey to make a serverless application architecture using Firebase and AppRun . You will see how easy it is to use AppRun's event system with the Firebase stack to develop applications that have the full business logic process capabilities, such as authentication, authorization, request logging, and real-time database, and without REST layer. Finally, we can make the application a serverless deployment to Firebase.","title":"Introduction"},{"location":"architecture-ideas/firebase-app/#the-architecture","text":"The example application uses the following technologies: Firebase Cloud Firestore as the backend database Firebase Cloud Functions for business logic process Firebase Hosting to host the frontend Firebase Authentication Firebase is Google's mobile platform that helps you quickly develop high-quality apps and grow your business. I will focus on the architecture instead of step by step instructions. If you are not familiar with the Firebase suite of products, please visit the docs and search for the tutorials. The architecture can be summarized in the diagram below. Figure 1. Architecture Diagram Let's get into the details.","title":"The Architecture"},{"location":"architecture-ideas/firebase-app/#event-pub-sub-using-firestore","text":"The center of the architecture is the Firebase Cloud Firestore. Firestore is a real-time database that keeps your data in-sync across client apps. When one client saves the data, FireStore pushes the data to all other clients. In the AppRun applications, we use app.on to publish events. If we save the events to FireStore, the events can be handled by other applications. It is the step (1) shown in Figure 1 above. Firestore also triggers Cloud Functions.","title":"Event Pub-Sub Using FireStore"},{"location":"architecture-ideas/firebase-app/#business-logic-process-using-cloud-functions","text":"Cloud Functions is Google Cloud's serverless compute platform. It runs on the server, not in the client apps. Therefore it is the best technology for business logic processing, authentication, and authorization. Functions are serverless. Functions run on Google's server, so we don't need to provision, manage, or upgrade the server. The Functions are event-driven (the magic word, I love). Firestore can trigger Functions upon data updates. When we save the events into FireStore, FireStore triggers the Function to handle the events automatically. It is the step (2) in Figure 1.","title":"Business Logic Process Using Cloud Functions"},{"location":"architecture-ideas/firebase-app/#real-time-data-sync-using-firestore","text":"During the Functions event handling, it writes the updated data back to FireStore (step (3) in Figure 1). FireStore pushes the update to the frontend applications (step (4) in Figure 1). The frontend application listens to FireStore changes and publishes AppRun events for the frontend logic process to run. Now, the event handling cycle is completed. Let's see it in action with an example.","title":"Real-Time Data Sync Using FireStore."},{"location":"architecture-ideas/firebase-app/#example","text":"The example is a ToDo application. Figure 2. ToDo Application","title":"Example"},{"location":"architecture-ideas/firebase-app/#save-events-to-firestore","text":"As usual, in the AppRun applications, we convert the DOM events into AppRun events. E.g., When users click the add button, we publish the //: event. // in JSX < button $onclick = {[ add ]} > Add < /button> const add = () => { app . run ( '//:' , '@create-todo' , { title : ( document . getElementById ( 'new_todo' ). value , done : 0 }) } The //: event handler saves the event into FireStore. const db = firebase . firestore (); app . on ( '//:' , ( event , data = {}) => { db . collection ( `events` ). add ({ uid , event , data }) }); There is a top-level collection, called events in FireStore. We save the user id (obtained using Firebase anonymous authentication), event name (@create-todo), and event parameters (the new to-do item). FireStore triggers our Function, which is monitoring the events collection.","title":"Save Events to FireStore"},{"location":"architecture-ideas/firebase-app/#handle-events-in-functions","text":"exports . updateTodo = functions . firestore . document ( 'events/{Id}' ) . onWrite (( change , context ) => { const dat = change . after . data () as any ; const { uid , event , data } = dat ; const db = admin . firestore (); const todos = db . collection ( '/users/' + uid + '/todos' ); switch ( event ) { case '@create-todo' : return todos . add ( data ); case '@update-todo' : ... case '@delete-todo' : ... case '@delete-all-todo' : ... default : return ; } }); The Function destructs the user id, event name, and event parameters and handles it accordingly, e.g., it adds a new Todo item data into FireStore upon the '@create-todo' event. And so on so forth. FireStore then pushes the data change to the frontend.","title":"Handle Events in Functions"},{"location":"architecture-ideas/firebase-app/#real-time-data-in-frontend","text":"In the frontend, we subscribe to the onSnapshot of FireStore and publish the AppRun event, '@show-all'. const db = firebase . firestore (); db . collection ( `users/ ${ uid } /todos` ). onSnapshot ( snapshot => { app . run ( '@show-all' , snapshot . docs . map ( d => ({ id : d . id , ... d . data () }))) }); Now, we are back to our AppRun application world, in which you can see the three familiar parts: state , view , and update . import app , { Component } from 'apprun' ; const state = { filter : 0 , todos : [] } const add = () => { app . run ( '//:' , '@create-todo' , { title : ( document . getElementById ( 'new_todo' ). value , done : 0 }) }; const toggle = ( _ , todo ) => { app . run ( '//:' , '@update-todo' , { ... todo , done : ! todo . done }) }; const remove = ( _ , todo ) => { app . run ( '//:' , '@delete-todo' , todo ) }; const clear = () => { app . run ( '//:' , '@delete-all-todo' ) }; const view = ({ todos }) => {...} const update = { '@show-all' : ( state , todos ) => ({ ... state , todos }) } The Firebase ToDo application shares the same architecture as in the Database-Driven Application Post . They are only different in events. The Firebase ToDo application saves the events to FireStore. The Database-Driven Application sends and receives the events through the WebSockets. If you are new to AppRun, read the AppRun Book or visit AppRun Docs .","title":"Real-Time Data in Frontend"},{"location":"architecture-ideas/firebase-app/#live-demo-and-source-code","text":"You can play with the live demo at https://apprun-demo.firebaseapp.com . Source Code: https://github.com/yysun/apprun-firebase","title":"Live Demo and Source Code"},{"location":"architecture-ideas/firebase-app/#conclusion","text":"The AppRun event pub-sub pattern looks so simple (just app.run and app.on ), yet so powerful. It is not only useful inside the frontend app. It shines more in crossing process boundaries, such as in the cases of WebSockets , Web Workers , Electron Apps , Firebase of course, and more ...","title":"Conclusion"},{"location":"architecture-ideas/rust-app/","text":"Introduction \u00b6 WebAssembly has many different definitions on the Internet. I like the one from MDN the most, which says WebAssembly is a new binary assembly-like language that can run in the modern web browsers at near-native speed. There are many tools to compile code written in C/C++, Rust, Go, C#, etc. to be WebAssembly. It tells us that we can create high-performance code, but not using JavaScript/TypeScript I decided to play with Rust. Rust is another hot buzzword. It is a relatively new programming language focused on performance and safety, especially safe concurrency. -- Wikipedia This post describes how to create a WebAssembly package using Rust and use it in the AppRun applications from a JavaScript/TypeScript developer point of view. You will see the minimum steps of adding and using WebAssembly into your JavaScript/TypeScript project. Setup \u00b6 First, you will need the Rust toolchain, including rustup, rustc, and cargo for compiling Rust code, and wasm-pack for building, testing and publishing Rust-generated WebAssembly. Install Rust \u00b6 To install Rust on Mac/Linux, run the following command in the terminal. curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh On Windows, I enabled the Windows Subsystem for Linux and used Rust in the Linux terminal. Install wasm-pack \u00b6 Once installed Rust, run the following command in the terminal. cargo install wasm-pack Believe it or not, that's all you need to create WebAssembly. Let's go back to the JavaScript/TypeScript world. If you start from scratch, follow the next section to create an AppRun project. If you already have an existing project, jump to the section of Create WebAssembly Project. Create AppRun Project \u00b6 Run the commands to create an AppRun project: mkdir your-app-name cd your-app-name npx apprun -i Wait a few minutes for installing the npm packages, and then run the npm command: npm start You will see a hello world application running. AppRun Hello World Next, we will add WebAssembly to this project. Create WebAssembly Project \u00b6 Let's create a Rust project by running the following command: cargo new wasm --lib The command creates a folder called wasm and two files under the folder your-app-name/wasm : Cargo.toml and src/lib.rs . It is a regular Rust project, not a WebAssembly yet. You will need to add wasm-bindgen as the dependency to make it target WebAssembly. Open Cargo.toml and add the following sections. [lib] crate-type = [\"cdylib\"] [dependencies] wasm-bindgen = \"0.2.60\" js-sys = \"0.3.37\" wasm-bindgen is a Rust library that facilitates high-level interactions between wasm modules and JavaScript. js-sys is the waw bindings to JS global APIs for projects using wasm-bindgen. Now, you can use wasm-pack to build a WebAssembly. cd wasm wasm-pack build Use WebPack \u00b6 Since the AppRun project is a WebPack project, we can use the wasm-pack-plugin to unify the build process that creates the WebAssembly and JavaScript code at the same time. Go ahead to add the package: npm i @wasm-tool/wasm-pack-plugin -D And add the wasm-pack-plugin into the webpack.config.js . const WasmPackPlugin = require ( \"@wasm-tool/wasm-pack-plugin\" ); module . exports = { ... plugins : [ new WasmPackPlugin ({ crateDirectory : path . resolve ( __dirname , \".\" ) }), ] ... } Also, because of the wasm-pack-plugin generates the dynamic import module, you need to modify tsconfig.json file to set the module to be esnext . { \"compilerOptions\" : { ... \"module\" : \"esnext\" , ... } } Finally, the npm scripts: npm start and npm run build will build the TypeScript code as well the Rust code. Let's write some Rust code. WebAssembly and AppRun \u00b6 We will demonstrate two interactions between the WebAssembly and the AppRun application. Call the WebAssembly from the AppRun application Call the AppRun application from the WebAssembly Call WebAssembly \u00b6 First, we create a Rust function in the wasm/src/lib.rs file. use wasm_bindgen :: prelude :: * ; #[wasm_bindgen] pub fn add ( a : i32 , b : i32 ) -> i32 { a + b } This function adds two numbers. We can make a counter application from it. Here is the counter application in AppRun. import app from 'apprun' ; let wasm ; import ( '../wasm/pkg' ). then ( module => wasm = module ); const state = { title : 'Hello world - AppRun !' , count : 0 } const add = ( state , num ) => ({ ... state , count : wasm . add ( state . count , num ) }); const view = ({ title , count }) => <> < h1 > { title } < /h1> < h1 > { count } < /h1> < button $onclick = {[ add , - 1 ]} >- 1 < /button> < button $onclick = {[ add , + 1 ]} >+ 1 < /button> < />; app . start ( document . body , state , view ); You can see from the code above: Wasm-pack has created a JavaScript module that we can import dynamically. We can call the WebAssembly function just like a regular JavaScript function from a module. Running the application, we have a counter that uses the WebAssembly function. Counter with WASM Next, let's see how does the WebAssembly function call AppRun functions. Call the AppRun \u00b6 Open wasm/src/lib.rs file and add the following functions. #[wasm_bindgen] extern \"C\" { #[wasm_bindgen(js_namespace = app)] fn run ( event : & str , p : & str ); } #[wasm_bindgen(start)] pub fn start () { run ( \"@hello\" , \"hello world from rust\" ); } The first function named run binds to the AppRun app.run function. The second function named start runs automatically when the WebAssembly is loaded. The start function calls the run function to send a '@hello' event to AppRun. Back to AppRun code, we will handle the '@hello' event. import app from 'apprun' ; let wasm ; import ( '../wasm/pkg' ). then ( module => wasm = module ); const state = {...} const add = ( state , num ) => ({...}); const view = ({ title , count }) => <> ... < />; const update = { '@hello' : ( state , title ) => ({... state , title }) } app . start ( document . body , state , view , update ); Now, when the application starts, it displays the messages sent from the WebAssembly. Message from wasm We have successfully made the two-way interactions between the WebAssembly and the AppRun application. Souce Code \u00b6 You can run the live demo: https://yysun.github.io/apprun-rust . Or visit the source. {% github yysun/apprun-rust %} You also can use this project as an AppRun application template. Run the command to create your application. npx degit yysun/apprun-rust my-app Conclusion \u00b6 This post should give you a quick start to use Rust/WebAssembly in the AppRun applications. The demo project shows the two technologies interact with each other very well. You can use the demo project as a template. We have now opened the door to a new world. There are much more potentials to explorer.","title":"Webassembly app with Rust"},{"location":"architecture-ideas/rust-app/#introduction","text":"WebAssembly has many different definitions on the Internet. I like the one from MDN the most, which says WebAssembly is a new binary assembly-like language that can run in the modern web browsers at near-native speed. There are many tools to compile code written in C/C++, Rust, Go, C#, etc. to be WebAssembly. It tells us that we can create high-performance code, but not using JavaScript/TypeScript I decided to play with Rust. Rust is another hot buzzword. It is a relatively new programming language focused on performance and safety, especially safe concurrency. -- Wikipedia This post describes how to create a WebAssembly package using Rust and use it in the AppRun applications from a JavaScript/TypeScript developer point of view. You will see the minimum steps of adding and using WebAssembly into your JavaScript/TypeScript project.","title":"Introduction"},{"location":"architecture-ideas/rust-app/#setup","text":"First, you will need the Rust toolchain, including rustup, rustc, and cargo for compiling Rust code, and wasm-pack for building, testing and publishing Rust-generated WebAssembly.","title":"Setup"},{"location":"architecture-ideas/rust-app/#install-rust","text":"To install Rust on Mac/Linux, run the following command in the terminal. curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh On Windows, I enabled the Windows Subsystem for Linux and used Rust in the Linux terminal.","title":"Install Rust"},{"location":"architecture-ideas/rust-app/#install-wasm-pack","text":"Once installed Rust, run the following command in the terminal. cargo install wasm-pack Believe it or not, that's all you need to create WebAssembly. Let's go back to the JavaScript/TypeScript world. If you start from scratch, follow the next section to create an AppRun project. If you already have an existing project, jump to the section of Create WebAssembly Project.","title":"Install wasm-pack"},{"location":"architecture-ideas/rust-app/#create-apprun-project","text":"Run the commands to create an AppRun project: mkdir your-app-name cd your-app-name npx apprun -i Wait a few minutes for installing the npm packages, and then run the npm command: npm start You will see a hello world application running. AppRun Hello World Next, we will add WebAssembly to this project.","title":"Create AppRun Project"},{"location":"architecture-ideas/rust-app/#create-webassembly-project","text":"Let's create a Rust project by running the following command: cargo new wasm --lib The command creates a folder called wasm and two files under the folder your-app-name/wasm : Cargo.toml and src/lib.rs . It is a regular Rust project, not a WebAssembly yet. You will need to add wasm-bindgen as the dependency to make it target WebAssembly. Open Cargo.toml and add the following sections. [lib] crate-type = [\"cdylib\"] [dependencies] wasm-bindgen = \"0.2.60\" js-sys = \"0.3.37\" wasm-bindgen is a Rust library that facilitates high-level interactions between wasm modules and JavaScript. js-sys is the waw bindings to JS global APIs for projects using wasm-bindgen. Now, you can use wasm-pack to build a WebAssembly. cd wasm wasm-pack build","title":"Create WebAssembly Project"},{"location":"architecture-ideas/rust-app/#use-webpack","text":"Since the AppRun project is a WebPack project, we can use the wasm-pack-plugin to unify the build process that creates the WebAssembly and JavaScript code at the same time. Go ahead to add the package: npm i @wasm-tool/wasm-pack-plugin -D And add the wasm-pack-plugin into the webpack.config.js . const WasmPackPlugin = require ( \"@wasm-tool/wasm-pack-plugin\" ); module . exports = { ... plugins : [ new WasmPackPlugin ({ crateDirectory : path . resolve ( __dirname , \".\" ) }), ] ... } Also, because of the wasm-pack-plugin generates the dynamic import module, you need to modify tsconfig.json file to set the module to be esnext . { \"compilerOptions\" : { ... \"module\" : \"esnext\" , ... } } Finally, the npm scripts: npm start and npm run build will build the TypeScript code as well the Rust code. Let's write some Rust code.","title":"Use WebPack"},{"location":"architecture-ideas/rust-app/#webassembly-and-apprun","text":"We will demonstrate two interactions between the WebAssembly and the AppRun application. Call the WebAssembly from the AppRun application Call the AppRun application from the WebAssembly","title":"WebAssembly and AppRun"},{"location":"architecture-ideas/rust-app/#call-webassembly","text":"First, we create a Rust function in the wasm/src/lib.rs file. use wasm_bindgen :: prelude :: * ; #[wasm_bindgen] pub fn add ( a : i32 , b : i32 ) -> i32 { a + b } This function adds two numbers. We can make a counter application from it. Here is the counter application in AppRun. import app from 'apprun' ; let wasm ; import ( '../wasm/pkg' ). then ( module => wasm = module ); const state = { title : 'Hello world - AppRun !' , count : 0 } const add = ( state , num ) => ({ ... state , count : wasm . add ( state . count , num ) }); const view = ({ title , count }) => <> < h1 > { title } < /h1> < h1 > { count } < /h1> < button $onclick = {[ add , - 1 ]} >- 1 < /button> < button $onclick = {[ add , + 1 ]} >+ 1 < /button> < />; app . start ( document . body , state , view ); You can see from the code above: Wasm-pack has created a JavaScript module that we can import dynamically. We can call the WebAssembly function just like a regular JavaScript function from a module. Running the application, we have a counter that uses the WebAssembly function. Counter with WASM Next, let's see how does the WebAssembly function call AppRun functions.","title":"Call WebAssembly"},{"location":"architecture-ideas/rust-app/#call-the-apprun","text":"Open wasm/src/lib.rs file and add the following functions. #[wasm_bindgen] extern \"C\" { #[wasm_bindgen(js_namespace = app)] fn run ( event : & str , p : & str ); } #[wasm_bindgen(start)] pub fn start () { run ( \"@hello\" , \"hello world from rust\" ); } The first function named run binds to the AppRun app.run function. The second function named start runs automatically when the WebAssembly is loaded. The start function calls the run function to send a '@hello' event to AppRun. Back to AppRun code, we will handle the '@hello' event. import app from 'apprun' ; let wasm ; import ( '../wasm/pkg' ). then ( module => wasm = module ); const state = {...} const add = ( state , num ) => ({...}); const view = ({ title , count }) => <> ... < />; const update = { '@hello' : ( state , title ) => ({... state , title }) } app . start ( document . body , state , view , update ); Now, when the application starts, it displays the messages sent from the WebAssembly. Message from wasm We have successfully made the two-way interactions between the WebAssembly and the AppRun application.","title":"Call the AppRun"},{"location":"architecture-ideas/rust-app/#souce-code","text":"You can run the live demo: https://yysun.github.io/apprun-rust . Or visit the source. {% github yysun/apprun-rust %} You also can use this project as an AppRun application template. Run the command to create your application. npx degit yysun/apprun-rust my-app","title":"Souce Code"},{"location":"architecture-ideas/rust-app/#conclusion","text":"This post should give you a quick start to use Rust/WebAssembly in the AppRun applications. The demo project shows the two technologies interact with each other very well. You can use the demo project as a template. We have now opened the door to a new world. There are much more potentials to explorer.","title":"Conclusion"},{"location":"architecture-ideas/state-machine/","text":"Introduction \u00b6 State machine \u00b6 The state machine is the tool that developers must have in their toolbox. If you are new to the state machine, check out the reference section below. How can a state machine help? Typically, when building applications, we follow what's known as the event-driven \u2014 where an event happens in the application, we update the application state and render the state to the screen. Events can happen anytime during user interactions and system interactions while the application can be in any state. Before we start to handle the events, we first have to determine what is the current state and then handle the event accordingly. Sometimes it can be challenging. The state machine provides a state-event-state mapping. Before we start to handle the events, we know the current state and the future state, so that we only need to focus on the limited state-event scope. The specific state machine we are going to use is the Mealy machine . It has an initial state and then transitions to new states based on events and its current state. We are going to build a calculator application as an example. You will learn from this post: Model a state machine declaratively, Make the state machine type-safe Add the state machine to the AppRun application Model a Calculator \u00b6 State and Event \u00b6 The calculator application looks like: It has a grid of buttons that users can click at any time. It also displays: The numbers that the user types, or the calculation result. The calculation formula, which includes the first argument, the operator and the second argument, and the calculation result. The initial state of the calculator looks like: const state = { display : '0' , arg1 : 0 , arg2 : 0 , op : '' , }; We handle the buttons' click events in the event handler, button___click . Because of the HTML event bubbling, we just need one event handler for all buttons const view = < div class = \"buttons\" $onclick = { button_click } > ...... < /div> const button_click = ( state , e ) => { } That's all we need to do to create an AppRun application, an initial state , a view , and event handlers . Next, we will add a state machine. State Machine \u00b6 We follow and extend the calculator state machine from David's post . The post also provides a diagram helpful to understand the state machine. We first define the states and events of the state machine using TypeScript Discriminated Unions . type Events = 'NUM' | 'OP' | 'DOT' | 'CE' | 'EQ' | '+/-' ; type States = 'START' | 'FIRST_ARG' | 'FIRST_ARG_FLOAT' | 'OP' | 'SECOND_ARG' | 'SECOND_ARG_FLOAT' | 'EQ' ; We then define the state machine. It is a collection of all the states . Each state has a list of available events and transitions in an array. The transition is the function to update the state . const state_machine = { START : [ [ 'NUM' , 'FIRST_ARG' , () => display = key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display = '0.' ] ], FIRST_ARG : [ [ '+/-' , 'FIRST_ARG' , negative ], [ 'NUM' , 'FIRST_ARG' , () => display += key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display += key ], [ 'OP' , 'OP' , op1 ], [ 'CE' , 'START' , clear ] ], ... } For example, when the current state is START, and the NUM event comes, the new state should be 'FIRST_ARG (waiting for 1st argument)'. The display property of the state should be the user's input. Another example, when the current state is FIRST_ARG, and the +/- event comes, the display property should toggle between positive and negative. So on and so forth. It is straightforward to create the state machine object according to the diagram. Next, we make the state machine type-safe by adding more types. export type Transition = () => void ; export type EventStateTransition < E , S > = [ E , S , Transition ]; export type StateMachine < S extends string , E > = { [ key in S ] : EventStateTransition < E , S > []; }; The Tansition is a function to update the application state. The EventStateTransition is a TypeScript Tuple . It describes which event leads to which new state. The StateMachine is an object that uses the _States as the index key. Now, the state machine is type-safe. The TypeScript compiler only allows you to use the states and events defined in States and Events . const state_machine : StateMachine < States , Events > = { START0 : [ // Error on START0 [ 'NUM0' , 'FIRST_ARG' , () => {}], // Error on NUM0 [ 'DOT' , 'FIRST_ARG_FLOAT0' , () => {}] // Error on FIRST_ARG_FLOAT0 ], } Also, the compiler makes sure all States have their relevant entries in the state machine. const state_machine : StateMachine < States , Events > = { START : [], FIRST_ARG : [], FIRST_ARG_FLOAT : [], OP : [], SECOND_ARG : [], SECOND_ARG_FLOAT : [], //EQ:[] // Error on missing EQ state, if we commented it out } Compare to many other different ways of implementing the state machine in JavaScript/TypeScript found online, the state machine in this post has the following advantages: Declarative - it tells whats, not how; Independent - technology stack agnostic; KISS - no worry of preconditions, postconditions, etc... You can see the state machine is just a simple data structure. We can easily add it to the AppRun applications. Explained step by step below. Add State Machine to AppRun Application \u00b6 Add State Machine State \u00b6 We add a new property for tracking the state-machine state, called _state into the application state. const state = { _state : 'START' as States , display : '0' , arg1 : 0 , arg2 : 0 , op : '' , }; export type State = typeof state ; Convert UI Events \u00b6 All button clicks use the button___click event handler. We convert UI events into different state-machine events. export const button_click = ( state : State , e : any ) => { const getEvent = ( c : string ) : Events => { switch ( c ) { case '+/-' : return '+/-' ; case 'CE' : return 'CE' ; case '.' : return 'DOT' ; case '=' : return 'EQ' ; default : return /\\d/ . test ( c ) ? 'NUM' : 'OP' ; } }; const key = e . target ? . textContent || e ; const event = getEvent ( key ); } Use State Machine \u00b6 Now that we know the current state-machine state from the _state property of the application state. We also know which state-machine event we are in. We now can use the state___machine to find the matching transition . Finding transitions from the state___machine is straightforward. export const find_transition = < S extends string , E > ( state_machine : StateMachine < S , E > , state : S , event : E ) : { next_state? : S , transition? : Transition } => { const current_state = state_machine [ state ]; if ( ! current_state ) throw new Error ( `No state: ${ current_state } found in state machine` ); const event_tuple = current_state . find ( s => s [ 0 ] === event ); return event_tuple ? { next_state : event_tuple [ 1 ], transition : event_tuple [ 2 ] } : {} }; If we found the transition , we run the transition function. It updates the destructed application state properties, such as op , arg1 , arg2 , and display accordingly. We then update the application state to be the next state . const button_click = ( state , e ) => { let { _state , op , arg1 , arg2 , display } = state ; const event = getEvent ( s ); const state_machine = { }; const { next_state , transition } = find_transition ( state_machine , _state , event ); transition && transition (); _state = next_state || _state ; return { _state , op , arg1 , arg2 , display }; } If no transition found, nothing will happen. Finally, we return a new state from the event handler, AppRun will render the screen accordingly. Now, the application is wired up with AppRun architecture. We have successfully created the calculator application. You can try the live app here and find the source code here . Conclusion \u00b6 We have created a declarative and type-safe state machine. The state machine data structure is technology agnostic. You can try to use it in React or other frameworks you like. It can naturally fit into AppRun applications. AppRun is event-driven. Often I feel it is challenging to make events right. Sometimes we define too many events. Sometimes the events come out of order. By using the state machine, I can handle the events within limited state scopes. I have started to think of using more state machines to control the events. References \u00b6 There are many references online about the state machine. I got most of my inspiration from the following posts. I recommend you read the concept explanation of the posts and pay less attention to the implementations, because using AppRun, you can do better. [1] Krasimir Tsonev explains Mealy and Moore in the post: The Rise Of The State Machines [2] Jon Bellah describes the paradigm shift from event-driven to the state machine in this post: A Complete Introduction to State Machines in JavaScript [3] Erik Mogensen explains state machine and introduced the statechart in this post: What is a state machine? Have fun coding!","title":"State Machine"},{"location":"architecture-ideas/state-machine/#introduction","text":"","title":"Introduction"},{"location":"architecture-ideas/state-machine/#state-machine","text":"The state machine is the tool that developers must have in their toolbox. If you are new to the state machine, check out the reference section below. How can a state machine help? Typically, when building applications, we follow what's known as the event-driven \u2014 where an event happens in the application, we update the application state and render the state to the screen. Events can happen anytime during user interactions and system interactions while the application can be in any state. Before we start to handle the events, we first have to determine what is the current state and then handle the event accordingly. Sometimes it can be challenging. The state machine provides a state-event-state mapping. Before we start to handle the events, we know the current state and the future state, so that we only need to focus on the limited state-event scope. The specific state machine we are going to use is the Mealy machine . It has an initial state and then transitions to new states based on events and its current state. We are going to build a calculator application as an example. You will learn from this post: Model a state machine declaratively, Make the state machine type-safe Add the state machine to the AppRun application","title":"State machine"},{"location":"architecture-ideas/state-machine/#model-a-calculator","text":"","title":"Model a Calculator"},{"location":"architecture-ideas/state-machine/#state-and-event","text":"The calculator application looks like: It has a grid of buttons that users can click at any time. It also displays: The numbers that the user types, or the calculation result. The calculation formula, which includes the first argument, the operator and the second argument, and the calculation result. The initial state of the calculator looks like: const state = { display : '0' , arg1 : 0 , arg2 : 0 , op : '' , }; We handle the buttons' click events in the event handler, button___click . Because of the HTML event bubbling, we just need one event handler for all buttons const view = < div class = \"buttons\" $onclick = { button_click } > ...... < /div> const button_click = ( state , e ) => { } That's all we need to do to create an AppRun application, an initial state , a view , and event handlers . Next, we will add a state machine.","title":"State and Event"},{"location":"architecture-ideas/state-machine/#state-machine_1","text":"We follow and extend the calculator state machine from David's post . The post also provides a diagram helpful to understand the state machine. We first define the states and events of the state machine using TypeScript Discriminated Unions . type Events = 'NUM' | 'OP' | 'DOT' | 'CE' | 'EQ' | '+/-' ; type States = 'START' | 'FIRST_ARG' | 'FIRST_ARG_FLOAT' | 'OP' | 'SECOND_ARG' | 'SECOND_ARG_FLOAT' | 'EQ' ; We then define the state machine. It is a collection of all the states . Each state has a list of available events and transitions in an array. The transition is the function to update the state . const state_machine = { START : [ [ 'NUM' , 'FIRST_ARG' , () => display = key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display = '0.' ] ], FIRST_ARG : [ [ '+/-' , 'FIRST_ARG' , negative ], [ 'NUM' , 'FIRST_ARG' , () => display += key ], [ 'DOT' , 'FIRST_ARG_FLOAT' , () => display += key ], [ 'OP' , 'OP' , op1 ], [ 'CE' , 'START' , clear ] ], ... } For example, when the current state is START, and the NUM event comes, the new state should be 'FIRST_ARG (waiting for 1st argument)'. The display property of the state should be the user's input. Another example, when the current state is FIRST_ARG, and the +/- event comes, the display property should toggle between positive and negative. So on and so forth. It is straightforward to create the state machine object according to the diagram. Next, we make the state machine type-safe by adding more types. export type Transition = () => void ; export type EventStateTransition < E , S > = [ E , S , Transition ]; export type StateMachine < S extends string , E > = { [ key in S ] : EventStateTransition < E , S > []; }; The Tansition is a function to update the application state. The EventStateTransition is a TypeScript Tuple . It describes which event leads to which new state. The StateMachine is an object that uses the _States as the index key. Now, the state machine is type-safe. The TypeScript compiler only allows you to use the states and events defined in States and Events . const state_machine : StateMachine < States , Events > = { START0 : [ // Error on START0 [ 'NUM0' , 'FIRST_ARG' , () => {}], // Error on NUM0 [ 'DOT' , 'FIRST_ARG_FLOAT0' , () => {}] // Error on FIRST_ARG_FLOAT0 ], } Also, the compiler makes sure all States have their relevant entries in the state machine. const state_machine : StateMachine < States , Events > = { START : [], FIRST_ARG : [], FIRST_ARG_FLOAT : [], OP : [], SECOND_ARG : [], SECOND_ARG_FLOAT : [], //EQ:[] // Error on missing EQ state, if we commented it out } Compare to many other different ways of implementing the state machine in JavaScript/TypeScript found online, the state machine in this post has the following advantages: Declarative - it tells whats, not how; Independent - technology stack agnostic; KISS - no worry of preconditions, postconditions, etc... You can see the state machine is just a simple data structure. We can easily add it to the AppRun applications. Explained step by step below.","title":"State Machine"},{"location":"architecture-ideas/state-machine/#add-state-machine-to-apprun-application","text":"","title":"Add State Machine to AppRun Application"},{"location":"architecture-ideas/state-machine/#add-state-machine-state","text":"We add a new property for tracking the state-machine state, called _state into the application state. const state = { _state : 'START' as States , display : '0' , arg1 : 0 , arg2 : 0 , op : '' , }; export type State = typeof state ;","title":"Add State Machine State"},{"location":"architecture-ideas/state-machine/#convert-ui-events","text":"All button clicks use the button___click event handler. We convert UI events into different state-machine events. export const button_click = ( state : State , e : any ) => { const getEvent = ( c : string ) : Events => { switch ( c ) { case '+/-' : return '+/-' ; case 'CE' : return 'CE' ; case '.' : return 'DOT' ; case '=' : return 'EQ' ; default : return /\\d/ . test ( c ) ? 'NUM' : 'OP' ; } }; const key = e . target ? . textContent || e ; const event = getEvent ( key ); }","title":"Convert UI Events"},{"location":"architecture-ideas/state-machine/#use-state-machine","text":"Now that we know the current state-machine state from the _state property of the application state. We also know which state-machine event we are in. We now can use the state___machine to find the matching transition . Finding transitions from the state___machine is straightforward. export const find_transition = < S extends string , E > ( state_machine : StateMachine < S , E > , state : S , event : E ) : { next_state? : S , transition? : Transition } => { const current_state = state_machine [ state ]; if ( ! current_state ) throw new Error ( `No state: ${ current_state } found in state machine` ); const event_tuple = current_state . find ( s => s [ 0 ] === event ); return event_tuple ? { next_state : event_tuple [ 1 ], transition : event_tuple [ 2 ] } : {} }; If we found the transition , we run the transition function. It updates the destructed application state properties, such as op , arg1 , arg2 , and display accordingly. We then update the application state to be the next state . const button_click = ( state , e ) => { let { _state , op , arg1 , arg2 , display } = state ; const event = getEvent ( s ); const state_machine = { }; const { next_state , transition } = find_transition ( state_machine , _state , event ); transition && transition (); _state = next_state || _state ; return { _state , op , arg1 , arg2 , display }; } If no transition found, nothing will happen. Finally, we return a new state from the event handler, AppRun will render the screen accordingly. Now, the application is wired up with AppRun architecture. We have successfully created the calculator application. You can try the live app here and find the source code here .","title":"Use State Machine"},{"location":"architecture-ideas/state-machine/#conclusion","text":"We have created a declarative and type-safe state machine. The state machine data structure is technology agnostic. You can try to use it in React or other frameworks you like. It can naturally fit into AppRun applications. AppRun is event-driven. Often I feel it is challenging to make events right. Sometimes we define too many events. Sometimes the events come out of order. By using the state machine, I can handle the events within limited state scopes. I have started to think of using more state machines to control the events.","title":"Conclusion"},{"location":"architecture-ideas/state-machine/#references","text":"There are many references online about the state machine. I got most of my inspiration from the following posts. I recommend you read the concept explanation of the posts and pay less attention to the implementations, because using AppRun, you can do better. [1] Krasimir Tsonev explains Mealy and Moore in the post: The Rise Of The State Machines [2] Jon Bellah describes the paradigm shift from event-driven to the state machine in this post: A Complete Introduction to State Machines in JavaScript [3] Erik Mogensen explains state machine and introduced the statechart in this post: What is a state machine? Have fun coding!","title":"References"}]}