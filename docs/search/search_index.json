{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to AppRun Docs","text":"<p>Welcome to the AppRun user guide! This guide shows you how to get started creating web applications using AppRun.</p>"},{"location":"#what-is-apprun","title":"What is AppRun?","text":"<p>AppRun is a lightweight JavaScript library for building applications. It has a unique architecture inspired by the Elm architecture.</p> <p>Use a Counter as an example.</p> <p><pre><code>// define the initial state\nconst state = 0;\n\n// view is a function to display the state\nconst view = state =&gt; &lt;&gt;\n  &lt;h1&gt;{state}&lt;/h1&gt;\n  &lt;button onclick={()=&gt;app.run('-1')}&gt;-1&lt;/button&gt;\n  &lt;button onclick={()=&gt;app.run('+1')}&gt;+1&lt;/button&gt;\n&lt;/&gt;;\n\n// update is a collection of event handlers\nconst update = {\n  '+1': state =&gt; state + 1,\n  '-1': state =&gt; state - 1\n};\n\n// start the app\napp.start(document.body, state, view, update);\n</code></pre> </p> <p>Note</p> <p>Most of the code snippets in this guide are interactive. Try edit and see the results.</p> <ul> <li> <p>AppRun is lightweight, only 6KB gzipped, but includes state management, rendering, event handling, and routing.</p> </li> <li> <p>With only three functions: <code>app.start</code>, <code>app.run</code>, and <code>app.on</code> in its API makes it easy to learn and use. It can be used directly in the browser or with a compiler/bundler like Webpack or Vite.</p> </li> <li> <p>One more thing, you can use AppRun with React to simplify state management and routing of your React applications.</p> </li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>You can choose one of the following options to get started:</p> <ul> <li> <p> Use AppRun in the browser</p> <p>Reference AppRun from CDN and start building your app in no time</p> <p> Getting started</p> </li> <li> <p> Create an SPA project</p> <p>Create a new SPA project using the AppRun CLI</p> <p> Create AppRun App</p> </li> <li> <p> Use AppRun with React</p> <p>Use AppRun with React to simplify state management and routing</p> <p> React</p> </li> <li> <p> Read More about the architecture</p> <p>Understand the architecture of AppRun and how it works</p> <p> Architecture</p> </li> </ul> <p>Ready to try it yourself?</p> <p>Head over to Getting Started or explore the AppRun Architecture.</p>"},{"location":"3rd-party-libs/","title":"3rd Party Libraries","text":"<p>Using jQuery and jQuery plugins is not an anti-pattern. On the contrary, it is welcomed and encouraged. AppRun embraces 3rd libraries and recommends you use them in your AppRun application development.</p> <p>AppRun was designed to support 3rd party libraries in mind. The AppRun VDOM is resilient to allow other libraries to change to DOM.</p> <p>You can embed a DOM element into JSX or use the JSX ref attribute.</p>"},{"location":"3rd-party-libs/#embed-element","title":"Embed Element","text":"<p>It is straightforward to create a DOM element and modify it using the 3rd party library. The DOM element can be embedded into JSX directly. e.g., the example of using chart.js below. The chart.js example above also demonstrates using the unload function to destroy the Chart object.</p> <pre><code>export default class extends Component {\n  state = {\n    data: {\n      /* ... */\n    }\n  };\n\n  view = state =&gt; {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    state.chart = new Chart(ctx, state.data);\n    return (\n      &lt;Card header=\"Chart JS\"&gt;\n        {canvas}\n      &lt;/Card&gt;\n    );\n  };\n\n  unload = state =&gt; {\n    state.chart?.destroy();\n    console.log('chart destroyed');\n  }\n}\n</code></pre>"},{"location":"3rd-party-libs/#ref-attribute","title":"Ref Attribute","text":"<p>The JSX ref attribute is a callback function called when the specific DOM element is rendered. The DOM element can be any element in JSX. e.g., the d3 example below. The d3 example also demonstrates using the mounted function to initialize the state as a Promise.</p> <pre><code>const map = (element, features) =&gt; { /*...*/}\nexport default class extends Component {\n  state = {};\n  view = features =&gt; (\n    &lt;Card header={&lt;div id=\"map-text\"&gt;D3 Map&lt;/div&gt;}&gt;\n      &lt;svg ref={el =&gt; map(el, features)}&gt;&lt;/svg&gt;\n    &lt;/Card&gt;\n  );\n  mounted = () =&gt;\n    new Promise((resolve, reject) =&gt; {\n      d3.json('./world-110m.json', (error, topo) =&gt; {\n        if (error) throw reject(error);\n        const features = topojson.feature(topo, topo.objects.countries)\n          .features;\n        resolve(features);\n      });\n    });\n}\n</code></pre> <p>Combing component life cycle events and embedding DOM and the ref attribute provides a convenient way to use 3rd party libraries in the AppRun application. You can find out more from the following examples.</p>"},{"location":"3rd-party-libs/#bootstrap-admin-dashboard","title":"Bootstrap Admin Dashboard","text":"<p>The bootstrap admin dashboard uses the Bootstrap layout. It also uses jQuery DataTables and FullCalendar and chart.js and D3.</p> <p></p>"},{"location":"3rd-party-libs/#coreui-admin-template","title":"CoreUI Admin Template","text":"<p>Another example is using the CoreUI for AppRun application.</p> <p></p>"},{"location":"about/","title":"About","text":""},{"location":"about/#introduction","title":"Introduction","text":"<p>The recently updated AppRun Docs Site has made the code snippets in the documents runnable and editable, making the technical documentation interactive and much more fun to use.</p> <p>The site is built with Material for MkDocs, a beautiful and powerful tool for building technical documentation sites. We extended it by adding a web component built with AppRun to deliver interactive experiences.</p> <p>In this post, I Will explain how it's made. Let's start with reviewing the user experience.</p>"},{"location":"about/#user-experience","title":"User Experience","text":"<p>Technical documents usually have code snippets. Often the code has syntax highlighted for easy reading. However, users usually can only see screenshots but not live results of the code. Screenshots have limitations. For example, when describing how to make animation, a static screenshot is not helpful. We need a way to display the live code execution results.</p>"},{"location":"about/#see-the-results","title":"See the Results","text":"<p>You can visit the AppRun Docs Page to see a live animation.</p> <p></p>"},{"location":"about/#try-the-code","title":"Try the Code","text":"<p>Furthermore, users might have been inspired by the code examples and want to try different ideas. Traditionally, they could copy and paste the code to run it in their code editors. It would be nice for users to edit the code right on the doc site and see the results.</p> <p>You can click the \"Try the Code\" button of the AppRun Docs Page. It opens the AppRun Playground with an editor and preview pane to play the code.</p> <p></p> <p>The user experiences have improved with the capabilities of seeing the code results and trying the code in technical documents.</p>"},{"location":"about/#author-experience","title":"Author Experience","text":"<p>Not only is it much more attractive to the readers, but also the authors will feel it is much more enjoyable when writing the documents.</p>"},{"location":"about/#present-the-live-code","title":"Present the Live Code","text":"<p>Traditionally, authors copy and paste the code snippets from their testing projects into the markdown documents as code blocks. The limitation is that they can only present the code but not the running code. Sometimes, it would be hard to describe the code behavior. For example, describing a calculator could need a long text, but it could be easier to present the calculator for users to click.</p> <p>You can visit the AppRun Docs Page to see a running calculator.</p> <p></p> <p>All we need to do is to add a web component, called apprun-play under the code blocks.</p> <pre><code>```js\n// code snippets\n```\n&lt;apprun-play&gt;&lt;/apprun-play&gt;\n```\n</code></pre>"},{"location":"about/#control-the-presentation","title":"Control the Presentation","text":"<p>You probably have noticed that the page shows only the results but not the source code. It is because we can control whether to show the source code. We can also decide whether to see the \"Try the Code\" button.</p> <pre><code>```js\n// code snippets\n```\n&lt;apprun-play hide_src=\"true\" hide_button=\"true\"&gt;&lt;/apprun-play&gt;\n</code></pre> <p>You can visit the AppRun Docs Page to see an example of only displaying the running results.</p> <p></p> <p>We can present the code snippets, but we can also embed whole applications because the apprun-play web component supports HTML.</p> <p></p> <p>We can use the embedding external files feature of Material for MkDocs. This way, the markdown document does not include the source code and can remain simple and clean. Automatic Test of the Code</p> <p>When it displays the code result automatically means automatic testing of the code, which tells the author if the code works as expected.</p> <p>Also, while writing, the authors can come up with new ideas. With apprun-play web component, they can edit the code and see the live results. Once it's done, they can copy and paste the code back into the document.</p> <p>Overall, the apprun-play web component is a helpful tool for the document author.</p>"},{"location":"about/#how-its-made","title":"How It's Made","text":"<p>Web components/custom elements are safe in the markdown documents. We can build web components out of the AppRun Components quickly.</p> <p>The apprun-play web component is an AppRun component that gets the source code from its previous sibling element, a textarea, or a div with highlighted code. Then, the apprun-play web component creates an iframe for the code.</p> <p>You can find the source code here.</p> <p>You can download compiled the apprun-play web component and add it to the configuration file of Material for MkDocs, mkdocs.yml</p> <pre><code>extra_css:\n  - assets/vendor/codemirror/codemirror.css\n\nextra_javascript:\n  - assets/vendor/codemirror/codemirror.js\n  - assets/vendor/codemirror/mode/javascript/javascript.js\n  - assets/vendor/codemirror/mode/xml/xml.js\n  - assets/vendor/codemirror/mode/jsx/jsx.js\n  - assets/apprun-play.js\n</code></pre> <p>That's it. The apprun-play web component is ready for use in all the markdown documents.</p> <p>Finally, the AppRun Docs Site Github project is: https://github.com/apprunjs/apprun-docs/</p> <p>Please enjoy and send pull requests.</p>"},{"location":"apprun-site-build/","title":"AppRun-Site Build","text":"<p>The AppRun-Site build command compiles your page to ES Modules with esbuild.</p> <pre><code>npx apprun-site build\n</code></pre> <p>The build command scans your pages in the <code>pages</code> directory and compiles them into the <code>public</code> directory.</p> <pre><code>/public             &lt;- compiled site\n  /index.html       &lt;- copied from `pages/index.html`\n  /index.js         &lt;- compiled from `pages/index.md`\n  /main.js          &lt;- compiled from `pages/main.tsx` and some bootstrap code\n  /about\n    index.js        &lt;- compiled from `pages/about/index.md`\n  /contact\n    index.js        &lt;- compiled from `pages/contact/index.tsx`\n\n/pages              &lt;- source pages\n  /index.html       &lt;- index page\n  /index.md         &lt;- home page\n  /main.tsx         &lt;- start up code\n  /about\n    index.md        &lt;- about page, markdown\n  /contact\n    contact.tsx     &lt;- contact page, AppRun component\n</code></pre> <p>The compiled js files are ES modules. They are compatible on the client-side and server-side.</p> <p>Next, you will learn about client-side rendering.</p>"},{"location":"apprun-site-cli/","title":"AppRun-Site Command Line","text":"<p>The AppRun-site command line has the following commands:</p> <pre><code>Usage: apprun-site [options] [command]\n\nOptions:\n  -h, --help                  display help for command\n\nCommands:\n  build [options] [source]    build site\n  serv [options] [source]     launch development server, watch and no live reload\n  dev [options] [source]      launch development server, watch and live reload\n  help [command]              display help for command\n</code></pre>"},{"location":"apprun-site-cli/#build-command-options","title":"Build Command Options","text":"<p>You can use the following command-line options for the build command.</p> <pre><code>Usage: apprun-site build [options] [source]\n\nbuild site\n\nOptions:\n  -c, --clean            clean the output directory (default: false)\n  -w, --watch            watch the directory (default: false)\n  -r, --render           pre-render html pages (default: false)\n  -o, --output [output]  output directory (default: \"public\")\n  -p, --pages [pages]    pages directory (default: \"pages\")\n  -h, --help             display help for command\n</code></pre>"},{"location":"apprun-site-cli/#dev-command-options","title":"Dev Command Options","text":"<pre><code>Usage: apprun-site dev [options] [source]\n\nlaunch development server, watch and live reload\n\nOptions:\n  -o, --output [output]  output directory (default: \"public\")\n  -p, --pages [pages]    pages directory (default: \"pages\")\n  -n, --no_ssr           disable server side rendering (default: false)\n  -h, --help             display help for command\n\u279c  apprun git:(master) \u2717 npx apprun-site@latest serve -h\n</code></pre>"},{"location":"apprun-site-cli/#serve-command-options","title":"Serve Command Options","text":"<pre><code>Usage: apprun-site serve [options] [source]\n\nlaunch development server, live reload is optional\n\nOptions:\n  -o, --output [output]  output directory (default: \"public\")\n  -p, --pages [pages]    pages directory (default: \"pages\")\n  -n, --no_ssr           disable server side rendering (default: false)\n  -l, --live_reload      enable live reload (default: false)\n  -h, --help             display help for command\n</code></pre>"},{"location":"apprun-site-cli/#apprun-site-config-file","title":"AppRun-Site Config File","text":"<p>In addition, you can also customize the AppRun-Site in the <code>apprun-site.yml</code> config file.</p> <pre><code>site_name: AppRun Site\nsite_url: /\n\nno-startup: true   # don't inject startup code for dynamic routing\nno-sss: true       # don't use server-side-rendering\n\ndev-server:\n  port: 8080\n\nstatic-pages:     # additional pages to pre-render for the static site\n  - /products/1\n  - /products/2\n  - /products/3\n</code></pre> <p>WIP, more options to come.</p>"},{"location":"apprun-site-csr/","title":"AppRun-Site Client-Side Rendering","text":"<p>The AppRun-Site build command creates pages as ES modules that can be loaded dynamically. The AppRun-Site build command injects the client-side code into the main.js file for routing and loading the pages. To conclude, AppRun Sites are Single Page Applications (SPA).</p>"},{"location":"apprun-site-csr/#app-startup","title":"App Startup","text":"<p>If you have a startup code, you can add it to the main.tsx file. The AppRun-Site build command injects calls to the default exported function of the main.tsx file.</p> <pre><code>/pages              &lt;- pages of the website\n  /main.tsx         &lt;- startup code\n</code></pre>"},{"location":"apprun-site-csr/#example-of-a-markdown-page","title":"Example of a markdown page:","text":"<pre><code>import app from 'apprun';\nimport Layout from '../components/layout'\nimport Comic from '../components/comic';\n\nexport default () =&gt; {\n  app.webComponent('ws-comic', Comic);        // register web component\n  app.render(document.body, &lt;Layout /&gt;);      // render site layout\n}\n</code></pre>"},{"location":"apprun-site-csr/#no-code-routing","title":"No-Code Routing","text":"<p>You don't need to write any code to route an URL to a component. When users visit an URL, the client-side code will load, route, and render the page dynamically.</p> <p>E.g., when the URL in the browser address bar becomes http://.../contact, it triggers the /contact event. The Contact component reacts to the /contact and renders itself to the screen.</p> <p>The event handler for the /contact event is also injected. Therefore, there is no need to code for routing.</p>"},{"location":"apprun-site-csr/#routing-parameters","title":"Routing Parameters","text":"<p>However, if you want to pass parameters to the component through the URL, you can create your event handler. For example: <pre><code>import { app, Component } from 'apprun';\nexport default class extends Component {\n  state = async () =&gt; { ... }\n  view = state =&gt; &lt;div&gt;...&lt;/div&gt;;\n  update = {\n    '/products': async (state, id) =&gt; {\n      state = await Promise.resolve(state);\n      return ({ ...state, id: parseInt(id) })\n    }\n  };\n}\n</code></pre> When the URL in the browser address bar becomes http://.../products/1, it triggers the /products event and passes the 1 as the parameter to your event handler.</p>"},{"location":"apprun-site-csr/#pretty-links","title":"Pretty Links","text":"<p>AppRun-Site injects code by default to support pretty links (a.k.a. non-hash links), e.g., http://.../products/1. You don't need to write any code to support pretty links. However, you will need a webserver to serve the index.html when the routes don't exist on the server.</p> <p>The AppRun-Site dev server provides such capability of serving index.html when the routes don't exist.</p> <p>Next, you will see how to use the dev server and how it renders your pages on the server side.</p>"},{"location":"apprun-site-ssr/","title":"AppRun-Site Server-Side Rendering","text":"<p>The AppRun-Site serv command starts a dev server at http://localhost:8080.</p> <pre><code>npx apprun-site serv\n</code></pre> <p>The AppRun-Site dev server serves index.html when the routes don't exist to support Single Page Apps. It also has the capability of server-side rendering to support pretty links and static site creation.</p>"},{"location":"apprun-site-ssr/#es-module","title":"ES Module","text":"<p>Because the pages are compiled into ES Modules, they can be loaded dynamically. Also, thanks to the AppRun architecture, the dev server can render all the pages on the server the same way in the browser.</p> <p>E.g., when users visit http://.../contact, the dev server finds an ES module from <code>/contact/index.js</code>. The dev server loads the module dynamically and renders it to jsdom. Then, it sends the HTML from jsdom back to the browser.</p> <p>The exact same code, /contact/index.js, can be run on the client-side and the server-side. No special treatment is needed.</p>"},{"location":"apprun-site-ssr/#dynamic-routing","title":"Dynamic Routing","text":"<p>The dev server supports dynamic routing. It searches the URL and finds the corresponding ES module. E.g., when users visit http://.../products/1, the dev server will first try to find the ES module from <code>/products/1/index.js</code>. Of course, /products/1/index.js does not exist, so it will try to find <code>/products/index.js.</code> If <code>/products/index.js</code> exists, it will load the module dynamically and sends 1 as the parameter for rendering.</p> <p>The result is that pretty links are supported on the server side.</p> <p>Finally, although you have a dev server for development, you may not have a node server or use a different web server in production. In this case, you can pre-render your site into a static site. Proceed to the next section to learn how to create a static site.</p>"},{"location":"apprun-site-static/","title":"AppRun-Site - Static Site","text":"<p>The AppRun-Site build command has the option to render your pages into HTML files and create a static website.</p> <pre><code>npx apprun-site build --render\n</code></pre> <p>The build command first scans and compiles your pages in the <code>pages</code> directory and then downloads them into the <code>public</code> directory by leveraging the dev server's server-side rendering.</p> <pre><code>/public             &lt;- compiled site\n  /index.html       &lt;- copied\n  /index.js         &lt;- compiled\n  /main.js          &lt;- compiled\n  /about\n    /index.html     &lt;- *** server-side rendered page ***\n    index.js        &lt;- compiled\n  /contact\n    /index.html     &lt;- *** server-side rendered page ***\n    index.js        &lt;- compiled\n\n/pages              &lt;- sorrce pages\n  /index.html       &lt;- index page\n  /index.md         &lt;- home page\n  /main.tsx         &lt;- start up code\n  /about\n    index.md        &lt;- about page, markdown\n  /contact\n    contact.tsx     &lt;- contact page, AppRun component`\n</code></pre> <p>With all the HTML pages created, you can deploy the static website.</p> <p>In the next section, you will learn the AppRun-Site command line.</p>"},{"location":"apprun-site/","title":"AppRun Site","text":"<p>AppRun-Site let you focus on creating web pages using HTML, markdown, AppRun components, and web components. AppRun-Site will take care of the rest:</p> <ul> <li>It compiles your pages to ES Modules</li> <li>It runs your pages run as Single Page Applications (SPA)</li> <li>It can render your pages using Server-Side Rendering (SSR)</li> <li>It can also generate a static website</li> </ul>"},{"location":"apprun-site/#create-apprun-site","title":"Create AppRun Site","text":"<p>You can initialize a project using the <code>npm create apprun-app</code> command and select the <code>AppRun Site</code> template.</p> <pre><code>npm init apprun-app [my-app]\n</code></pre>"},{"location":"apprun-site/#apprun-site-architecture","title":"AppRun Site Architecture","text":"<p>An AppRun-Site project has the following structure:</p> <pre><code>/pages              &lt;- pages of the website\n  /index.html       &lt;- index page\n  /index.md         &lt;- home page\n  /main.tsx         &lt;- start up code\n  /about\n    index.md        &lt;- about page, markdown\n  /contact\n    contact.tsx     &lt;- contact page, AppRun component\n</code></pre> <p>Then, you can use:</p> <ul> <li>npm start or npm run dev to start the dev server and watch your code changes.</li> </ul> <p>The application will run at http://localhost:8080.</p>"},{"location":"apprun-site/#add-pages","title":"Add Pages","text":"<p>You can add AppRun components, class or functional (tsx/jsx files), markdown, or html files to the <code>pages</code> directory.</p> <p>Example of an AppRun class component page: <pre><code>import { app, Component } from 'apprun';\nexport default class ContactComponent extends Component {\n  state = '...';\n  view = state =&gt; &lt;div&gt;\n    &lt;h2&gt;{state}&lt;/h2&gt;\n    &lt;p&gt;This is a class Component&lt;/p&gt;\n  &lt;/div&gt;;\n}\n</code></pre></p>"},{"location":"apprun-site/#example-of-an-apprun-functional-component-page","title":"Example of an AppRun functional component page:","text":"<pre><code>import app from 'apprun';\nexport default () =&gt; &lt;&gt;\n  &lt;h2&gt;...&lt;/h2&gt;\n  &lt;p&gt;This is a functional Component&lt;/p&gt;\n&lt;/&gt;\n</code></pre>"},{"location":"apprun-site/#example-of-a-markdown-page","title":"Example of a markdown page:","text":"<pre><code># Hello Web Component\nThis is a markdown page with a web component to display a comic from XKCD\n&lt;ws-comic&gt;&lt;/ws-comic&gt;\n</code></pre>"},{"location":"apprun-site/#example-of-an-html-page","title":"Example of an html page:","text":"<pre><code>&lt;h2&gt;Page&lt;/h2&gt;\n&lt;div&gt;This is an HTML page&lt;/div&gt;\n</code></pre> <p>All the pages will be compiled into the ES modules in the <code>public</code> directory when you build the site.</p> <p>Next, you will learn how to build your site.</p>"},{"location":"architecture/","title":"AppRun Architecture","text":""},{"location":"architecture/#architecture-overview","title":"Architecture Overview","text":"<p>Application logic is broken down into three separate parts in the AppRun architecture.</p> <ul> <li>State (a.k.a. Model) \u2014 the state of your application</li> <li>View \u2014 a function to display the state</li> <li>Update \u2014 a collection of event handlers to update the state</li> </ul> <p>Use a Counter as an example.</p> <p><pre><code>const state = 0;\n\nconst view = state =&gt; &lt;div&gt;\n  &lt;h1&gt;{state}&lt;/h1&gt;\n  &lt;button onclick={()=&gt;app.run('-1')}&gt;-1&lt;/button&gt;\n  &lt;button onclick={()=&gt;app.run('+1')}&gt;+1&lt;/button&gt;\n&lt;/div&gt;;\n\nconst update = {\n  '+1': state =&gt; state + 1,\n  '-1': state =&gt; state - 1\n};\n\napp.start(document.body, state, view, update);\n</code></pre> </p>"},{"location":"architecture/#state","title":"State","text":"<p>The state can be any data structure, a number, an array, or an object that reflects the state of the application. In the _ Counter_ example, it is a number.</p> <pre><code>const state = 0;\n</code></pre> <p>Note</p> <p>You define the initial state. AppRun manages the state. Therefore the initial state is an immutable constant.</p>"},{"location":"architecture/#view","title":"View","text":"<p>The view generates Virtual DOM based on the state. Finally, AppRun calculates the differences against the web page element and renders the changes.</p> <pre><code>const view = state =&gt; &lt;div&gt;\n  &lt;h1&gt;${state}&lt;/h1&gt;\n  &lt;button $onclick=\"-1\"&gt;-1&lt;/button&gt;\n  &lt;button $onclick=\"+1\"&gt;+1&lt;/button&gt;\n&lt;/div&gt;;\n</code></pre> <p>Note</p> <p>AppRun allows you to choose your favorite virtual DOM technology in the view function. The example above uses JSX. You can also use lit-html, uhtml, and etc.</p>"},{"location":"architecture/#update","title":"Update","text":"<p>The update is a collection of named event handlers or a dictionary of event handlers. Each event handler creates a new state from the current state. <pre><code>const update = {\n  '+1': state =&gt; state + 1,\n  '-1': state =&gt; state - 1\n}\n</code></pre></p> <p>Note</p> <p>There are a few other ways to define event handlers.</p> <p>When the three parts, the state, view, and update are provided to AppRun to start an application, AppRun registers the event handlers defined in the update and waits for AppRun events.</p> <pre><code>app.start(document.body, state, view, update);\n</code></pre> <p>Next, let's review some of the benefits of AppRun Architecture.</p>"},{"location":"architecture/#avoid-spaghetti-code","title":"Avoid Spaghetti Code","text":"<p>AppRun solves two challenging problems commonly found in application development:</p> <p>Let's make the Counter a bitter complicated to show how many times each button clicked.</p> <p><pre><code>// initial state object\nconst state = {\n  count: 0,\n  count_plus: 0,\n  count_minus: 0\n}\n\n// one view function to render the state, its' a pure function\nconst view = ({ count, count_plus, count_minus }) =&gt; html`\n  &lt;h1&gt;${count}&lt;/h1&gt;\n  &lt;button onclick=\"app.run('minus')\"&gt;- (${count_minus})&lt;/button&gt;\n  &lt;button onclick=\"app.run('plus')\"&gt;+ (${count_plus})&lt;/button&gt;\n`\n\n// collection of state updates, state is immutable\nconst minus = (state) =&gt; ({\n  ...state,\n  count: state.count - 1,\n  count_minus: state.count_minus + 1\n});\n\nconst plus = (state) =&gt; ({\n  ...state,\n  count: state.count + 1,\n  count_plus: state.count_plus + 1\n});\n\napp.start(document.body, state, view, { plus, minus });\n</code></pre> </p> <p>The code below uses jQuery. jQuery is a library that provides the convenience to access and manipulate the DOM. It does not give any architectural guidance. jQuery code is similar to the vanilla JavaScript code that can go wild. A jQuery Example</p> <pre><code>$(function () {\n\n    // global state\n    let count = 0\n    let count_plus = 0\n    let count_minus = 0\n\n    function plus() {\n      // state update\n      count ++\n      count_plus ++\n\n      // rendering\n      $('#total').html(count)\n      $('#plus').html(`+ (${count_plus})`)\n    }\n\n    function minus() {\n      // state update\n      count --\n      count_minus ++\n\n      // rendering\n      $('#total').html(count)\n      $('#minus').html(`- (${count_minus})`)\n    }\n\n    $('#plus').on('click', plus)\n    $('#minus').on('click', minus)\n\n  })\n</code></pre> <p>You can see from the above code that</p> <ul> <li>The state is shared globally. The two event handlers plus and minus both update the state directly.</li> <li>The two event handlers also render the DOM in different pieces.</li> </ul> <p>Therefore, the jQuery code has two problems:</p> <ul> <li>Direct State Update</li> <li>Rendering Fragments</li> </ul> <p>In much more complicated real applications, the logic could be long and tangled even more.</p> <p>How can we solve the problems using AppRun?</p>"},{"location":"architecture/#apprun-code","title":"AppRun Code","text":"<p>AppRun includes state management, an event system, and Virtual-DOM rendering. Following the Hollywood Principle (Don't call us. We call you), we provide code pieces to AppRun and wait for AppRun to call them.</p> <p>During an AppRun event lifecycle:</p> <ul> <li>AppRun let you update the state when needed</li> <li>AppRun let you create a virtual DOM out of the state when needed</li> <li>AppRun renders the virtual DOM when needed.</li> </ul> <p>When using AppRun to update the state, AppRun gives the current state. Then, we create a new state based on the current state.</p> <pre><code>const minus = (state) =&gt; ({ ...state,\n  count: state.count - 1,\n  count_minus: state.count_minus + 1\n});\n\nconst plus = (state) =&gt; ({ ...state,\n  count: state.count + 1,\n  count_plus: state.count_plus + 1\n});\n</code></pre> <p>Because there is no reference to a shared global object, it is very easy to unit-test the logic. Also, we can focus on the parts of the state that are needed to update and ignore the rest of the state using the spread operator.</p> <p>We only write a view function that creates a virtual DOM. AppRun renders the DOM using the diffing algorithm. It only updates the DOM that is needed to change. Therefore, although we have only one view function for all events, AppRun takes care of the differential rendering accordingly.</p> <pre><code>const view = ({ count, count_plus, count_minus }) =&gt; html`\n  &lt;h1&gt;${count}&lt;/h1&gt;\n  &lt;button onclick=\"app.run('minus')\"&gt;- (${count_minus})&lt;/button&gt;\n  &lt;button onclick=\"app.run('plus')\"&gt;+ (${count_plus})&lt;/button&gt;`\n</code></pre> <p>The view function always returns the same result as long as the state is the same. It also does not change the state or anything outside the function, which means it has no side effects. Therefore, the view function is a pure function. There are many benefits of using the pure__ function, including but not limited to unit testing.</p> <p>Finally, We have a _ counter _ application shown below by putting the state, _view, and update together.</p> <p><pre><code>// initial state object\nconst state = {\n  count: 0,\n  count_plus: 0,\n  count_minus: 0\n}\n\n// one view function to render the state, its' a pure function\nconst view = ({ count, count_plus, count_minus }) =&gt; html`\n  &lt;h1&gt;${count}&lt;/h1&gt;\n  &lt;button onclick=\"app.run('minus')\"&gt;- (${count_minus})&lt;/button&gt;\n  &lt;button onclick=\"app.run('plus')\"&gt;+ (${count_plus})&lt;/button&gt;\n`\n\n// collection of state updates, state is immutable\nconst minus = (state) =&gt; ({\n  ...state,\n  count: state.count - 1,\n  count_minus: state.count_minus + 1\n});\n\nconst plus = (state) =&gt; ({\n  ...state,\n  count: state.count + 1,\n  count_plus: state.count_plus + 1\n});\n\napp.start(document.body, state, view, { plus, minus });\n</code></pre> </p> <p>You can see that with the help of AppRun state management and DOM differential rendering, we no longer have the Direct State Update with Rendering Fragments problems.</p>"},{"location":"architecture/#apprun-benefits","title":"AppRun Benefits","text":"<p>No matter how complex the application is, we will always have three parts, the state, view, and update. We don't mix the state update with DOM rendering. Because the three parts are decoupled, our codebase is so much easier to understand, test, and maintain.</p>"},{"location":"architecture/#ceremony-vs-essence","title":"Ceremony vs. Essence","text":"<p>There was the 'Ceremony vs. Essence' discussion that happened about ten years ago. At that time, Ruby was on the rise. So people compared Ruby with C#.</p> <p>The fundamental idea of the Ceremony vs. Essence idea appears to be that, all other things being equal, programming languages should attempt to allow programmers to clearly express the essence of their programs without being caught up in excessive ceremony provided by the programming language. -- From this post.</p> <p>Let's take a look at some of today's frontend technologies from the Ceremony vs. Essence point of view. We will use a simple button-click counting application as an example.</p> <p><pre><code>const add = count =&gt; count + 1;\n\nconst view = count =&gt; &lt;button $onclick={add}&gt;\n  Clicks: {count}\n&lt;/button&gt;;\n\nconst rendered = count =&gt; console.log(count);\n\napp.start(document.body, 0, view, null, { rendered });\nconsole.log('mounted!');\n</code></pre> </p>"},{"location":"architecture/#the-essence","title":"The Essence","text":"<p>The essence of the application is to display a button that adds the count by one and shows the count. Also, it will log some messages in the console to mimic effects after the rendering cycle.</p> <p>The concept is as simple as below.</p> <pre><code>&lt;button onclick=\"count+1\"&gt;\n  Clicks: {count}\n&lt;/button&gt;\n\nconsole.log(count); // upon very click\nconsole.log('mounted!'); // upon mounted\n</code></pre> <p>We will compare the 95-character essence code above with a few front-end frameworks, such as AppRun, Svelte, React Hooks, and the Vue Composition API.</p> <p>A framework defines a skeleton where the application defines its features to fill out the skeleton. -- you can find this quote from googling.</p> <p>We need to write code to plugin the essence code into the frontend frameworks, which is the ceremony. We don't want them. Less of them is better.</p>"},{"location":"architecture/#the-ceremony","title":"The Ceremony","text":""},{"location":"architecture/#apprun","title":"AppRun","text":"<p>Application logic is broken down into three separate parts in the AppRun architecture.</p> <p><pre><code>const add = count =&gt; count + 1;\n\nconst view = count =&gt; &lt;button $onclick={add}&gt;\n  Clicks: {count}\n&lt;/button&gt;;\n\nconst rendered = count =&gt; console.log(count);\n\napp.start(document.body, 0, view, null, { rendered });\nconsole.log('mounted!');\n</code></pre> </p> <p>In the example above,</p> <ol> <li>The application's state is a number that has a default value of 0.</li> <li>The add function is the event handler to update the state.</li> <li>The view function displays the state.</li> <li>The rendered function runs after the DOM is rendered.</li> <li>The app.start function ties them all together to the document.body element.</li> </ol> <p>Now, we identify and cross out the ceremonies.</p> <p></p> <p>With AppRun, the ceremony is mainly required by the JavaScript syntax, like the module import and the arrow functions. Overall, it has 226 characters, which means 58% of the code are ceremonies.</p>"},{"location":"architecture/#svelte","title":"Svelte","text":"<p>Svelte uses a single file for a component. The file consists of a script section for the code and the UI template. It requires a compiler to turn it into runnable JavaScript code.</p> <pre><code>&lt;script&gt;\n  import { onMount } from 'svelte'\n\n  let count = 0;\n  const add = () =&gt; count + 1;\n\n  $: console.log(count)\n\n  onMount(() =&gt; console.log('mounted!')\n&lt;/script&gt;\n\n&lt;button on:click={add}&gt;\n  Clicks: {count}\n&lt;/button&gt;\n</code></pre> <p>Behind the scene, the svelte compiler creates the component class boilerplate. Then, the compiler extracts the script block, wires up the reactivity ($:), and adds the rendering template into the boilerplate. The boilerplate does not exist in our codebase. Therefore, the svelte application has very few ceremonies.</p> <p></p> <p>Svelte code ceremony is also mainly the JavaScript syntax requirements. Only the script tags are required by the Svelte compiler, which is worth trading with what the compiler saves.</p> <p>It has 217 characters, which means 56% of the code is ceremony.</p>"},{"location":"architecture/#react-hooks","title":"React Hooks","text":"<p>The React code is a slightly modified version of the React Hooks Docs](https://reactjs.org/docs/hooks-overview.html).</p> <pre><code>import React, { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  const add = () =&gt; setCount(count + 1)\n\n  useEffect(() =&gt; {\n    console.log(count);\n  });\n\n  return (\n    &lt;button onClick={add}&gt;\n      Clicks: {count}\n    &lt;/button&gt;\n  );\n}\n</code></pre> <p>The React code has more ceremonies than the AppRun code and Svelte code above. It has 272 characters and a 65% ceremony.</p> <p></p> <p>The setCount, _useState, and useEffect functions are the code that deals with the React framework itself. They don't help us to express the essence of the application. They are framework ceremonies.</p>"},{"location":"architecture/#vue-composition-api","title":"Vue Composition API","text":"<p>The Vue code is a slightly modified version of the Vue Composition API Docs.</p> <p><pre><code>&lt;template&gt;\n  &lt;button @click=\"add\"&gt;\n    Clicks: {{ count }}\n  &lt;/button&gt;\n&lt;/template&gt;\n\nimport { ref, watchEffect, onMounted } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    function add() {\n      count.value++\n    }\n\n    watchEffect(() =&gt; console.log(count.value))\n\n    onMounted(() =&gt; console.log('mounted!'))\n\n    return {\n      count,\n      add\n    }\n  }\n}\n</code></pre> The Vue code has 355 characters and a 73% ceremony.</p> <p></p> <p>The ref, watchEffect, onMounted, setup, _count.value, and returning an object of count, and add are all required by the Vue framework. Sometimes, they may make writing code more difficult.</p>"},{"location":"architecture/#expression-comparison","title":"Expression Comparison","text":"<p>We are not stopping at only comparing the character counts or how many extra boilerplates are forced on you by the frameworks. We also compare how you express the business logic. For example, let's see how we express Increase the Counter as an example again.</p> <pre><code>// AppRun\nconst add = counter =&gt; counter + 1;\n\n//Svelte\nlet count = 0;\nconst add = () =&gt; counter + 1;\n\n// React\nconst [count, setCount] = useState(0);\nconst add = () =&gt; setCount(count + 1);\n\n// Vue\nconst count = ref(0);\nconst add = () =&gt; count.value++;\n</code></pre> <p>Both the AppRun code and the Svelte code express the essence well and have less ceremony. So AppRun and Svelte are easy to understand. React Hooks and Vue Composition API are cool. However, they both add a lot more ceremonies to our codebase.</p> <p>Remember, the ceremony has no business values but just challenges to understand and maintain.</p> <p>In addition, AppRun has a few other benefits</p> <ul> <li>AppRun is lightweight that can run in browsers directly without a compiler.</li> <li>AppRun uses pure functions when it is possible.</li> <li>AppRun app codebase can easily be strongly typed if you wish.</li> </ul> <p>I hope you enjoy it. If you haven't tried, try to edit and run the AppRun code above.</p>"},{"location":"cli-in-console/","title":"AppRun Dev Tools","text":"<p>We have been using the command-line interface (CLI) in the terminal window and the command prompt. Have you thought of a CLI in the console of the browser's developer tool?</p> <p></p>"},{"location":"cli-in-console/#how-does-it-work","title":"How does it work?","text":"<p>In the console of the browser's developer tool (F12), you can type the command.</p> <pre><code>_apprun `&lt;command&gt; [options]`\n</code></pre> <p>Just like many other CLI, the help command lists all available commands. For example, you can see three commands in the screenshotcomponents, events, and log.</p>"},{"location":"cli-in-console/#why-do-we-need-a-cli-in-the-console","title":"Why do we need a CLI in the console?","text":"<p>CLI in the console is convenient for watching runtime data. For example, during application development, we often need to debug and check the application's internal data. Using the console.log function is the easiest yet most compelling way to display the data because the console lets us drill down into the nested array and object structure.</p> <p></p> <p>With a CLI in the console, The app codebase stays clear of console.log. The CLI provides a non-destructive way of watching the runtime data. We can include the CLI script in the development environment and remove it from the production environment.</p>"},{"location":"cli-in-console/#how-is-it-made","title":"How is it made?","text":"<p>The CLI uses JavaScript tagged templates.</p> <p>We create the _apprun function in the window object.</p> <pre><code>window['_apprun'] = (strings) =&gt; { }\n</code></pre> <p>The _apprun function is called when we type the AppRun commands in the console. The command and the command parameters are passed into the _apprun function as the function parameter strings, which we can parse and then invoke the command functions.</p> <p><pre><code>window['_apprun'] = (strings) =&gt; {\n  const [cmd, ...p] = strings[0].split(' ').filter(c =&gt; !!c);\n  const command = window[`_apprun-${cmd}`];\n  if (command) command[1](...p);\n  else window['_apprun-help'][1]();\n}\n</code></pre> It has extensive architecture. We create the AppRun commands in the window object. The AppRun command is a tuple that includes the description of the command and the implementation function of the command. E.g., the help command looks like this:</p> <p><pre><code>window['_apprun-help'] = ['', () =&gt; {\n  Object.keys(window).forEach(cmd =&gt; {\n    if (cmd.startsWith('_apprun-')) {\n      cmd === '_apprun-help' ?\n        console.log('AppRun Commands:') :\n        console.log(`* ${cmd.substring(8)}: ${window[cmd][0]}`);\n    }\n  });\n}];\n</code></pre> The help command searches for the tuples stored in the window object and prints the description of other AppRun commands.</p> <p>That's all the infrastructure code we need to create CLI commands in the console. Let's see an example.</p>"},{"location":"cli-in-console/#live-demo","title":"Live Demo","text":"<p>The AppRun Dev Tools is one of the developer tools included in the AppRun library. You can visit the AppRun RealWorld Example App https://gothinkster.github.io/apprun-realworld-example-app to see the CLI in action.</p> <ul> <li>The components command logs the DOM elements that have AppRun components</li> <li>The events command logs the event subscription of the app</li> <li>The log command logs the runtime events publication of the app</li> <li>The create-event-tests command creates unit tests for the app</li> <li>The create-state-tests command creates Jest snapshot tests for the app</li> </ul>"},{"location":"cli-in-console/#conclusion","title":"Conclusion","text":"<p>Developers like CLI. Dev Tools helps get runtime events and messages hard for the traditional CLI in the terminal. The AppRun Dev Tools can watch the components and events, and can generate tests. Thus, it increases the development productivity for debugging and testing.</p>"},{"location":"component/","title":"Component","text":"<p>The component is a technique to decompose the large system into smaller, manageable, and reusable pieces. The component is the basic building block. Usually, a component is an autonomous and reusable module that encapsulates a set of data and functions.</p> <p>An AppRun component is a mini-application with elm architecture, which means inside a component, there are state, view, and update. In addition, components provide a local scope.</p>"},{"location":"component/#render-the-component","title":"Render the Component","text":"<p>To use the components, you can render them into an element.</p> <p><pre><code>const element = document.getElementById('my-app');\napp.render(element, &lt;Counter /&gt;);\n</code></pre> When rendering the component, AppRun creates a component instance and renders it to the element.</p>"},{"location":"component/#mount-and-start","title":"Mount and Start","text":"<p>Or you can create the component using the constructor and mount the component instance to an element or to an element ID. When the component is mounted to an element ID, It will render the element only when it exists.</p> <pre><code>const element = document.getElementById('my-app');\nnew Counter().mount(element);\n</code></pre> <p>You can also pass the initial state into the component's constructor directly:</p> <pre><code>new Counter(100).mount(element);\n</code></pre> <p>When the component is mounted, by default, it won't display until the events come. It is useful in the single-page application (SPA) scenario where you can mount all components at once. Each component is activated by the routing events.</p> <p>If you need the component to display the initial state, you can use the start function.</p> <pre><code>new Counter().start(document.body); // mount and display\n</code></pre> <p>You can render, mount, or start the component to document.body.</p> <pre><code>//\napp.render(document.body, &lt;Counter /&gt;);\n//\nnew Counter().mount(document.body);\n//\nnew Counter().start(document.body);\n</code></pre>"},{"location":"component/#child-component","title":"Child Component","text":"<p>Components can have child components.</p> <pre><code>class Child extends Component {\n  state = {}\n  view = state =&gt; &lt;div&gt;&lt;/div&gt;\n  update = {}\n}\n\nclass Parent extends Component {\n  state = {}\n  view = state =&gt; &lt;div&gt;\n    &lt;Child /&gt;\n  &lt;/div&gt;\n  update = {}\n}\n</code></pre> <p>You are not forced into the nested component structure. Sometimes, mounting components are more flexible. Please read this post, Redux vs. The React Context API vs. AppRun.</p>"},{"location":"component/#component-events","title":"Component Events","text":"<p>A Component provides a local scope for events. The update registers the local events in the component. The this.run function fires local events that can only be picked up inside the component.</p> <p>You can prefix the event name with #, / or @ to make it global.</p> <pre><code>class Counter extends Component {\n   update = {\n      '+1': state=&gt;state+1, // local event\n      '#+1': state=&gt;state+1, // global event\n   }\n}\n</code></pre> <p>The app.run fires the global events that can be picked up by all components.</p> <p>In addition, to use the update for defining event handlers, you can also use the @on decorator or the $on directive.</p>"},{"location":"component/#event-handler-decorator","title":"Event Handler Decorator","text":"<p>In the component class, we can use TypeScript to compile the @on decorators to create the event handlers without using the update object.</p> <pre><code>import app, { Component, on } from 'apprun';\nclass Counter extends Component {\n  state = 0;\n  view = state =&gt; &lt;&gt;\n    &lt;h1&gt;{state}&lt;/h1&gt;\n    &lt;button onclick={()=&gt;this.run('-1')}&gt;-1&lt;/button&gt;\n    &lt;button onclick={()=&gt;this.run('+1')}&gt;+1&lt;/button&gt;\n  &lt;/&gt;;\n\n  @on('-1')\n  decrease = state =&gt; state - 1;\n\n  @on('+1')\n  increase = state =&gt; state + 1;\n}\n</code></pre>"},{"location":"component/#event-directive","title":"Event Directive","text":"<p>We can also use the directive to simplify event handling.</p> <pre><code>import {app, Component} from 'apprun';\nclass Counter extends Component {\n  state = 0;\n  view = state =&gt; &lt;div&gt;\n    &lt;h1&gt;{state}&lt;/h1&gt;\n    &lt;button $onclick={state=&gt;state-1}&gt;-1&lt;/button&gt;\n    &lt;button $onclick={state=&gt;state+1}&gt;+1&lt;/button&gt;\n  &lt;/div&gt;;\n}\n</code></pre>"},{"location":"component/#life-cycle-functions","title":"Life Cycle Functions","text":"<p>Life Cycle Functions are callback functions that AppRun calls during the component life cycle. They are mounted, rendered, and unload.</p> <pre><code>import { app, Component } from 'apprun';\n\nclass MyApp extends Component {\n  state = {};\n  view = state =&gt; &lt;div&gt;&lt;/div&gt;;\n  update = {};\n\n  //life cycle functions\n  mounted = (props, children, state) =&gt; state;\n  rendered = state =&gt; {};\n  unload = state =&gt; {};\n}\n\napp.render(document.body, &lt;MyApp /&gt;);\n</code></pre>"},{"location":"component/#mounted","title":"mounted","text":"<p>The mounted function is called after the component instance is mounted to a DOM element. The mounted function can be used to set the initialize state. <pre><code>mounted: (props: any, children: any[], state: T) =&gt; T | void;\n</code></pre></p> <p>Note: the mounted function is only called in the child component.</p> <pre><code>class Child extends Component {\n  state = {} // you can define the initial state\n  view = state =&gt; &lt;div&gt;&lt;/div&gt;\n  update = {}\n  mounted = (props, children) =&gt; { ...state, ...props } // this will be called, you can merge props into the state\n}\n\nclass Parent extends Component {\n  state = {} // you can define the initial state\n  view = state =&gt; &lt;div&gt;\n    &lt;Child /&gt;\n  &lt;/div&gt;\n  update = {}\n  mounted = () =&gt; { } // this will NOT be called when component is created using the constructor\n}\nnew Parent().start(document.body);\n</code></pre>"},{"location":"component/#rendered","title":"rendered","text":"<p>The rendered function is called after AppRun renders the result of the view function. The rendered function can be used to modify the DOM element using 3rd party libraries. <pre><code>rendered: (state: T, props?: any[]) =&gt; void;\n</code></pre></p>"},{"location":"component/#unload","title":"unload","text":"<p>The _unload function is called when the DOM element that the component is mounted to is removed or reused by other components. For example, the _unload function can be used to clean the resources created by the 3rd party libraries.</p> <pre><code>unload: (state: T) =&gt; void;\n</code></pre> <p>You can see, the component life cycle functions are useful for integrating 3rd party libraries.</p>"},{"location":"component/#html-child-components","title":"HTML Child Components","text":"<p>Unlike JSX, you can embed component classes into JSX; when using HTML string components, you will need to make a web component/custom element. Then you can embed the components.</p> <pre><code>import app from 'apprun';\nimport MyComponent from './MyComponent';\n\napp.webComponent('my-component', MyComponent);\n\nconst view = state =&gt; {\n  return `&lt;div&gt;\n    &lt;my-component /&gt;\n  &lt;/div&gt;`;\n};\napp.start('my-app', state, view);\n</code></pre>"},{"location":"create-apprun-app/","title":"Create AppRun App","text":"<p>The npm create apprun-app command line tool creates a new AppRun project. It can scaffold a new project with build tools and a development server.</p> <p>To create a project, run:</p> <pre><code>npx create-apprun-app my-app\ncd my-app\nnpm start\n</code></pre> <p>You can select one of the following project templates:</p> <pre><code>? Select a template \u203a - Use arrow-keys. Return to submit.\n    HTML/JS\n    HTML/JS - Web Component\n    Blank App\n    Signle Page App\n\u276f   AppRun Site (default)\n</code></pre> <p>You can also select a build tool:</p> <pre><code>? Select a compiler \u203a - Use arrow-keys. Return to submit.\n    esbuild\n    webpack\n\u276f   vite\n</code></pre> <p>Then, you can choose to add Jest and git repo:</p> <pre><code>? Add Jest? \u2026 No / Yes\n? Add git repo? \u203a No / Yes\n</code></pre> <p>Finally, it creates a new project for you:</p> <pre><code>Project created in:  ....../my-app\nPlease go to the project directory and run:\n\n        npm start\n\nAnd then, you can visit the project at: http://localhost:8080\n</code></pre> <p>You can read more about the project templates in the following sections.</p> <ul> <li>Single Page App</li> <li>AppRun Site</li> </ul>"},{"location":"dev-server/","title":"AppRun Dev Server Supports ESM","text":""},{"location":"dev-server/#introduction","title":"Introduction","text":"<p>We use JavaScript modules (ESM) extensively while coding nowadays. But we still cannot deploy the module-based code yet. It is because the browsers don't know how to handle global modules.  E.g., When developing applications using AppRun, we need a globe module of apprun.</p> <pre><code>import app from 'apprun'\n</code></pre> <p>The browsers don't know how to import apprun. Therefore, We still need to use JavaScript bundlers such as webpack, rollup, or parcel to bundle the modules.</p> <p>But at least now, we can use the modules to speed up the development process. Recently, the Snowpack team introduced the concept of Unbundled Development, which is to leverage modules for speeding up the development process.</p> <p>In the past, I was thinking of building a tool to convert the global modules to the modules links on unpkg after compilation.</p> <p>The npm package CDN, unpkg.com supports delivering modules for along time. We can load apprun as a module from unpkg.</p> <pre><code>import app from 'https://unpkg.com/apprun?module'\n</code></pre> <p>Now, it seems that a development server is a different and better idea. So, I forked the live-server and made a development server for AppRun.</p> <p>This post is to introduce the AppRun development server, called apprun-dev-server.</p>"},{"location":"dev-server/#apprun-dev-server","title":"apprun-dev-server","text":"<p>This is a static web server for developing JavaScript/TypeScript using ES modules following the concept of Unbundled Development.</p> <ul> <li>It serves the ES Modules from unpkg.com.</li> <li>Based on live-server, so it reloads the page automatically</li> <li>Also, it detects AppRun and can replace the module/Component while keeping the application state.</li> </ul> <p></p> <p>The best part of the apprun-dev-server is that it does NOT require any code in our components to handle the hot module replacement. Instead, it retains the component state; replaces the module; and then puts the state back. All done automatically.</p> <p>If you want to refresh the state, you can reload the page in the browser by pressing F5 (on Windows) or Command+R (on Mac).</p>"},{"location":"dev-server/#how-to-use","title":"How to Use","text":"<p>You export Component as the default module export.</p> <pre><code>import { app, Component } from 'apprun';\n\nexport default class AboutComponent extends Component {\n  state = 'About';\n  view = state =&gt; &lt;div&gt;\n    &lt;h1&gt;{state}&lt;/h1&gt;\n  &lt;/div&gt;;\n  update = {\n    '#About': state =&gt; state,\n  };\n}\n</code></pre> <p>Then, you use the Component in the main file.</p> <pre><code>import About from './About';\n\nnew About().start('my-app');\n</code></pre> <p>Then, you use a module-type script tag in HTML.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"&gt;\n  &lt;title&gt;AppRun SPA&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;script type=\"module\" src=\"/dist/main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Turn on the compiler, TypeScript, or Babel in watch mode. And then, start the apprun-dev-server using npx.</p> <pre><code>npx apprun-dev-server\n</code></pre> <p>Apprun-dev-server monitors the file changes. If the changed JavaScript files (*.js) file have global modules. Apprun-dev-server replaces the global module's references to unpkg. In the server console, if you see the file names that have some dots '......' in front, they are the files modified.</p> <p>Apprun-dev-server injects JavaScript code snippets in the index.html just like live-server. Also, Apprun-dev-server adds logic to detect AppRun and replace AppRun components.</p> <p>You can download an example app to give it a try.</p> <pre><code>npx degit yysun/apprun-esm-server my-app\n</code></pre>"},{"location":"dev-server/#configuration","title":"Configuration","text":"<p>Create a apprun-dev-server.config.js in your project:</p> <pre><code>module.exports = {\n  port: 8181, // Set the server port. Defaults to 8080.\n  host: \"0.0.0.0\", // Set the address to bind to. Defaults to 0.0.0.0 or process.env.IP.\n  root: \"public\", // Set root directory that's being served. Defaults to cwd.\n  open: false, // When false, it won't load your browser by default.\n  ignore: '', // comma-separated string for paths to ignore\n  file: \"index.html\", // When set, serve this file (server root relative) for every 404 (useful for single-page applications)\n  wait: 1000, // Waits for all changes, before reloading. Defaults to 0 sec.\n  mount: [], // Mount a directory to a route.\n  logLevel: 2, //\n}\n</code></pre>"},{"location":"dev-server/#use-with-esbuild","title":"Use with esbuild","text":"<p>The apprun-dev-server is installed when creating a project by using the <code>npm init apprun-app</code> command and selecting the `esbuild`` option.</p> <pre><code>npm init apprun-app [my-app]\n</code></pre> <p>Give it a try and send pull requests.</p> <p>https://github.com/yysun/apprun-dev-server</p>"},{"location":"directive/","title":"Directives","text":"<p>AppRun directives are syntax sugars that help simplify the code. They are custom attributes in JSX that have names starting with $. AppRun two out-of-the-box directives: $on and $bind.</p>"},{"location":"directive/#on","title":"$on...","text":"<p>The $on directive simplifies the code to convert the DOM events to AppRun events.</p>"},{"location":"directive/#publish-events","title":"Publish Events","text":"<p><pre><code>class Counter extends Component {\n  state = 0;\n  view = state =&gt; &lt;&gt;\n    &lt;h1&gt;{state}&lt;/h1&gt;\n    &lt;button $onclick='-1'&gt;-1&lt;/button&gt;\n    &lt;button $onclick='+1'&gt;+1&lt;/button&gt;\n  &lt;/&gt;;\n  update = {\n    '+1': state =&gt; state + 1,\n    '-1': state =&gt; state - 1\n  };\n}\nnew Counter().start(document.body);\n</code></pre> </p>"},{"location":"directive/#invoke-functions","title":"Invoke Functions","text":"<p>The $on directive can also invoke functions.</p> <p><pre><code>class Counter extends Component {\n  state = 0;\n  view = state =&gt; &lt;div&gt;\n    &lt;h1&gt;{state}&lt;/h1&gt;\n    &lt;button $onclick={state=&gt;state-1}&gt;-1&lt;/button&gt;\n    &lt;button $onclick={state=&gt;state+1}&gt;+1&lt;/button&gt;\n  &lt;/div&gt;;\n}\nnew Counter().start(document.body);\n</code></pre> </p>"},{"location":"directive/#bind","title":"$bind","text":"<p>The $bind directive synchronizes the HTML input value to the state. See the $bind example below.</p> <p><pre><code>const state = '';\nconst view = state =&gt; &lt;div&gt;\n  &lt;h1&gt;Hello {state}&lt;/h1&gt;\n  &lt;input autofocus $bind /&gt;\n&lt;/div&gt;;\napp.start(document.body, state, view);\n</code></pre> </p> <p>Or, you can bind to the properties of the state.</p> <p><pre><code>const state = {\n  a: 1,\n  b: 2,\n  get c() {\n    return this.a + this.b;\n  }\n};\nconst view = ({a, b, c}) =&gt; &lt;&gt;\n  &lt;input type=\"number\" $bind=\"a\" /&gt;\n  &lt;input type=\"number\" $bind=\"b\" /&gt;\n  &lt;p&gt;{a} + {b} = { c }&lt;/p&gt;\n&lt;/&gt;;\napp.start(document.body, state, view);\n</code></pre> </p>"},{"location":"directive/#custom-directive","title":"Custom directive","text":"<p>When AppRun is processing the JSX code, it publishes the $ event when it finds the custom attributes like $X. Thus, you can subscribe to the $ event to provide your directives.</p> <pre><code>app.on('$', ({key, props}) =&gt; {\n  if (key === '$animation') {\n    const value = props[key];\n    if (typeof value === 'string') {\n      props.class = \\`animated \\${value}\\`;\n    }\n  }\n});\n</code></pre>"},{"location":"directive/#animation-directive","title":"Animation directive","text":"<p>We can create the $animation directive to attach the animation classes from the animation library, animation.css. See the $animation example below.</p> <p><pre><code>// Animation Directive Using animate.css\napp.on('$', ({key, props}) =&gt; {\n  if (key === '$animation') {\n    const value = props[key];\n    if (typeof value === 'string') {\n      props.class = `animated ${value}`;\n    }\n  }\n});\n\nconst state = {\n  animation: true\n}\n\nconst start_animation = state =&gt; ({ animation: true })\nconst stop_animation = state =&gt; ({ animation: false })\n\nconst view = state =&gt; &lt;&gt;\n  &lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css\"&gt;&lt;/link&gt;\n  &lt;img $animation={state.animation &amp;&amp; 'bounce infinite'} src='../assets/logo.png' /&gt;\n  &lt;div $animation='bounceInRight'&gt;\n    &lt;button disabled={state.animation} $onclick={start_animation}&gt;start&lt;/button&gt;\n    &lt;button disabled={!state.animation} $onclick={stop_animation}&gt;stop&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/&gt;\n\napp.start(document.body, state, view);\n</code></pre> </p>"},{"location":"directive/#form-validation","title":"Form Validation","text":"<p>HTML5 Constraint Validation API simplifies client-side validation. We can use basic validation by choosing the type attribute of input elements, such as email and URL. Or we can use the pattern attribute for validation using regular expression. Also, we can use the required, maxlength, min, and max attributes.</p> <p>We can create the $validation directive to display the validation results by setting and removing the class.</p> <p><pre><code>const validate = (e) =&gt; {\n  const element = e.target;\n  element.checkValidity();\n  console.log(element.validity.valid);\n  if (element.validity.valid) {\n    element.classList.remove('is-invalid');\n  } else {\n    element.classList.add('is-invalid');\n  }\n}\n\napp.on('$', ({ key, props }) =&gt; {\n  if (key === '$validate') {\n    const event = props[key];\n    props['oninput'] = validate;\n  }\n});\n\n\nconst signIn = (state, e) =&gt; {\n  e.preventDefault();\n  alert('form submitted')\n}\n\nconst view = ({name}) =&gt; &lt;&gt;\n  &lt;style&gt;{`.is-invalid { border: 2px solid red; color: red }`}&lt;/style&gt;\n  &lt;form autocomplete=\"off\" $onsubmit=\"signIn\"&gt;\n    &lt;p&gt;\n    &lt;label for=\"name\" autocomplete=\"off\"&gt;Enter an name (letters only): &lt;/label&gt;\n    &lt;input $validate type=\"text\" name=\"name\" required pattern=\"[A-Za-z]+\"/&gt;\n    &lt;/p&gt;\n    &lt;p&gt;\n    &lt;label for=\"email\" autocomplete=\"off\"&gt;Enter a email: &lt;/label&gt;\n    &lt;input $validate type=\"email\" name=\"email\" required /&gt;\n    &lt;/p&gt;\n    &lt;p&gt;\n    &lt;label for=\"url\" autocomplete=\"off\"&gt;Enter an URL: &lt;/label&gt;\n    &lt;input $validate type=\"url\" name=\"url\" required /&gt;\n    &lt;/p&gt;\n    &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n  &lt;/form&gt;\n  &lt;div&gt;{name}&lt;/div&gt;\n&lt;/&gt;;\n\napp.start(document.body, {}, view, {signIn});\n</code></pre> </p>"},{"location":"esm/","title":"Use AppRun in the browser","text":""},{"location":"esm/#get-apprun-from-cdn","title":"Get AppRun from CDN","text":"<p>You can use AppRun directly from the unpkg.com CDN:</p> <pre><code>&lt;script src=\"https://unpkg.com/apprun/dist/apprun-html.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\n  const view = state =&gt; `&lt;div&gt;${state}&lt;/div&gt;`;\n  app.start(document.body, 'hello AppRun', view);\n&lt;/script&gt;\n</code></pre>"},{"location":"esm/#use-the-esm-version","title":"Use the ESM version","text":"<pre><code>&lt;script type=\"module\"&gt;\n  import { app } from 'https://unpkg.com/apprun/dist/apprun-html.esm.js';\n  const view = state =&gt; `&lt;div&gt;${state}&lt;/div&gt;`;\n  app.start(document.body, 'hello AppRun ESM', view);\n&lt;/script&gt;\n</code></pre>"},{"location":"esm/#use-other-libraries","title":"Use Other Libraries","text":""},{"location":"esm/#lit-html","title":"lit-html","text":"<p><pre><code>&lt;html&gt;\n&lt;body&gt;\n  &lt;script type=\"module\"&gt;\n    import { app } from 'https://esm.run/apprun';\n    import { html, render } from 'https://esm.run/lit-html';\n\n    // use lit-html\n    app.use_render(render);\n    class Counter extends Component {\n      state = 0;\n      view = state =&gt; {\n        return html`&lt;div&gt;\n          &lt;h1&gt;${state}&lt;/h1&gt;\n          &lt;button @click=${()=&gt;this.run(\"-1\")}&gt;-1&lt;/button&gt;\n          &lt;button @click=${()=&gt;this.run(\"+1\")}&gt;+1&lt;/button&gt;\n        &lt;/div&gt;`;\n      };\n      update = {\n        '+1': state =&gt; state + 1,\n        '-1': state =&gt; state - 1\n      };\n    }\n    new Counter().start(document.body);\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </p>"},{"location":"esm/#htm","title":"htm","text":"<p><pre><code>&lt;html&gt;\n&lt;body&gt;\n  &lt;script type=\"module\"&gt;\n    import { app } from 'https://unpkg.com/apprun/dist/apprun.esm.js';\n    import { html, render } from 'https://unpkg.com/htm/preact/standalone.module.js';\n    app.use_render(render);\n\n    const add = (state, delta) =&gt; state + delta;\n    const view = state =&gt; html`&lt;div&gt;\n      &lt;h1&gt;${state}&lt;/h1&gt;\n      &lt;button onClick=${() =&gt; app.run('-1')}&gt;-1&lt;/button&gt;\n      &lt;button onClick=${() =&gt; app.run('+1')}&gt;+1&lt;/button&gt;\n    &lt;/div&gt;\n    `;\n    const update = {\n      '+1': state =&gt; state + 1,\n      '-1': state =&gt; state - 1\n    };\n    app.start(document.body, 0, view, update);\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </p>"},{"location":"esm/#installation","title":"Installation","text":"<p>AppRun is distributed on npm. To get it, run:</p> <pre><code>npm install apprun\n</code></pre>"},{"location":"event-pubsub/","title":"Event Pub-Sub","text":"<p>Event publication and subscription, also known as event emitter, is a commonly used pattern in JavaScript programming.</p> <ul> <li>Publishing an event means raising an event for some other code to handle. Publishing an event is also referred to as firing an event or triggering an event.</li> <li>Subscribing an event means registering an event handler function to the event. The event handler function executes when the correspondent event</li> </ul> <p>At the core, AppRun is an event pub-sub system.</p>"},{"location":"event-pubsub/#event-life-cycle","title":"Event Life Cycle","text":"<p>When an AppRun event is published, the following steps take place:</p> <ol> <li>AppRun dispatches the events to the event handlers defined in the update along with the current state.</li> <li>The event handlers create a new state based on the current state.</li> <li>AppRun passes the new state to the view function.</li> <li>The view function creates HTML or a Virtual DOM.</li> <li>AppRun renders the HTML/Virtual DOM to the screen</li> <li>AppRun calls the optional rendered function to complete the AppRun event life cycle.</li> </ol> <p></p> <p>AppRun Event Life Cycle connects the state, view, and update (event handlers) together. Take a look at the Counter example again.</p> <p><pre><code>const state = 0;\nconst view = state =&gt; {\n  return `&lt;div&gt;\n    &lt;h1&gt;${state}&lt;/h1&gt;\n    &lt;button onclick='app.run(\"-1\")'&gt;-1&lt;/button&gt;\n    &lt;button onclick='app.run(\"+1\")'&gt;+1&lt;/button&gt;\n  &lt;/div&gt;`;\n};\nconst update = {\n  '+1': state =&gt; state + 1,\n  '-1': state =&gt; state - 1\n};\napp.start(document.body, state, view, update);\n</code></pre> </p> <p>When one of the buttons is clicked, it publishes AppRun event +1 or -1. The event handlers increase or decrease the state and return a new state. The view function creates the virtual DOM using the new state. Finally, AppRun renders the virtual DOM.</p>"},{"location":"event-pubsub/#event-scope","title":"Event Scope","text":"<p>In AppRun global application mode, events are global events, which means that events are published and handled globally by all modules.</p> <p>In AppRun components, events are limited within the component's local scope. Local events are only available inside the components.</p> <p>Note</p> <p>app.run publishes global events this.run publishes local events</p>"},{"location":"event-pubsub/#event-directives","title":"Event Directives","text":"<p>In addition to using app.run and this.run for publishing events</p> <p>AppRun Directives provides syntax sugar to simplify event publishing.</p>"},{"location":"event-pubsub/#jsx-directives","title":"JSX Directives","text":"<p>The directives are special HTML attributes with names starting with $, such as $onclick. They are extensions to the JSX syntax to simplify the JSX or add extra features.</p> <p>We can use $onclick to simplify the syntax of publishing AppRun events from</p> <pre><code>&lt;button onclick={()=&gt;app.run('+1')}&gt;+1&lt;/button&gt;\n</code></pre> <p>to We use tuples for passing event parameters.</p> <pre><code>&lt;button $onclick={['add', +1]}&gt;+1&lt;/button&gt;\n</code></pre> <p>Also, the $onclick directive can call the event directly.</p> <p><pre><code>const add = count =&gt; count + 1;\nconst view = count =&gt; &lt;button $onclick={add}&gt;\n  Clicks: {count}\n&lt;/button&gt;;\napp.start(document.body, 0, view);\n</code></pre> </p> <p>You can see, because there are no events in this case, we don't need the update object anymore.</p>"},{"location":"event-pubsub/#lit-html-directive","title":"lit-html Directive","text":"<p>lit-html is the DOM rendering technology that lets us write HTML templates using string literals.</p> <p>Following the idea of using the JSX event directive what can we do similar thing with lit-html?</p> <p>The good news is that lit-html also has the directive concept to bring the event directive to lit-html. So the directive for lit-html is called run.</p> <p>The example below shows how to use the run directive to trigger AppRun events. Also, similar to the JSX event directives, the run directive can call the event lifecycle directly.</p> <p><pre><code>const add = (state, delta) =&gt; state + delta;\nconst view = state =&gt; {\n  return html`&lt;div&gt;\n    &lt;h1&gt;${state}&lt;/h1&gt;\n      &lt;button @click=${run('add', -1)}&gt;-1&lt;/button&gt;\n      &lt;button @click=${run('add', +1)}&gt;+1&lt;/button&gt;\n    &lt;/div&gt;`;\n};\napp.start(document.body, 0, view, {add});\n</code></pre> </p> <p>The run directive will:</p> <ul> <li>Call the add function</li> <li>Call the view function</li> <li>Render the HTML element (document.body)</li> </ul>"},{"location":"event-pubsub/#asynchronous-events","title":"Asynchronous Events","text":"<p>In the service API-oriented applications, the state is created asynchronous operations. e.g., getting remote data from the server.</p> <p>It is easy to handle asynchronous operations in the AppRun event handlers. We only need to add the async keyword in front of the event handler and call the functions that return a Promise object with the await keyword.</p> <p><pre><code>const state = {};\nconst view = state =&gt; &lt;&gt;\n  &lt;div&gt;&lt;button $onclick=\"fetchComic\"&gt;fetch ...&lt;/button&gt;&lt;/div&gt;\n  {state.loading &amp;&amp; &lt;div&gt;loading ... &lt;/div&gt;}\n  {state.comic &amp;&amp; &lt;img src={state.comic.img}/&gt;}\n&lt;/&gt;;\nconst update = {\n  'loading': (state, loading) =&gt; ({...state, loading }),\n  'fetchComic': async _ =&gt; {\n    app.run('loading', true);\n    const response = await fetch('https://my-xkcd-api.glitch.me');\n    const comic = await response.json();\n    return {comic};\n  }\n};\napp.start(document.body, state, view, update);\n</code></pre> </p>"},{"location":"event-pubsub/#use-events-for-everything","title":"Use Events for Everything","text":"<p>Web programming is event-driven. All we have to do is to convert DOM events to AppRun events to trigger the AppRun event life cycle.</p> <pre><code>DOM events =&gt; AppRun Events =&gt; (current state) =&gt; Update =&gt; (new state) =&gt; View =&gt; (HTML/Virtual DOM) =&gt; Render Web Page\n</code></pre> <p>Events are not only for handling user interactions. They are used for everything in AppRun.</p> <ul> <li>Routing is through events.</li> <li>Directives are through events.</li> </ul>"},{"location":"event-pubsub/#event-typing","title":"Event Typing","text":"<p>Events can be strongly typed using TypeScript Discriminated Unions. If you are interested, please read this post: strong-typing.</p> <p></p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#npm","title":"npm","text":"<p>AppRun is distributed on npm. To get it, run:</p> <pre><code>npm install apprun\n</code></pre>"},{"location":"installation/#create-apprun-app","title":"Create AppRun App","text":"<p>The npm create apprun-app command line tool creates a new AppRun project. It can scaffold a new project with build tools and a development server.</p> <p>To create a project, run:</p> <pre><code>npx create-apprun-app my-app\ncd my-app\nnpm start\n</code></pre>"},{"location":"notebooks/","title":"Notebooks","text":"<p>A notebook interface (also called a computational notebook) is a virtual notebook environment used for literate programming -- wikipedia</p> <p>Notebooks have a series of cells containing text, code, and visualizations.</p>"},{"location":"notebooks/#observable","title":"Observable","text":"<p>Observable is a website for online JavaScript notebooks.</p> <p>You can use AppRun on the Observable site by following the steps:</p> <ol> <li>Import app, html from @yysun/apprun</li> <li>Create the state, view, and update</li> <li>Create a div</li> <li>Start an app on the div</li> </ol> <p></p> <p>Visit https://observablehq.com/@yysun?tab=notebooks for more examples.</p>"},{"location":"notebooks/#net-interactive-notebooks","title":".NET Interactive Notebooks","text":"<p>With the .NET Interactive Notebooks extension for Visual Studio Code installed, we can run the .NET Interactive notebooks in Visual Studio Code. The .NET Interactive notebooks support C#, F#, HTML, JavaScript, Power Shell, and even SQL.</p> <p>You use AppRun in the .NET Interactive notebooks by following the steps:</p> <ol> <li>Import AppRun</li> <li>Create a div</li> <li>Create the state, view, and update</li> <li>Start an app on the div</li> </ol> <p>Download the sample notebook.</p> <p></p>"},{"location":"react/","title":"Use AppRun with React","text":"<p>React is a popular JavaScript library for building user interfaces. Using AppRun and React in conjunction is one of the best ways to build a web app. Here's why you should consider using AppRun with React:</p> <ul> <li> <p>Simplified State Management: React often requires additional libraries like Hooks or Redux for state management. AppRun's state management system is easier use. It can reduce complexity and make your application easier to build and maintain\u200b.</p> </li> <li> <p>Event-Driven Routing: AppRun's routing system is event-based, treating route changes as events just like any other user interaction. This makes routing in single-page applications (SPA) straightforward and consistent with other app logic. It is a pertect replacement of the React Router or similar tools\u200b\u200b.</p> </li> <li> <p>Seamless JSX Integration: AppRun supports JSX, the same syntax used by React, which means you can use React as the rendering engine for AppRun components. This allows you to leverage React's powerful rendering capabilities and its vast ecosystem\u200b\u200b.</p> </li> </ul> <p>You can either create an React app and add AppRun to it or create an AppRun app and add React. Here is how you can do it:</p>"},{"location":"react/#step-1-installation","title":"Step 1, Installation","text":"<pre><code>npm create vite@latest my-app -- --template react\ncd my app\nnpm i apprun\n</code></pre> <p>or</p> <pre><code>npm create apprun-app my-app\ncd my-app\nnpm i react react-dom\n</code></pre>"},{"location":"react/#step-2-use-reacts-rendering-function","title":"Step 2, Use React's Rendering Function","text":"<p>Replace AppRun's app.render function with React's render function.</p>"},{"location":"react/#for-react-18","title":"For React 18","text":"<pre><code>import { createRoot } from 'react-dom/client'\nimport app from 'apprun';\napp.use_react(createRoot);\n</code></pre>"},{"location":"react/#for-react-17-and-earlier","title":"For React 17 and earlier","text":"<pre><code>import { render } from 'react-dom'\nimport app from 'apprun';\napp.use_render(render);\n</code></pre>"},{"location":"react/#for-preact","title":"For Preact","text":"<pre><code>import { render } from 'preact'\nimport app from 'apprun';\napp.use_render(render);\n</code></pre> <p>Note</p> <p>Preact's render function has less restriction than React's. We can take advantage of AppRun's unique custom directives ($on, $bind) for handling events and data binding\u200b\u200b.</p> <p>Usually you replace the app.render function in the main.tsx file once.</p> <pre><code>import \"antd/dist/reset.css\"\nimport './index.css'\n\nimport { createRoot } from 'react-dom/client'\nimport { flushSync } from 'react-dom';\nimport app from 'apprun';\nimport App from './App'\nimport Home from './Home';\nimport About from './About';\nimport Contact from './Contact';\n\n// Use React DOM to render components\napp.use_react(createRoot);\n\n// Render the App component to create page layout\nconst root = document.getElementById('root');\nflushSync(() =&gt; app.render(root, &lt;App /&gt;));\n\n// Load page components\nnew Contact().mount('my-app');\nnew About().mount('my-app');\nnew Home().start('my-app');\n</code></pre>"},{"location":"react/#step-3-use-react-jsx-and-components","title":"Step 3, Use React JSX and Components","text":"<p>Write your AppRun components using React's JSX and Component in the view function.</p> <pre><code>import { Component } from 'apprun';\nimport { Button } from 'antd';\n\nexport default class ContactComponent extends Component {\n  state = 0;\n\n  view = state =&gt; (\n    &lt;&gt;\n      &lt;h1&gt;{state}&lt;/h1&gt;\n      &lt;Button onClick={() =&gt; this.run('add', -1)}&gt;-1&lt;/Button&gt;\n      &lt;Button onClick={() =&gt; this.run('add', +1)}&gt;+1&lt;/Button&gt;\n      &lt;div&gt;&lt;p/&gt;(component)&lt;/div&gt;\n    &lt;/&gt;\n  );\n\n  update = {\n    add: (state, num) =&gt; state + num,\n    '#Contact': state =&gt; state,\n  };\n}\n</code></pre> <p>Note</p> <p>The React JSX syntax is the mostly compatible with AppRun's JSX syntax. But, you need to remember React uses onClick instead of onclick.</p>"},{"location":"react/#example","title":"Example","text":"<p>By using React and AppRun together, you can build a powerful web application with AppRun's clean architecture and React component libraries like Ant Design..</p> <p>Here is an example: https://yysun.github.io/apprun-antd-demo-js</p> <p>Source: https://github.com/yysun/apprun-antd-demo-js</p>"},{"location":"react/#conclusion","title":"Conclusion","text":"<p>Whether you add AppRun to your React app or add React to your AppRun app, you can get the best of both worlds.</p>"},{"location":"reactivity/","title":"Reactivity","text":"<p>title: Reactivity in AppRun published: true description: This post describes the reactive implementation in AppRun tags: #apprun #vue #svelte #angular</p>"},{"location":"reactivity/#introduction","title":"Introduction","text":"<p>Reactivity has been a hot buzzword for modern JavaScript UI frameworks in the past few years. Angular, Vue, and Svelte all have reactivity built-in. They are famous and popular because of their reactivity features.</p> <p>Reactivity means that the changed application state will automatically reflect in the DOM.</p> <p>Don't be confuse the reactivity with another buzz word, reactive programming. Reactive programming is programming with asynchronous data streams. I will have another post to explain reactive programming.</p> <p>Reactivity is related to the data binding concept. Data binding is the process that establishes a connection between the application state and the application UI. There are two major types of data binding: one-way bing and two-binding.</p> <ul> <li> <p>One-way binding means that changes in the application state cause changes to the application UI.</p> </li> <li> <p>Two-way binding means that either application state or application UI changes (for example, with input elements) automatically update the other.</p> </li> </ul> <p>The reactivity also applies to the state object properties. E.g., if there is a person object with the properties of first-name, last-name, and full-name, we want the full-name property to be reactive to the other two name properties.</p> <p>With the reactivity concept clarified, let's see how we can have reactivity in AppRun.</p>"},{"location":"reactivity/#one-way","title":"One-Way","text":"<p>Many frameworks use the concept of \"variable assignments trigger UI updates.\" E.g., Vue wires up the application state objects with a change detection mechanism to become a view model or Proxy. Then you can modify the view model to trigger the UI update. Svelte has a compiler to inject change detection around your application state object. You can also modify the state to trigger the UI update.</p> <p>Unlike other frameworks, AppRun uses the events to trigger UI updates following the event-driven web programming model naturally. During an AppRun event lifecycle:</p> <ul> <li>AppRun gives you the current state for you to create a new state</li> <li>AppRun calls your view function to create a virtual</li> <li>AppRun renders the virtual DOM if it is not null.</li> </ul> <p>You can feel the Hollywood Principle (Don't call us. We call you.) here, which usually means things are loosely coupled. We provide code pieces. The framework calls them when needed.</p> <p>In the example below, the AppRun $onclick directive calls the event handler, then calls the view function, and then renders the virtual DOM.</p> <p><pre><code>const view = state =&gt; &lt;div&gt;\n  &lt;h1&gt;{state}&lt;/h1&gt;\n  &lt;button $onclick={state =&gt; state - 1}&gt;+1&lt;/button&gt;\n  &lt;button $onclick={state =&gt; state + 1}&gt;+1&lt;/button&gt;\n&lt;/div&gt;;\n\napp.start(document.body, 0, view)\n</code></pre> </p>"},{"location":"reactivity/#two-way-binding","title":"Two-Way Binding","text":"<p>AppRun $bind directive can update the state properties automatically when used with the input elements and the textarea element. It looks similar to Angular's ngModel, Vue' v-model, and Svelte's bind:value syntax. However, Angular, Vue, and Svelte have invented their own proprietary template language/syntax that you need to learn. AppRun uses the JSX that React also uses.</p> <p><pre><code>const view = state =&gt; &lt;&gt;\n  &lt;div&gt;{state.text}&lt;/div&gt;\n  &lt;input $bind=\"text\" placeholder=\"type something here ...\"/&gt;\n&lt;/&gt;\napp.start(document.body, {}, view)\n</code></pre> </p>"},{"location":"reactivity/#reactive-state","title":"Reactive State","text":"<p>The state properties' reactivity is not a problem that the UI frameworks are to solve. But if the UI frameworks wrap or change the original state objects, they have to solve the reactivity problems. E.g., Vue uses the computed object. Svelte uses the reactive-declarations, the famous $: sign.</p>"},{"location":"reactivity/#property-getter","title":"Property Getter","text":"<p>Like in languages like Java and C#, JavaScript has object property getter, which we can use to compute the property values dynamically.</p> <pre><code>const state = ({\n  a: 1,\n  b: 2,\n  get c() {\n    return this.a + this.b;\n  }\n})\n</code></pre> <p>Binding to the state object properties is straightforward.</p> <p><pre><code>// Reactivity - getter\nconst state = {\n  a: 1,\n  b: 2,\n  get c() {\n    return this.a + this.b;\n  }\n};\nconst view = ({a, b, c}) =&gt; &lt;&gt;\n  &lt;input type=\"number\" $bind=\"a\" /&gt;\n  &lt;input type=\"number\" $bind=\"b\" /&gt;\n  &lt;p&gt;{a} + {b} = { c }&lt;/p&gt;\n&lt;/&gt;;\napp.start(document.body, state, view);\n</code></pre> </p>"},{"location":"reactivity/#es2015-proxy","title":"ES2015 Proxy","text":"<p>The Proxy is used to define custom behavior for fundamental operations (e.g., property lookup, assignment, enumeration, function invocation, etc.).</p> <p>Proxies enable you to intercept and customize operations performed on objects (such as getting properties). They are a metaprogramming feature. - from Metaprogramming with proxies</p> <p>To create a Proxy, we create a handler first. Then, we combine the object proxied with the handler.</p> <pre><code>const handler = ({\n  get: (target, name) =&gt; {\n    const text = target.text || '';\n    switch (name) {\n      case 'text': return target.text;\n      case 'characters': return text.replace(/\\s/g, '').length;\n      case 'words': return !text ? 0 : text.split(/\\s/).length;\n      case 'lines': return text.split('\\n').length;\n      default: return null\n    }\n  }\n})\n\nconst state = new Proxy(\n  { text: \"let's count\" },\n  handler\n)\n</code></pre> <p>Proxy has almost no barrier to use. Anywhere accepts objects can use Proxy. For example, AppRun can take a state with Proxy.</p> <p><pre><code>// Reactivity - Proxy\nconst handler = {\n  get: (target, name) =&gt; {\n    const text = target.text || '';\n    switch (name) {\n      case 'text': return target.text;\n      case 'characters': return text.replace(/\\s/g, '').length;\n      case 'words': return !text ? 0 : text.split(/\\s/).length;\n      case 'lines': return text.split('\\n').length;\n      default: return null\n    }\n  }\n};\nconst state = new Proxy(\n  { text: \"let's count\" },\n  handler\n);\nconst view = state =&gt; &lt;div&gt;\n  &lt;textarea rows=\"10\" cols=\"30\" $bind=\"text\"&gt;&lt;/textarea&gt;\n  &lt;div&gt;chars: {state.characters} words: {state.words} lines: {state.lines}&lt;/div&gt;\n  &lt;pre&gt;{state.text}&lt;/pre&gt;\n&lt;/div&gt;;\napp.start(document.body, state, view);\n</code></pre> </p> <p>I like Proxy because it takes the property value calculation logic out of the state objects. As a result, the proxy handler is much easier to test and maintain. On the other hand, the state objects stay lean. I want the state to act like the data transfer object (DTO) in traditional multi-layered application architecture, where the DTO is an object that carries data between logical and physical layers.</p>"},{"location":"reactivity/#conclusion","title":"Conclusion","text":"<p>AppRun has full reactivity support that provides us the one-way and two-way data binding and the reactive state. Thus, we only need to use the native JavaScript/TypeScript features. Furthermore, AppRun does not require you to learn a new language or a new templating syntax.</p>"},{"location":"resources/","title":"Books and Resources","text":""},{"location":"resources/#book-about-apprun","title":"Book About AppRun","text":"<p>AppRun book published by Apress.</p> <p></p> <p>Order from Amazon</p>"},{"location":"resources/#blogs-and-demos","title":"Blogs and Demos","text":"<ul> <li>https://dev.to/@yysun</li> <li>https://glitch.com/@yysun</li> <li>https://observablehq.com/@yysun</li> <li>https://apprun.js.org/#play</li> </ul>"},{"location":"resources/#posts","title":"Posts","text":"<ul> <li> <p>All the Ways to Make a Web Component - May 2021 Update</p> </li> <li> <p>A Real-World Comparison of Front-End Frameworks with Benchmarks 2019 Update (2019)</p> </li> <li> <p>A Real-World Comparison of Front-End Frameworks with Benchmarks 2018 Update (2018)</p> </li> <li> <p>A Real-World Comparison of Front-End Frameworks with Benchmarks (2017)</p> </li> </ul>"},{"location":"resources/#performance-benchmark","title":"Performance Benchmark","text":"<p>AppRun has also joined the js-framework-benchmark project. You can see its performance results compared to other frameworks and libraries.</p>"},{"location":"routing/","title":"Routing","text":"<p>Routing in AppRun is event-driven. Therefore, handling routing using events is straightforward.</p>"},{"location":"routing/#routing-event","title":"Routing Event","text":"<p>AppRun router detects the hash changes in the URL (by listening to the window's onpopstate event) and publishes the AppRun events using the hash as the event name. Components subscribe to the routing events.</p> <p>E.g., when the URL in the browser address bar becomes http://..../#counter, it triggers the #counter event. The Counter component reacts to the #counter and renders itself to the screen.</p> <p>That's it. There is no other code for routing.</p>"},{"location":"routing/#unhandled-routes","title":"Unhandled Routes","text":"<p>When the AppRun router triggers an AppRun event with no listener for the route, the router will automatically generate a ROUTER_404_EVENT AppRun event giving the application a chance to degrade gracefully by, perhaps, displaying a 404 page. To bind to this event, here are a few examples of things you can do:</p> <pre><code>import app, { Component, ROUTER_404_EVENT } from 'apprun';\n\n// Generate an error message when there's no handler for a URL.\napp.on(ROUTER_404_EVENT, (url, ..._rest) =&gt; console.error('No event handler for', url));\n\n// Alternatively, create a component that will display a message.\nclass NoRouteComponent extends Component {\n  state = {};\n\n  view = (state) =&gt; {\n    return &lt;&gt;&lt;h1&gt;PAGE NOT FOUND! WE SUCK!&lt;/h1&gt;&lt;/&gt;\n  }\n\n  // Handle the \"no route found\" events with this component\n  update = {\n    [ROUTER_404_EVENT]: state =&gt; state\n  }\n}\n\nnew NoRouteComponent().mount( on some element );\n</code></pre>"},{"location":"routing/#pretty-links","title":"Pretty Links","text":"<p>If you would prefer to use pretty links (i.e., non-hash links) and have HTML5 browser history, then you can implement a new router yourself or use the pretty router from the apprun-router package. This router also handles unknown routes via the ROUTER_404_EVENT and has a few other goodies to make life easier.</p>"},{"location":"routing/#replacing-default-router","title":"Replacing Default Router","text":"<p>Replacing AppRun's default router couldn't be easier. Just overwrite app.route, and you're off to the races. You'll also want to bind to the popstate events and trigger the first URL event (via the DOMContentLoaded event handler in the code example below):</p> <pre><code>// A simplistic but not great router.\nfunction newRouter(url: string) {\n  app.run(url);\n  app.run(ROUTER_EVENT, url);\n}\n\n// Kick off the first URL event when the DOM is loaded.\ndocument.addEventListener(\"DOMContentLoaded\", () =&gt; {\n  window.onpopstate = app[\"route\"](location.pathname, true);\n  newRouter(location.pathname);\n});\n\napp[\"route\"] = newRouter;\n</code></pre>"},{"location":"showcase/","title":"Showcase","text":"<p>This page shows a few public applications built with AppRun.</p>"},{"location":"showcase/#conduit","title":"Conduit","text":"<ul> <li>Project: https://github.com/gothinkster/apprun-realworld-example-app</li> </ul> conduit conduit          An interactive learning project from Thinkster. Code &amp; design licensed         under MIT."},{"location":"showcase/#hacker-news-pwa","title":"Hacker-News PWA","text":"<ul> <li>Project: https://github.com/yysun/apprun-hn</li> </ul> AppRun - HN"},{"location":"showcase/#todomvc","title":"TodoMVC","text":"<ul> <li>Author: https://github.com/samsondav</li> <li>Project: https://github.com/samsondav/todomvc-apprun</li> </ul> <p>Double-click to edit a todo</p> <p>Created by Sam Davies</p> <p>Powered by AppRunJS</p> <p>Part of TodoMVC</p> <p></p>"},{"location":"spa/","title":"Single Page Apps","text":""},{"location":"spa/#create-project","title":"Create Project","text":"<p>You can initialize a project using the <code>npm create apprun-app</code> command and select the <code>Single Page App</code> template.</p> <pre><code>npm create apprun-app [my-app]\n</code></pre>"},{"location":"spa/#spa-architecture","title":"SPA Architecture","text":"<p>AppRun SPA usually includes an HTML file, the main program that renders the screen layout, and page components that render the pages.</p> <pre><code>.\n\u251c\u2500 dist/\n\u251c\u2500 src/\n\u2502  \u251c\u2500 About.tsx\n\u2502  \u251c\u2500 Contact.tsx\n\u2502  \u251c\u2500 Home.tsx\n\u2502  \u251c\u2500 Layour.tsx\n\u2502  \u2514\u2500 main.tsx\n\u2514\u2500 index.html\n</code></pre> <p>Example of the <code>index.html</code> file:</p> <pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"&gt;\n  &lt;title&gt;AppRun SPA&lt;/title&gt;\n&lt;body&gt;\n  &lt;div id=\"main\"&gt;&lt;/div&gt;\n  &lt;script src=\"dist/main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Example of the <code>main.tsx</code> file:</p> <pre><code>import Home from './Home';\nimport About from './About';\nimport Contact from './Contact';\nimport Layout from './Layout';\n\nnew Layout().start(document.getElementById('main'));\nconst element = document.getElementById('my-app');\nnew Home().start(element);\nnew About().mount(element);\nnew Contact().mount(element);\n</code></pre> <p></p> <p>AppRun SPA uses the events to route user interaction to the components. Treating routing like other web events is the smart idea of AppRun. All web events are unified under the event pub-sub pattern. Routing does not require special treatment.</p>"},{"location":"spa/#dynamic-component-loading","title":"Dynamic Component Loading","text":"<p>AppRun components are modularized using the ECMAScript module standard. We can import the modules statically and dynamically. We can also use the native module from modern browsers.</p> <pre><code>import app from 'apprun';\nimport Layout from './Layout';\n\nnew Layout().start(document.getElementById('main'));\n\napp.on('#,#home', async () =&gt; {\n  const module = await import('./home');\n  new module.default().mount(element);\n});\n\napp.on('#about', async () =&gt; {\n  const module = await import('./about');\n  new module.default().mount(element);\n});\n\napp.on('#contact', async () =&gt; {\n  const module = await import('./contact');\n  new module.default().mount(element);\n})\n</code></pre>"},{"location":"ssr/","title":"Server-Side Rendering","text":"<p>AppRun is a front-end library for developing SPA. It also supports rendering the SPAs on the server-side, just like other frameworks. Furthermore, it also allows us to make existing traditional server-side rendered applications into SPAs. Thus, AppRun can make many existing applications built using the server-side model-view-control (MVC) architecture become SPAs quickly.</p>"},{"location":"ssr/#spa-to-ssr","title":"SPA to SSR","text":"<p>AppRun is isomorphic/universal. AppRun components can render on the client-side and on the server-side using the AppRun server-side view engine.</p> <p>Included in the SSR AppRun application example, there are:</p> <ul> <li>The express.js server application (server.ts),</li> <li>The site layout (components/layout.tsx),</li> <li>The AppRun components (components/*.tsx)</li> <li>The client-side application (/public/spa.js).</li> </ul> <p>You can run the application on @glitch, https://apprun-ssr.glitch.me.</p>"},{"location":"ssr/#ssr-to-spa","title":"SSR to SPA","text":"<p>Please read this post, Making ASP.NET Core MVC Apps into Single Page Apps using AppRun</p> <p></p>"},{"location":"state-management/","title":"State Management","text":"<p>The State, one of three main parts of the AppRun architecture, plays an essential role in the AppRun event lifecycle. It is the equivalent of the Model of Elm architecture. Elm defines the Model as the application state. Modal and State are two names of the same thing. Therefore, they are interchangeable in the AppRun architecture. Most of the time, we use the term State in AppRun.</p> <p>The State is the application state at any given time of your application. The State is the data flow between Update and View. It acts as the data transfer object (DTO) in traditional multilayered application architecture, where the DTO is an object that carries data between logical and physical layers.</p> <p>The benefit of using events and DTO like the state is that there are no dependencies between the view and update (event handlers). Thus, it makes the AppRun applications easier to develop, test, and maintain. You can get more information about unit testing later.</p>"},{"location":"state-management/#initial-state","title":"Initial State","text":"<p>We only need to define the initial state. The initial state is an immutable constant. AppRun manages the state through the event lifecycle.</p> <p></p>"},{"location":"state-management/#asynchronous-state","title":"Asynchronous State","text":"<p>We can define the initial state as a function. And even an asynchronous function to initialize the state.</p> <p><pre><code>// Init State as an Async Function\nconst state = async () =&gt; {\n  const response = await fetch('https://my-xkcd-api.glitch.me');\n  const comic = await response.json();\n  return { comic };\n};\nconst view = state =&gt; &lt;&gt;\n  { state.comic &amp;&amp; &lt;img src={ state.comic.img } /&gt;}\n&lt;/&gt;;\napp.start(document.body, state, view);\n</code></pre> </p>"},{"location":"state-management/#state-history","title":"State History","text":"<p>The state can be stored in state history by AppRun. Once the state history is enabled, we can travel through the history back and forth to get the previous and next state. See the sample below.</p> <p><pre><code>const state = [];\n\nconst Counter = ({num, idx}) =&gt; (\n  &lt;div&gt;\n    &lt;h1&gt;{num}&lt;/h1&gt;\n    &lt;button $onclick={[\"-1\", idx]}&gt;-1&lt;/button&gt;\n    &lt;button $onclick={[\"+1\", idx]}&gt;+1&lt;/button&gt;\n    &lt;button $onclick={[\"remove-counter\", idx]}&gt;x&lt;/button&gt;\n  &lt;/div&gt;\n);\n\nconst CounterList = ({counters}) =&gt; counters.map((num, idx) =&gt;\n  &lt;Counter num={num} idx={idx} /&gt;\n);\n\nconst view = (state) =&gt; {\n  return (\n  &lt;div&gt;\n    &lt;div&gt;\n      &lt;button $onclick=\"history-prev\"&gt; &amp;lt;&amp;lt; &lt;/button&gt;\n      &lt;button $onclick=\"history-next\"&gt; &amp;gt;&amp;gt; &lt;/button&gt;\n      &lt;button $onclick=\"add-counter\"&gt;add counter&lt;/button&gt;\n      &lt;button $onclick={[\"remove-counter\", state.length-1]}\n        disabled={state.length &lt;= 0}&gt;remove counter&lt;/button&gt;\n    &lt;/div&gt;\n    &lt;br/&gt;\n    &lt;CounterList counters={state} /&gt;\n  &lt;/div&gt;);\n};\n\nconst update = {\n  'add-counter': (state) =&gt; [...state, 0],\n  'remove-counter': (state, idx) =&gt; [\n     ...state.slice(0, idx),\n     ...state.slice(idx + 1)\n   ],\n  '+1': (state, idx) =&gt; [\n    ...state.slice(0, idx),\n    state[idx] + 1,\n    ...state.slice(idx + 1)\n  ],\n  '-1': (state, idx) =&gt; [\n    ...state.slice(0, idx),\n    state[idx] - 1,\n    ...state.slice(idx + 1)\n  ]\n};\n\napp.start(document.body, state, view, update, {history: true});\n</code></pre> </p> <p>Although it is effortless to enable the AppRun state history, the caveat must be immutable. Because the AppRun state history stores the references to the states, if we have modified the state directly, each state stored in the state history refers to the same state, which is always the value of the last change. Thus, the time travel back and forward will not work. Therefore, the fundamental concept of using state history is to make the state immutable.</p>"},{"location":"strong-typing/","title":"Strong Typing","text":"<p>From the AppRun architecture and AppRun event life cycle, we can see two places that require strong typing: state and event names.</p> <ul> <li>The initial state and the state passed between the view function and event handlers</li> <li>The event names for publishing and subscribing to Apprun events</li> </ul> <p></p>"},{"location":"strong-typing/#strong-typing-of-state","title":"Strong Typing of\u00a0State","text":"<p>The state is used in the view function and in the update(event handlers). We can make the state strong typed in the view function and in the update.</p>"},{"location":"strong-typing/#typed-view","title":"Typed View","text":"<p>First, we can make the state used in the view strongly typed by importing the View type from AppRun and applying it to the view function.</p> <pre><code>import { app, View } from 'apprun';\nconst view: View&lt;number&gt; =&gt; state =&gt; &lt;div&gt;...&lt;/div&gt;\n</code></pre> <p>The View type imported from AppRun is a generic type. It makes the view function into a generic function, which let us define the type of its parameters. E.g., we define the view function to be View, TypeScript recognizes the state parameter of the view function is a number."},{"location":"strong-typing/#typed-update","title":"Typed Update","text":"<p>Next, let's import the Update type from AppRun and apply it to the update object.</p> <pre><code>import { app, View, Update } from 'apprun';\nconst update: Update&lt;number&gt; = { ... }\n</code></pre> <p>The Update type imported from AppRun is also generic. It makes the event handlers in the update object into generic functions. TypeScript recognizes the state parameter of the event handler functions as are number.</p> <p></p>"},{"location":"strong-typing/#typed-application","title":"Typed Application","text":"<p>Finally, let's make the application strongly typed. The app.start is a generic function already. If we give the app.start function a type, E.g., number, it means the state of the application is number, the view of the application is View and the update of the application is Update. <pre><code>app.start&lt;number&gt;( ... )\n</code></pre> <p>If the type of state does not match the types assigned to the app.start function, TypeScript catches the type error.</p> <p></p> <p>If the type of the view function does not match the types assigned to the app.start function, TypeScript catches the type error.</p> <p></p> <p>If the type of the update object does not match the type assigned to the app.start function, TypeScript catches the type error.</p> <p></p> <p>So far, e have made the strongly typed state to the view function, the event handlers in the update object, and the application. Next, we will move to make strongly typed events.</p>"},{"location":"strong-typing/#strong-typing-of-events","title":"Strong Typing of\u00a0Events","text":"<p>AppRun update object is a named collection or dictionary of the event handlers. The event names are strings, such as +1 and -1. They are not typed, not checked by the compiler, and not IDE friendly. Instead, we can use the TypeScript enum to define the event names.</p>"},{"location":"strong-typing/#enum-of-event-names","title":"Enum of Event\u00a0Names","text":"<p>We define the Events enum and use it in the view functions and the update object.</p> <pre><code>enum Events { inc = '+1', dec = '-1' }\n</code></pre> <p></p> <p>You can see when we type 'Events.', Visual Studio code provides the intelliSense to help us typing. However, you can also see that the string +0 is still allowed in the update object. It is because the object index can only be a number or string. Or as long as a number or string is used, the compiler is happy and has no more type checking.</p>"},{"location":"strong-typing/#update-tuple","title":"Update Tuple","text":"<p>The update can be an array of tuples for defining AppRun event handlers.</p> <p></p> <p>The event handler tuple has two fields: the event name and the event handler function.</p> <p>We can use two advanced TypeScript types the tuple: union type and string literal type, to create so call discriminated union. For more information about union type, string literal type, and discriminated union, please refer to the TypeScript handbook.</p>"},{"location":"strong-typing/#discriminated-union-typed-event-names","title":"Discriminated Union Typed Event\u00a0Names","text":"<p>First, we define a union type called Events, which is made out of two string literal types, -1 and +1.</p> <pre><code>type Events = '-1' | '+1';\n</code></pre> <p>Then, we use the Events type as the second generic of the Update type imported from AppRun and apply it to the update tuple.</p> <pre><code>const update: Update&lt;number, Events&gt; = [ ... ]\n</code></pre> <p>The event names are strongly typed. TypeScript can even provide code auto-completion (IntelliSense) to hint at the event names.</p> <p></p> <p>If the event name is not one of the strings defined in the Events type, TypeScript catches the error.</p> <p></p>"},{"location":"strong-typing/#typed-events-in-view","title":"Typed Events in\u00a0View","text":"<p>To make the event names in the view function strongly type, we need to make the event names of the application strongly type first. We can add the Events type to the app.start_ the generic function.</p> <pre><code>app.start&lt;number, Events&gt;(...)\n</code></pre> <p>It makes the application only can trigger the events that are defined in the Events type. Because we have made the event names strongly typed TypeScript provides intelliSense to the event names of the application.</p> <p></p> <p>TypeScript also catches the event name errors in the view function.</p> <p></p> <p>So far, we have accomplished strong typing for the AppRun global application. Next, we will implement strong typing for AppRun Components.</p>"},{"location":"strong-typing/#strong-typing-of-component","title":"Strong Typing of Component","text":"<p>AppRun Component is like a scoped AppRun application. It also has three parts: state, view, and update.</p> <p>AppRun Component is a generic class. We create our components by extending the AppRun Component class. We can add the state type and events type to the Component class, as well as to the view function, and update the tuple to make the component strongly typed so that TypeScript can provide IntelliSense and type validation while we are coding.</p> <p></p>"},{"location":"strong-typing/#typed-event-decorator","title":"Typed Event Decorator","text":"<p>The AppRun @on decorator makes a function in the component class to be an event handler. The @on decorator is also generic. When we add the event type to the @on the decorator, TypeScript recognizes and enforces the event names to be the event type.</p> <p></p>"},{"location":"strong-typing/#typed-on-directive","title":"Typed $on Directive","text":"<p>The AppRun directive is a syntax sugar for JSX. The $on directive is helpful for publishing DOM events to AppRun events. The $on directive can be strongly typed.</p> <p></p>"},{"location":"strong-typing/#conclusion","title":"Conclusion","text":"<p>Thanks to TypeScript, we can make AppRun application strong-typed.</p>"},{"location":"svg/","title":"SVG","text":""},{"location":"svg/#create-svg","title":"Create SVG","text":"<p>You can create SVG using JSX or lit-HTML. For example, below is a reimplementation of a snabbdom example by Jon Kleiser (@jkleiser).</p>"},{"location":"svg/#svg-use-jsx","title":"SVG use JSX","text":"<p><pre><code>const style=`\nsvg {\n  display: block;\n  margin-bottom: 10px;\n  border: 1px solid gray;\n}\ng#carousel {\n  -webkit-transition: -webkit-transform 1s ease;\n  transition: transform 1s ease;\n}\npolygon {\n  stroke: #808000;\n  transition: fill 0.5s linear;\n}\npolygon#yellow {\n  fill: rgba(255,255,0,0.4);\n}\npolygon#yellow:hover, polygon#yellow:active {\n  fill: yellow;\n}\npolygon#green {\n  fill: rgba(0,128,0,0.4);\n}\npolygon#green:hover, polygon#green:active {\n  fill: green;\n}\npolygon#magenta {\n  fill: rgba(255,0,255,0.4);\n}\npolygon#magenta:hover, polygon#magenta:active {\n  fill: magenta;\n}\npolygon#red {\n  fill: rgba(255,0,0,0.4);\n}\npolygon#red:hover, polygon#red:active {\n  fill: red;\n}\npolygon#cyan {\n  fill: rgba(0,255,255,0.4);\n}\npolygon#cyan:hover, polygon#cyan:active {\n  fill: cyan;\n}\npolygon#blue {\n  fill: rgba(0,0,255,0.4);\n}\npolygon#blue:hover, polygon#blue:active {\n  fill: blue;\n}\n`\nconst triangles = [\n{id: \"yellow\", rot: 0},\n{id: \"green\", rot: 60},\n{id: \"magenta\", rot: 120},\n{id: \"red\", rot: 180},\n{id: \"cyan\", rot: 240},\n{id: \"blue\", rot: 300}\n];\n\nclass SvgComponent extends Component {\n  state = 0;\n\n view = state =&gt; {\n    const transform = \"rotate(\" + state + \"deg)\";\n    return &lt;div className=\"view\"&gt;\n    &lt;style&gt;{style}&lt;/style&gt;\n      &lt;svg width=\"380\" height=\"380\" viewBox=\"-190,-190,380,380\"&gt;\n        &lt;g id=\"carousel\" style={{transform}}&gt;\n          {triangles.map(t =&gt;\n            &lt;polygon id={t.id}\n              points=\"-50,-88 0,-175 50,-88\"\n              transform={`rotate(${t.rot})`}\n              stroke-width=\"3\" /&gt;\n          )}\n        &lt;/g&gt;\n      &lt;/svg&gt;\n      &lt;button $onclick=\"rot+60\"&gt;Rotate Clockwise&lt;/button&gt;\n      &lt;button $onclick=\"rot-60\"&gt;Rotate Anticlockwise&lt;/button&gt;\n      &lt;button $onclick=\"reset\"&gt;Reset&lt;/button&gt;\n    &lt;/div&gt;\n  };\n\n  update = {\n    \"rot+60\": state =&gt; state + 60,\n    \"rot-60\": state =&gt; state - 60,\n    \"reset\": state =&gt; 0,\n  };\n}\nnew SvgComponent().start(document.body);\n</code></pre> </p>"},{"location":"svg/#svg-use-lit-html","title":"SVG use lit-HTML","text":"<p><pre><code>const style=`\nsvg {\n  display: block;\n  margin-bottom: 10px;\n  border: 1px solid gray;\n}\ng#carousel {\n  -webkit-transition: -webkit-transform 1s ease;\n  transition: transform 1s ease;\n}\npolygon {\n  stroke: #808000;\n  transition: fill 0.5s linear;\n}\npolygon#yellow {\n  fill: rgba(255,255,0,0.4);\n}\npolygon#yellow:hover, polygon#yellow:active {\n  fill: yellow;\n}\npolygon#green {\n  fill: rgba(0,128,0,0.4);\n}\npolygon#green:hover, polygon#green:active {\n  fill: green;\n}\npolygon#magenta {\n  fill: rgba(255,0,255,0.4);\n}\npolygon#magenta:hover, polygon#magenta:active {\n  fill: magenta;\n}\npolygon#red {\n  fill: rgba(255,0,0,0.4);\n}\npolygon#red:hover, polygon#red:active {\n  fill: red;\n}\npolygon#cyan {\n  fill: rgba(0,255,255,0.4);\n}\npolygon#cyan:hover, polygon#cyan:active {\n  fill: cyan;\n}\npolygon#blue {\n  fill: rgba(0,0,255,0.4);\n}\npolygon#blue:hover, polygon#blue:active {\n  fill: blue;\n}\n`\nconst triangles = [\n{id: \"yellow\", rot: 0},\n{id: \"green\", rot: 60},\n{id: \"magenta\", rot: 120},\n{id: \"red\", rot: 180},\n{id: \"cyan\", rot: 240},\n{id: \"blue\", rot: 300}\n];\n\nclass SvgComponent extends Component {\n  state = 0;\n\n  view = state =&gt; {\n    const items = triangles.map(t =&gt;\n      svg`&lt;polygon id=\"${t.id}\"\n        points=\"-50,-88 0,-175 50,-88\"\n        transform=\"rotate(${t.rot})\"\n        stroke-width=\"3\" /&gt;`\n    );\n    return html`&lt;div class=\"view\"&gt;\n      &lt;style&gt;${style}&lt;/style&gt;\n      &lt;svg width=\"380\" height=\"380\" viewBox=\"-190,-190,380,380\"&gt;\n        &lt;g id=\"carousel\" style=\"transform: rotate(${state}deg);\"&gt;\n          ${items}\n        &lt;/g&gt;\n      &lt;/svg&gt;\n      &lt;button @click=${run(\"@rot+60\")}&gt;Rotate Clockwise&lt;/button&gt;\n      &lt;button @click=${run(\"@rot-60\")}&gt;Rotate Anticlockwise&lt;/button&gt;\n      &lt;button @click=${run(\"@reset\")}&gt;Reset&lt;/button&gt;\n    &lt;/div&gt;`;\n  };\n\n  update = {\n    \"@rot+60\": state =&gt; state + 60,\n    \"@rot-60\": state =&gt; state - 60,\n    \"@reset\": () =&gt; 0,\n  };\n}\nnew SvgComponent().start(document.body);\n</code></pre> </p>"},{"location":"svg/#svg-xlinkhref","title":"SVG - xlink:href","text":"<p>You can use xlinkHref to define the xlink:href attribute of SVG.</p> <p><pre><code>// SVG - xlink\nconst view = () =&gt; &lt;svg viewBox=\"0 0 150 20\"&gt;\n  &lt;a xlinkHref=\"https://apprun.js.org/\"&gt;\n    &lt;text x=\"10\" y=\"10\" font-size=\"5\"&gt;Click Here&lt;/text&gt;&lt;/a&gt;\n&lt;/svg&gt;\n\napp.start(document.body, {}, view);\n</code></pre> </p>"},{"location":"svg/#svg-event-handlers","title":"SVG Event Handlers","text":"<p>You can handle the onclick event of SVG elements. Or use the $onclick directive</p> <p><pre><code>// SVG - $onclick\nconst view = state =&gt; &lt;&gt;\n&lt;div&gt;click the buttons:&lt;/div&gt;\n&lt;svg viewBox=\"0 0 520 520\" xmlns=\"http://www.w3.org/2000/svg\"&gt;\n  &lt;rect x=\"10\" y=\"10\" width=\"90\" height=\"20\" fill=\"#aaa\"\n    $onclick=\"test\" id=\"$onclick\"/&gt;\n  &lt;rect x=\"110\" y=\"10\" width=\"90\" height=\"20\" fill=\"#bbb\"\n    onclick=\"app.run('test', event)\" id=\"onclick\"/&gt;\n&lt;/svg&gt;\n&lt;/&gt;\n\nconst update = {\n  test: (state, evt) =&gt; alert(\"You have used: \" + evt.target.id)\n}\napp.start(document.body, '', view, update);\n</code></pre> </p>"},{"location":"svg/#svg-animation","title":"SVG Animation","text":"<p>You can use the animate element to add animation to SVG.</p> <p><pre><code>// SVG - animation\nconst view = () =&gt; &lt;&gt;\n  &lt;svg height=\"60\" width=\"160\"&gt;\n    &lt;rect width=\"100%\" height=\"100%\" rx=\"10\" ry=\"10\" fill=\"lightgrey\" /&gt;\n    &lt;circle cx=\"30\" cy=\"30\" r=\"20\" fill='lime'&gt;\n    &lt;animate\n          attributeType=\"XML\"\n          attributeName=\"fill\"\n          values=\"lime;lightgrey;lime;lightgrey\"\n          dur=\"0.5s\"\n          repeatCount=\"indefinite\"/&gt;\n    &lt;/circle&gt;\n    &lt;circle cx=\"80\" cy=\"30\" r=\"20\" fill='yellow' fill-opacity='0.2'/&gt;\n    &lt;circle cx=\"130\" cy=\"30\" r=\"20\" fill='orangered' fill-opacity='0.2' /&gt;\n  &lt;/svg&gt;\n&lt;/&gt;;\napp.start(document.body, {}, view);\n</code></pre> </p>"},{"location":"tutorial/","title":"Quick Start Tutorial","text":""},{"location":"tutorial/#create-your-first-app","title":"Create Your First App","text":"<p>AppRun Application logic is broken down into three separate parts in the AppRun architecture.</p> <ul> <li>State (a.k.a. Model) \u2014 the state of your application</li> <li>View \u2014 a function to display the state</li> <li>Update \u2014 a collection of event handlers to update the state</li> </ul> <p>Let's use the Counter app as an example and code it directly in the HTML file.</p> <p><pre><code>&lt;html&gt;\n&lt;body&gt;\n  &lt;script src=\"https://unpkg.com/apprun/dist/apprun-html.js\"&gt;\n  &lt;/script&gt;\n  &lt;script&gt;\n    const state = 0;\n    const view = state =&gt; {\n      return html`&lt;div&gt;\n        &lt;h1&gt;${state}&lt;/h1&gt;\n        &lt;button onclick='app.run(\"-1\")'&gt;-1&lt;/button&gt;\n        &lt;button onclick='app.run(\"+1\")'&gt;+1&lt;/button&gt;\n      &lt;/div&gt;`;\n    };\n    const update = {\n      '+1': state =&gt; state + 1,\n      '-1': state =&gt; state - 1\n    };\n    app.start(document.body, state, view, update);\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </p> <p>Note</p> <p>Browsers dont support JSX, so we use the html function (Template literals) in the view function to create HTML elements.</p>"},{"location":"tutorial/#create-your-first-component","title":"Create Your First Component","text":"<p>AppRun components are mini-applications with the state, view, and update architecture.</p> <p>Let's re-create the Counter app as a component.</p> <p><pre><code>&lt;html&gt;\n&lt;body&gt;\n  &lt;script src=\"https://unpkg.com/apprun/dist/apprun-html.js\"&gt;&lt;/script&gt;\n  &lt;script&gt;\n    class Counter extends Component {\n      state = 0;\n      view = state =&gt; {\n        return html`&lt;div&gt;\n          &lt;h1&gt;${state}&lt;/h1&gt;\n          &lt;button @click=${()=&gt;this.run(\"-1\")}&gt;-1&lt;/button&gt;\n          &lt;button @click=${()=&gt;this.run(\"+1\")}&gt;+1&lt;/button&gt;\n        &lt;/div&gt;`;\n      };\n      update = {\n        '+1': state =&gt; state + 1,\n        '-1': state =&gt; state - 1\n      };\n    }\n    new Counter().start(document.body);\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </p> <p>Note</p> <p>Components have local event events. We use this.run instead of app.run to publish local events.</p>"},{"location":"tutorial/#use-components-for-spa","title":"Use Components for SPA","text":"<p>We can easily make a single-page page (SPA) using AppRun components. Each page is a component that can be activated by anchor links like #Home, #contact, and #about.</p> <p><pre><code>class Home extends Component {\n  view = () =&gt; &lt;div&gt;Home&lt;/div&gt;;\n  update = {'#, #home': state =&gt; state };\n}\n\nclass Contact extends Component {\n  view = () =&gt; &lt;div&gt;Contact&lt;/div&gt;;\n  update = {'#contact': state =&gt; state };\n}\n\nclass About extends Component {\n  view = () =&gt; &lt;div&gt;About&lt;/div&gt;;\n  update = {'#about': state =&gt; state };\n}\n\nconst App = () =&gt; &lt;&gt;\n  &lt;div id=\"menus\"&gt;\n    &lt;a href=\"#home\"&gt;Home&lt;/a&gt;{' | '}\n    &lt;a href=\"#contact\"&gt;Contact&lt;/a&gt;{' | '}\n    &lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/div&gt;\n  &lt;div id=\"pages\"&gt;&lt;/div&gt;\n&lt;/&gt;\n\napp.render(document.body, &lt;App /&gt;);\n[About, Contact, Home].map(C =&gt; new C().start('pages'));\n</code></pre> </p> <p>Note</p> <p>We have just created a simple SPA using components. In a real-world scenario, usually, create pages as modules and bundle them together or load them dynamically. See the Single Page App for more details.</p>"},{"location":"tutorial/#create-a-web-component","title":"Create a Web Component","text":"<p>AppRun components can be defined as web components/custom elements and used in HTML. All we need to do is to give the AppRun component a custom-element name using the app.webComponent function.</p> <p><pre><code>&lt;html&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"&gt;\n  &lt;title&gt;Counter&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;my-counter&gt;&lt;/my-counter&gt;\n  &lt;my-counter&gt;&lt;/my-counter&gt;\n  &lt;my-counter&gt;&lt;/my-counter&gt;\n  &lt;script src=\"https://unpkg.com/apprun/dist/apprun-html.js\"&gt;\n  &lt;/script&gt;\n  &lt;script&gt;\n    class Counter extends Component {\n      state = 0;\n      view = state =&gt; {\n        return html`&lt;div&gt;\n          &lt;h1&gt;${state}&lt;/h1&gt;\n          &lt;button @click=${()=&gt;this.run(\"-1\")}&gt;-1&lt;/button&gt;\n          &lt;button @click=${()=&gt;this.run(\"+1\")}&gt;+1&lt;/button&gt;\n        &lt;/div&gt;`;\n      };\n      update = {\n        '+1': state =&gt; state + 1,\n        '-1': state =&gt; state - 1\n      };\n    }\n    app.webComponent('my-counter', Counter);\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </p> <p>Note</p> <p>We have create a web component / custom element and used it three times.</p> <p></p> <p>Now, you are ready to move forward to more advanced topics:</p> <ul> <li> <p> Use AppRun as ESM in browser</p> <p>Reference AppRun from CDN as ESM to build your apps</p> <p>Use AppRun Module in the browser</p> </li> <li> <p> Create an SPA project</p> <p>Create a new SPA project using the AppRun CLI</p> <p> Create AppRun App</p> </li> </ul>"},{"location":"unit-testing/","title":"Unit Testing","text":"<p>AppRun architecture is unit test-oriented. The three architectural parts state, view, and update (event handlers) are decoupled. They are straightforward to test.</p> <p>AppRun development environment includes the Jest framework. The convention to run the tests is to use the npm script: <pre><code>npm run jest\n</code></pre> We can also run the Jest testing interactive mode using the npm script: <pre><code>npm test\n</code></pre> Jest watches file changes and runs the test files only related to changed files. Jest also executes the tests in parallel. Therefore, it is very fast to execute the tests. The interactive way for us to define which tests to be executed during the watch mode.</p>"},{"location":"unit-testing/#types-of-testing","title":"Types of Testing","text":"<p>There are two types of unit tests in the AppRun application.</p> <ol> <li>Test the events-states - publishing the events and asserting the states.</li> <li>Test the state-vdom - set the states and assert the VDOM output of the view function.</li> </ol>"},{"location":"unit-testing/#create-tests-using-cli","title":"Create Tests using CLI","text":"<p>Creating unit tests could be tedious, but you can use the AppRun Dev Tools to generate the tests.</p> <p>First, include the CLI scripts in your HTML.</p> <pre><code>&lt;script src=\"https://unpkg.com/apprun@latest/dist/apprun-dev-tools.js\"&gt;&lt;/script&gt;\n</code></pre>"},{"location":"unit-testing/#event-state-tests","title":"Event-State Tests","text":"<p>Use the create-event-tests command to create event-state tests.</p> <p> </p>"},{"location":"unit-testing/#state-vdom-tests","title":"State-VDOM Tests","text":"<p>Use the create-state-tests (start|stop) command to create state-view tests.</p> <p> </p>"},{"location":"unit-testing/#examples","title":"Examples","text":"<p>Please check out the unit tests from the AppRun RealWorld example application.</p> <p>You can find:</p> <ul> <li>How to mock the API calls</li> <li>Event-State Test</li> <li>State-VDOM Test</li> </ul>"},{"location":"view-patterns/","title":"JSX","text":"<p>AppRun uses virtual DOM technology (VDOM). The VDOM is the data representing a DOM structure. AppRun compares the VDOM with the real DOM and updates only the changed elements and element properties. It provides high performance.</p> <p>AppRun allows you to choose your favorite virtual DOM technology to create user interfaces in the view function.</p> <p>We recommend using JSX. Some advanced features only apply to JSX.</p>"},{"location":"view-patterns/#jsx_1","title":"JSX","text":"<p>JSX is a syntax sugar of function calls. Thus, you can compose the functions and apply dynamic and conditional rendering without the run-time cost of parsing the HTML string.</p> <p>You can use the JSX features described below.</p>"},{"location":"view-patterns/#jsx-fragments","title":"JSX fragments","text":"<p>JSX Fragments let you group a list of children without adding extra root node. E.g., you can use &lt;&gt; for declaring fragments. E.g.,</p> <pre><code>const view = &lt;&gt;\n  &lt;h1&gt;title 1&lt;/h1&gt;\n  &lt;h2&gt;title 2&lt;/h2&gt;\n&lt;/&gt;\n</code></pre>"},{"location":"view-patterns/#function-calls","title":"Function Calls","text":"<p>We can also use the capitalized JSX tag to call JavaScript functions with capitalized function names. The functions are also known as the Pure Function Component.</p> <p>E.g., To render the todo item list, You can call the Todo function in an array.map function.</p> <pre><code>const Todo = ({ todo, idx }) =&gt; &lt;li&gt;{todo.title}&lt;/li&gt;;\nconst view = state =&gt; &lt;ul class=\"todo-list\"&gt; {\n  state.list.map((todo, idx) =&gt; &lt;Todo todo={todo} idx={idx} /&gt;)\n}&lt;/ul&gt;\n</code></pre>"},{"location":"view-patterns/#de-structuring-properties","title":"De-structuring Properties","text":"<p>The call to the Todo function passes two properties todo and idx. In the Todo function, you can retrieve the two properties by de-structuring the parameters.</p> <pre><code>const Todo = ({ todo, idx }) =&gt; &lt;li&gt;{todo.title}&lt;/li&gt;;\n</code></pre>"},{"location":"view-patterns/#set-class","title":"Set Class","text":"<p>Each todo item should have a class \u201cview\u201d that represents that active or complete for a complete status of the todo item. You can use the ternary operator to toggle between two classes.</p> <pre><code>const Todo = ({ todo, idx }) =&gt; &lt;li class={todo.done ? \"completed\" : \"view\"}&gt;\n</code></pre> <p>Please note that AppRun supports using the keyword class in JSX.</p>"},{"location":"view-patterns/#toggle-class","title":"Toggle Class","text":"<p>Sometimes, you need to toggle classes based on the state. You can also use the ternary operator to toggle the class. E.g., toggle the selected class to a menu item.</p> <pre><code>&lt;li&gt;&lt;a class={state.filter === 'All' ? 'selected' : ''} &gt;All&lt;/a&gt;&lt;/li&gt;\n</code></pre>"},{"location":"view-patterns/#show-and-hide-element","title":"Show and Hide Element","text":"<p>To show or hide an element dynamically, you can use the &amp;&amp; operator.</p> <pre><code>const countComplete = state.list.filter(todo =&gt; todo.done).length || 0;\n{ countComplete &amp;&amp; &lt;button&gt;Clear completed&lt;/button&gt;}\n</code></pre>"},{"location":"view-patterns/#ref","title":"ref","text":"<p>ref is a special JSX property, which is a callback function that is called after the view function is executed.</p> <pre><code>const view = &lt;div ref={el=&gt;{...}}&gt;&lt;/div&gt;\n</code></pre> <p>We can use ref function to update the HTML element, e.g., set focus to an input box.</p> <p>ref is a better method to update the element than using the rendered lifecycle function.</p> <p>Please think of using the ref function before you use the rendered function.</p>"},{"location":"view-patterns/#element-embedding","title":"Element embedding","text":"<p>Furthermore, AppRun allows embedding elements directly into JSX.</p> <pre><code>view = state =&gt; {\n  const canvas = document.createElement('canvas');\n  return &lt;div&gt;{canvas}&lt;/div&gt;\n};\n</code></pre> <p>A few use cases of the Element embedding are:</p> <ul> <li>Create special element, e.g. element has shadow root</li> <li>Create elements using 3rd libraries.</li> <li>Create and cache the element to avoid recreation in every event lifecycle</li> </ul> <p>Just create the HTML element and add it to the AppRun view.</p> <p>Please think of embedding the element before you use the ref function.</p>"},{"location":"view-patterns/#directive","title":"Directive","text":"<p>The directive is the special property that looks like $xxx. When AppRun is processing the JSX code and finds the properties of $xxx, it publishes the $ event. The event parameters contain the directive key, properties, and tag Name of the HTML element and component instance.</p> <pre><code>const view = &lt;div $myDirective&gt;&lt;/div&gt;;\napp.on('$', ({key, props, tag, component}) =&gt; {\n  if (key === '$myDirective') {\n  }\n}\n</code></pre> <p>We can subscribe to the $ event and create custom directives to modify the properties of the HTML element.</p> <p>See more details about directive in the next section.</p>"},{"location":"architecture-ideas/dapr/","title":"Use AppRun with Dapr","text":"<p>Welcome to the world of AppRun, microservices, CQRS, and Dapr.</p> <ul> <li>Dapr is a portable, serverless, event-driven runtime for building resilient, stateless, and stateful microservices.</li> </ul> <p>We can connect AppRun events to Dapr PubSub through WebSockets to build microservices using CQRS, and Dapr.</p> <p></p> <p>https://github.com/yysun/apprun-dapr/</p>"},{"location":"architecture-ideas/db-websocket/","title":"Database-Driven Applications Using WebSockets","text":""},{"location":"architecture-ideas/db-websocket/#introduction","title":"Introduction","text":"<p>The database is a specific technology for storing, managing, and processing data. In the real-world, web sites, mobile apps, and business applications that serve dynamic content all have a backend database.</p> <p>Started being popular in the web and mobile apps, moving to the business applications, nowadays most of the database-driven applications use a REST API based architecture. The REST API provides flexibility, scalability, and simplicity over other traditional web services architectures.</p> <p></p> <p>However, the primary purpose of the REST API is to decouple the backend and frontend, which assumes backend and frontend know nothing about each other. Even in case we know and own both backend and frontend, such as in many business applications, we still have to develop the backend API endpoints first. And then, we develop the frontend API clients. Developing backend and frontend separately is tedious and error-prone.</p> <p>Also, If we want to publish events from the frontend to be handled in the backend business logic modules, we cannot do it directly. Furthermore, the REST API is not a duplex protocol. Only the frontend can call the API. The backend cannot call the frontend. Therefore sometimes, the REST API has become a barrier between frontend and backend that costs us extra time and effort to overcome.</p> <p>In this post, I will introduce a new application architecture that allows us to send events back and forth between the frontend apps to the backend business logic modules using the WebSocket API and AppRun without REST API.</p> <p>The WebSocket API is a duplex communication channel. It works well with an event-driven framework, such as AppRun.</p>"},{"location":"architecture-ideas/db-websocket/#the-architecture","title":"The Architecture","text":"<p>The new architecture uses the WebSocket API and AppRun event system.</p> <p>AppRun has two important functions: app.run and app.on. app.run fires events. app.on handles events. E.g.:</p> <p>Module A handles the print event:</p> <p><pre><code>import app from 'apprun';\nexport default () =&gt; app.on('print', e =&gt; console.log(e));\n</code></pre> Module B fires the print event:</p> <pre><code>import app from 'apprun';\napp.run('print', {});\n</code></pre> <p>Module B can invoke the function in Module A without knowing Module A. It works when Module A and Module B are both frontend modules. Can the business logic modules behind the webserver also subscribe to the frontend events?</p> <p>Yes, that's the exact idea of the new architecture.</p> <p></p> <p>Let's see how it works.</p>"},{"location":"architecture-ideas/db-websocket/#an-example-application","title":"An Example Application","text":"<p>We will create a database-driven todo application to demonstrate the new architecture. The project has the following files:</p> <p></p> <ul> <li>The database:</li> <li>db/todo.db is a SQLite database</li> <li>The public folder has the frontend code:</li> <li>index.html</li> <li>dist/app.js</li> <li>The server folder has the backend code:</li> <li>db.js: the business logic</li> <li>server.js: the web server using the express and _websocket libraries</li> <li>The src folder has the frontend code:</li> <li>todo.tsx: the AppRun component for managing the todo list</li> <li>main.tsx: the main program</li> </ul>"},{"location":"architecture-ideas/db-websocket/#send-events-to-server-through-websocket","title":"Send Events to Server Through WebSocket","text":"<p>First, we create a WebSocket in the frontend app (main.tsx). Then, We define a special AppRun global event called //ws:, which sends the events to the server.</p> <pre><code>const ws = new WebSocket(`wss://${location.host}`);\napp.on('//ws:', (event, state) =&gt; {\n  const msg = { event, state };\n  ws.send(JSON.stringify(msg));\n});\n</code></pre>"},{"location":"architecture-ideas/db-websocket/#receiving-events-from-frontend","title":"Receiving Events from Frontend","text":"<p>We create the WebSockets on the webserver side (index.js). We listen to the WebSockets messages and convert them to AppRun events. AppRun runs on the webserver. Just like Module A and Module B example above, the AppRun events will be handled in the business logic module (db.js).</p> <pre><code>const apprun = require('apprun').app;\nrequire('./db');\n\nconst path = require('path');\nconst express = require('express');\nconst { createServer } = require('http');\nconst webSocket = require('ws');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, '../public')));\n\nconst server = createServer(app);\nconst wss = new webSocket.Server({ server });\n\nwss.on('connection', function(ws) {\n  ws.on('message', function (data) {\n    try {\n      const json = JSON.parse(data);\n      console.log('==&gt;', json);\n      apprun.run(json.event, json, ws);\n    } catch (e) {\n      ws.send(e.toString());\n      console.error(e);\n    }\n  });\n});\n</code></pre> <p>Notice the webserver also adds the WebSocket reference, ws as the event parameter for the business logic module.</p>"},{"location":"architecture-ideas/db-websocket/#handle-events-in-business-logic-module","title":"Handle Events in Business Logic Module","text":"<p>We handle AppRun events in the business logic module (db.js) to complete the CRUD operations against the database.</p> <pre><code>const app = require('apprun').app;\nconst sqlite3 = require('sqlite3').verbose();\nconst dbFile = \"db/todo.db\";\n\napp.on('@get-all-todo', (json, ws) =&gt; {\n  const sql = 'select * from todo';\n  db.all(sql, function (err, rows) {\n    json.state = rows || [];\n    ws.send(JSON.stringify(json));\n  });\n});\n\napp.on('@get-todo', (json, ws) =&gt; {\n});\n\napp.on('@create-todo', (json, ws) =&gt; {\n});\n\napp.on('@update-todo', (json, ws) =&gt; {\n});\n\napp.on('@delete-todo', (json, ws) =&gt; {\n});\n\napp.on('@delete-all-todo', (json, ws) =&gt; {\n});\n</code></pre> <p>Once completed the database operations, we use the WebSocket reference, ws, to send events back.</p>"},{"location":"architecture-ideas/db-websocket/#receiving-events-from-backend","title":"Receiving Events from Backend","text":"<p>Receiving events from the backend in the frontend app (main.tsx) is straightforward.</p> <pre><code>const ws = new WebSocket(`wss://${location.host}`);\nws.onmessage = function (msg) {\n  const {event, state} = JSON.parse(msg.data);\n  app.run(event, state);\n}\n</code></pre> <p>You can see now we have 9 lines of client-side code in main.tsx and 11 lines of server-side code in index.js for transferring AppRun events between frontend and backend through WebSockets.</p> <p>We also have a business logic module that operates the database using AppRun events.</p> <p>They are ready to serve the frontend application.</p>"},{"location":"architecture-ideas/db-websocket/#the-frontend-application","title":"The Frontend Application","text":"<p>The frontend Todo application is a typical AppRun application that has the Elm inspired architecture (todo.tsx). Listed below is the simplified code except.</p> <pre><code>import app, { Component } from 'apprun';\n\nconst state = {\n  filter: 0,\n  todos: []\n}\n\nconst add = () =&gt; {\n  app.run('//ws:', '@create-todo', {\n    title: document.getElementById('new_todo').value,\n    done: 0\n  })\n};\n\nconst toggle = (_, todo) =&gt; { app.run('//ws:', '@update-todo', { ... }) };\n\nconst remove = (_, todo) =&gt; { app.run('//ws:', '@delete-todo', todo) };\n\nconst clear = () =&gt; { app.run('//ws:', '@delete-all-todo') };\n\nconst search = (state, filter) =&gt; ({ ...state, filter });\n\nconst view = (state) =&gt; {...}\n\nconst update = {\n  '@get-all-todo': (state, todos) =&gt; ({ ...state, todos }),\n\n  '@create-todo': (state, todo) =&gt; ({ ... }),\n\n  '@update-todo': (state, todo) =&gt; { ... },\n\n  '@delete-todo': (state, todo) =&gt; { ... },\n\n  '@delete-all-todo': state =&gt; ({ ...state, todos: [] })\n}\n\nexport default new Component(state, view, update);\n</code></pre> <p>You can see we have state, view, and update to form an AppRun component.</p> <p>The local functions handle local events, such as add, toggle, remove, clear, and search. These functions fire the global event //ws: to the WebSocket.</p> <p>The update object contains the event handlers for the events fired from the backend.</p> <p>That's all the implementation plan. For details, please take a look at the live demo and the source code if you like.</p>"},{"location":"architecture-ideas/db-websocket/#run-the-demo","title":"Run the Demo","text":"<p>Live Demo:</p> <p>https://glitch.com/~apprun-websockets-sqlite</p> <p>Source Code:</p> <p>https://github.com/yysun/apprun-websockets-sqlite</p>"},{"location":"architecture-ideas/db-websocket/#conclusion","title":"Conclusion","text":"<p>The todo application has demonstrated the architecture of using events through WebSockets. The web server has no REST API endpoints. The frontend has only event handlings and has no REST API calls.</p> <p>The architecture is useful for database-driven applications, especially business applications.</p> <p>Furthermore, AppRun events are not limited to frontend and WebSockets.  We can use AppRun events with the Web Workers API explained in the AppRun Book. We can also use AppRun in the Electron Apps, Firebase, Cloud Pub-Sub, and more ...</p> <p>Feel the power of event pub-sub pattern and learn more about building applications with AppRun.</p>"},{"location":"architecture-ideas/firebase-app/","title":"Serverless App Using Firebase and AppRun","text":""},{"location":"architecture-ideas/firebase-app/#introduction","title":"Introduction","text":"<p>I have been writing about the application architecture without REST, which includes the underlying architecture using WebSockets and the database-driven architecture. In this post, I will continue the journey to make a serverless application architecture using Firebase and AppRun.</p> <p>You will see how easy it is to use AppRun's event system with the Firebase stack to develop applications that have the full business logic process capabilities, such as authentication, authorization, request logging, and real-time database, and without REST layer.</p> <p>Finally, we can make the application a serverless deployment to Firebase.</p>"},{"location":"architecture-ideas/firebase-app/#the-architecture","title":"The Architecture","text":"<p>The example application uses the following technologies:</p> <ul> <li>Firebase Cloud Firestore as the backend database</li> <li>Firebase Cloud Functions for business logic process</li> <li>Firebase Hosting to host the frontend</li> <li>Firebase Authentication</li> </ul> <p>Firebase is Google's mobile platform that helps you quickly develop high-quality apps and grow your business.</p> <p>I will focus on the architecture instead of step-by-step instructions. If you are not familiar with the Firebase suite of products, please search google for the tutorials.</p> <p>The architecture can be summarized in the diagram below.</p> <p></p> Figure 1. Architecture Diagram <p>Let's get into the details.</p>"},{"location":"architecture-ideas/firebase-app/#event-pub-sub-using-firestore","title":"Event Pub-Sub Using FireStore","text":"<p>The center of the architecture is the Firebase Cloud Firestore. Firestore is a real-time database that keeps your data in-sync across client apps. When one client saves the data, FireStore pushes the data to all other clients.</p> <p>In the AppRun applications, we use app.on to publish events. If we save the events to FireStore, the events can be handled by other applications. It is the step (1) shown in Figure 1 above.</p> <p>Firestore also triggers Cloud Functions.</p>"},{"location":"architecture-ideas/firebase-app/#business-logic-process-using-cloud-functions","title":"Business Logic Process Using Cloud Functions","text":"<p>Cloud Functions is Google Cloud's serverless compute platform. It runs on the server, not in the client apps. Therefore it is the best technology for business logic processing, authentication, and authorization. Functions are serverless. Functions run on Google's server, so we don't need to provision, manage, or upgrade the server.</p> <p>The Functions are event-driven (the magic word, I love). Firestore can trigger Functions upon data updates. When we save the events into FireStore, FireStore triggers the Function to handle the events automatically. It is the step (2) in Figure 1.</p>"},{"location":"architecture-ideas/firebase-app/#real-time-data-sync-using-firestore","title":"Real-Time Data Sync Using FireStore.","text":"<p>During the Functions event handling, it writes the updated data back to FireStore (step (3) in Figure 1). FireStore pushes the update to the frontend applications (step (4) in Figure 1). The frontend application listens to FireStore changes and publishes AppRun events for the frontend logic process to run.</p> <p>Now, the event handling cycle is completed. Let's see it in action with an example.</p>"},{"location":"architecture-ideas/firebase-app/#example","title":"Example","text":"<p>The example is a ToDo application.</p> <p></p> Figure 2. ToDo Application"},{"location":"architecture-ideas/firebase-app/#save-events-to-firestore","title":"Save Events to FireStore","text":"<p>As usual, in the AppRun applications, we convert the DOM events into AppRun events. E.g., When users click the add button, we publish the //: event.</p> <pre><code>// in JSX\n&lt;button $onclick={[add]}&gt;Add&lt;/button&gt;\n\nconst add = () =&gt; {\n  app.run('//:', '@create-todo', {\n    title: (document.getElementById('new_todo').value,\n    done: 0\n  })\n}\n</code></pre> <p>The //: event handler saves the event into FireStore.</p> <pre><code>const db = firebase.firestore();\napp.on('//:', (event, data = {}) =&gt; {\n  db.collection(`events`).add({ uid, event, data })\n});\n</code></pre> <p>There is a top-level collection, called events in FireStore. We save the user id (obtained using Firebase anonymous authentication), event name (@create-todo), and event parameters (the new to-do item).</p> <p>FireStore triggers our Function, which is monitoring the events collection.</p>"},{"location":"architecture-ideas/firebase-app/#handle-events-in-functions","title":"Handle Events in Functions","text":"<pre><code>exports.updateTodo = functions.firestore.document('events/{Id}')\n  .onWrite((change, context) =&gt; {\n    const dat = change.after.data() as any;\n    const { uid, event, data } = dat;\n    const db = admin.firestore();\n    const todos = db.collection('/users/' + uid + '/todos');\n    switch (event) {\n      case '@create-todo': return todos.add(data);\n      case '@update-todo': ...\n      case '@delete-todo': ...\n      case '@delete-all-todo': ...\n      default: return;\n    }\n});\n</code></pre> <p>The Function destructs the user id, event name, and event parameters and handles it accordingly, e.g., it adds a new Todo item data into FireStore upon the '@create-todo' event. And so on so forth.</p> <p>FireStore then pushes the data change to the frontend.</p>"},{"location":"architecture-ideas/firebase-app/#real-time-data-in-frontend","title":"Real-Time Data in Frontend","text":"<p>In the frontend, we subscribe to the onSnapshot of FireStore and publish the AppRun event, '@show-all'.</p> <pre><code>const db = firebase.firestore();\ndb.collection(`users/${uid}/todos`).onSnapshot(snapshot =&gt; {\n  app.run('@show-all',\n    snapshot.docs.map(d =&gt; ({ id: d.id, ...d.data() })))\n});\n</code></pre> <p>Now, we are back to our AppRun application world, in which you can see the three familiar parts: state, view, and update.</p> <pre><code>import app, { Component } from 'apprun';\n\nconst state = {\n  filter: 0,\n  todos: []\n}\n\nconst add = () =&gt; {\n  app.run('//:', '@create-todo', {\n    title: (document.getElementById('new_todo').value,\n    done: 0\n  })\n};\nconst toggle = (_, todo) =&gt; { app.run('//:', '@update-todo', { ...todo, done: !todo.done }) };\nconst remove = (_, todo) =&gt; { app.run('//:', '@delete-todo', todo) };\nconst clear = () =&gt; { app.run('//:', '@delete-all-todo') };\n\nconst view = ({todos}) =&gt; {...}\n\nconst update = {\n  '@show-all': (state, todos) =&gt; ({ ...state, todos })\n}\n</code></pre> <p>The Firebase ToDo application shares the same architecture as in the Database-Driven Application Post. They are only different in events. The Firebase ToDo application saves the events to FireStore. The Database-Driven Application sends and receives the events through the WebSockets.</p> <p>If you are new to AppRun, read the AppRun Book or visit AppRun Docs.</p>"},{"location":"architecture-ideas/firebase-app/#live-demo-and-source-code","title":"Live Demo and Source Code","text":"<p>You can play with the live demo at https://apprun-demo.firebaseapp.com.</p> <p>Source Code: https://github.com/yysun/apprun-firebase</p>"},{"location":"architecture-ideas/firebase-app/#conclusion","title":"Conclusion","text":"<p>The AppRun event pub-sub pattern looks so simple (just app.run and app.on), yet so powerful. It is not only useful inside the frontend app. It shines more in crossing process boundaries, such as in the cases of WebSockets, Web Workers, Electron Apps, Firebase of course, and more ...</p>"},{"location":"architecture-ideas/rust-app/","title":"Rust WebAssembly and AppRun","text":""},{"location":"architecture-ideas/rust-app/#introduction","title":"Introduction","text":"<p>WebAssembly has many different definitions on the Internet. I like the one from MDN the most, which says WebAssembly is a new binary assembly-like language that can run in the modern web browsers at near-native speed. There are many tools to compile code written in C/C++, Rust, Go, C#, etc. to be WebAssembly. It tells us that we can create high-performance code, but not using JavaScript/TypeScript</p> <p>I decided to play with Rust. Rust is another hot buzzword. It is a relatively new programming language focused on performance and safety, especially safe concurrency. -- Wikipedia</p> <p>This post describes how to create a WebAssembly package using Rust and use it in the AppRun applications from a JavaScript/TypeScript developer point of view. You will see the minimum steps of adding and using WebAssembly into your JavaScript/TypeScript project.</p>"},{"location":"architecture-ideas/rust-app/#setup","title":"Setup","text":"<p>First, you will need the Rust toolchain, including rustup, rustc, and cargo for compiling Rust code, and wasm-pack for building, testing and publishing Rust-generated WebAssembly.</p>"},{"location":"architecture-ideas/rust-app/#install-rust","title":"Install Rust","text":"<p>To install Rust on Mac/Linux, run the following command in the terminal. <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> On Windows, I enabled the Windows Subsystem for Linux and used Rust in the Linux terminal.</p>"},{"location":"architecture-ideas/rust-app/#install-wasm-pack","title":"Install wasm-pack","text":"<p>Once installed Rust, run the following command in the terminal. <pre><code>cargo install wasm-pack\n</code></pre> Believe it or not, that's all you need to create WebAssembly. Let's go back to the JavaScript/TypeScript world.</p> <ul> <li>If you start from scratch, follow the next section to create an AppRun project.</li> <li>If you already have an existing project, jump to the section of Create WebAssembly Project.</li> </ul>"},{"location":"architecture-ideas/rust-app/#create-apprun-project","title":"Create AppRun Project","text":"<p>Run the commands to create an AppRun project:</p> <pre><code>mkdir your-app-name\ncd your-app-name\nnpx apprun -i\n</code></pre> <p>Wait a few minutes for installing the npm packages, and then run the npm command:</p> <pre><code>npm start\n</code></pre> <p>You will see a hello world application running.</p> <p></p> AppRun Hello World <p>Next, we will add WebAssembly to this project.</p>"},{"location":"architecture-ideas/rust-app/#create-webassembly-project","title":"Create WebAssembly Project","text":"<p>Let's create a Rust project by running the following command:</p> <pre><code>cargo new wasm --lib\n</code></pre> <p>The command creates a folder called wasm and two files under the folder your-app-name/wasm: Cargo.toml and src/lib.rs.</p> <p>It is a regular Rust project, not a WebAssembly yet. You will need to add wasm-bindgen as the dependency to make it target WebAssembly. Open Cargo.toml and add the following sections.</p> <pre><code>[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\nwasm-bindgen = \"0.2.60\"\njs-sys = \"0.3.37\"\n</code></pre> <p>wasm-bindgen is a Rust library that facilitates high-level interactions between wasm modules and JavaScript. js-sys is the waw bindings to JS global APIs for projects using wasm-bindgen.</p> <p>Now, you can use wasm-pack to build a WebAssembly.</p> <pre><code>cd wasm\nwasm-pack build\n</code></pre>"},{"location":"architecture-ideas/rust-app/#use-webpack","title":"Use WebPack","text":"<p>Since the AppRun project is a WebPack project, we can use the wasm-pack-plugin to unify the build process that creates the WebAssembly and JavaScript code at the same time. Go ahead to add the package:</p> <pre><code>npm i @wasm-tool/wasm-pack-plugin -D\n</code></pre> <p>And add the wasm-pack-plugin into the webpack.config.js.</p> <pre><code>const WasmPackPlugin = require(\"@wasm-tool/wasm-pack-plugin\");\nmodule.exports = {\n  ...\n  plugins: [\n    new WasmPackPlugin({\n      crateDirectory: path.resolve(__dirname, \".\")\n    }),\n  ]\n  ...\n}\n</code></pre> <p>Also, because the wasm-pack-plugin generates the dynamic import module, you need to modify tsconfig.json file to set the module to be esnext.</p> <pre><code>{\n  \"compilerOptions\": {\n    ...\n    \"module\": \"esnext\",\n    ...\n  }\n}\n</code></pre> <p>Finally, the npm scripts: npm start and npm run build will build the TypeScript code as well the Rust code.</p> <p>Let's write some Rust code.</p>"},{"location":"architecture-ideas/rust-app/#webassembly-and-apprun","title":"WebAssembly and AppRun","text":"<p>We will demonstrate two interactions between the WebAssembly and the AppRun application.</p> <ul> <li>Call the WebAssembly from the AppRun application</li> <li>Call the AppRun application from the WebAssembly</li> </ul>"},{"location":"architecture-ideas/rust-app/#call-webassembly","title":"Call WebAssembly","text":"<p>First, we create a Rust function in the wasm/src/lib.rs file.</p> <pre><code>use wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\npub fn add(a: i32, b: i32) -&gt; i32 {\n  a + b\n}\n</code></pre> <p>This function adds two numbers. We can make a counter application from it. Here is the counter application in AppRun.</p> <pre><code>import app from 'apprun';\n\nlet wasm;\nimport('../wasm/pkg').then(module =&gt; wasm = module);\n\nconst state = {\n  title: 'Hello world - AppRun !',\n  count: 0\n}\n\nconst add = (state, num) =&gt; ({\n  ...state,\n  count: wasm.add(state.count, num)\n});\n\nconst view = ({ title, count }) =&gt; &lt;&gt;\n  &lt;h1&gt;{title}&lt;/h1&gt;\n  &lt;h1&gt;{count}&lt;/h1&gt;\n  &lt;button $onclick={[add, -1]}&gt;-1&lt;/button&gt;\n  &lt;button $onclick={[add, +1]}&gt;+1&lt;/button&gt;\n&lt;/&gt;;\n\napp.start(document.body, state, view);\n</code></pre> <p>You can see from the code above:</p> <ul> <li>Wasm-pack has created a JavaScript module that we can import dynamically.</li> <li>We can call the WebAssembly function just like a regular JavaScript function from a module.</li> </ul> <p>Running the application, we have a counter that uses the WebAssembly function.</p> <p></p> Counter with WASM <p>Next, let's see how does the WebAssembly function call AppRun functions.</p>"},{"location":"architecture-ideas/rust-app/#call-the-apprun","title":"Call the AppRun","text":"<p>Open wasm/src/lib.rs file and add the following functions.</p> <pre><code>#[wasm_bindgen]\nextern \"C\" {\n  #[wasm_bindgen(js_namespace = app)]\n  fn run(event: &amp;str, p: &amp;str);\n}\n\n#[wasm_bindgen(start)]\npub fn start() {\n  run(\"@hello\", \"hello world from rust\");\n}\n</code></pre> <ul> <li>The first function named run binds to the AppRun app.run function.</li> <li>The second function named start runs automatically when the WebAssembly is loaded.</li> <li>The start function calls the run function to send a '@hello' event to AppRun.</li> </ul> <p>Back to AppRun code, we will handle the '@hello' event.</p> <pre><code>import app from 'apprun';\n\nlet wasm;\nimport('../wasm/pkg').then(module =&gt; wasm = module);\n\nconst state = {...}\n\nconst add = (state, num) =&gt; ({...});\n\nconst view = ({ title, count }) =&gt; &lt;&gt;...&lt;/&gt;;\n\nconst update = {\n  '@hello': (state, title) =&gt; ({...state, title})\n}\n\napp.start(document.body, state, view, update);\n</code></pre> <p>Now, when the application starts, it displays the messages sent from the WebAssembly.</p> <p></p> Message from wasm <p>We have successfully made two-way interactions between the WebAssembly and the AppRun application.</p>"},{"location":"architecture-ideas/rust-app/#souce-code","title":"Souce Code","text":"<p>You can run the live demo: https://yysun.github.io/apprun-rust.</p> <p>Or visit the source.</p> <p>{% github yysun/apprun-rust %}</p> <p>You also can use this project as an AppRun application template. Run the command to create your application.</p> <pre><code>npx degit yysun/apprun-rust my-app\n</code></pre>"},{"location":"architecture-ideas/rust-app/#conclusion","title":"Conclusion","text":"<p>This post should give you a quick start to use Rust/WebAssembly in the AppRun applications. The demo project shows the two technologies interact with each other very well. You can use the demo project as a template.</p> <p>We have now opened the door to a new world. There is much more potential to explore.</p>"},{"location":"architecture-ideas/state-machine/","title":"Use State Machine in AppRun Applications","text":""},{"location":"architecture-ideas/state-machine/#introduction","title":"Introduction","text":"<p>The state machine is the tool that developers must have in their toolbox.</p> <p>If you are new to the state machine, check out the reference section below.</p> <p>How can a state machine help?</p> <p>Typically, when building applications, we follow what's known as the event-driven \u2014 where an event happens in the application, we update the application state and render the state to the screen.</p> <p>Events can happen anytime during user interactions and system interactions, while the application can be in any state. Therefore, before we start to handle the events, we first have to determine the current state and then handle the event accordingly. Sometimes it can be challenging.</p> <p>The state machine provides a state-event-state mapping. Thus, before we start to handle the events, we know the current state and the future state, so that we only need to focus on the limited state-event scope.</p> <p>The specific state machine we are going to use is the Mealy machine. It has an initial state and then transitions to new states based on events and its current state.</p> <p>We are going to build a calculator application as an example. You will learn from this post:</p> <ul> <li>Model a state machine declaratively,</li> <li>Make the state machine type-safe</li> <li>Add the state machine to the AppRun application</li> </ul>"},{"location":"architecture-ideas/state-machine/#model-a-calculator","title":"Model a Calculator","text":""},{"location":"architecture-ideas/state-machine/#state-and-event","title":"State and Event","text":"<p>The calculator application looks like this:</p> <p><pre><code>const find_transition = (state_machine, state, event) =&gt; {\n  const current_state = state_machine[state];\n  if (!current_state) throw new Error(`No state: ${current_state} found in state machine`);\n  const event_tuple = current_state.find(s =&gt; s[0] === event);\n  return event_tuple ? {\n    next_state: event_tuple[1],\n    transition: event_tuple[2]\n  } : {}\n};\n\nconst state = {\n  _state: 'START',\n  display: '0',\n  arg1: 0,\n  arg2: 0,\n  op: '',\n  stack: []\n};\n\nconst view = ({ _state, op, arg1, arg2, display, stack }) =&gt; &lt;&gt;\n  &lt;style&gt; {`\n    .calculator { width: 200px; }\n    .buttons {\n      display: grid;\n      grid-template-columns: repeat(4, 1fr);\n      grid-gap: 2px;\n    }\n    button { padding: 10px; width:100%; }\n    button:nth-of-type(1) {\n      grid-column: span 2;\n    }\n    button:nth-of-type(16) {\n      grid-column: span 2;\n    }\n  `}\n  &lt;/style&gt;\n  &lt;div class=\"calculator\"&gt;\n    &lt;h1&gt;{display}&lt;/h1&gt;\n    &lt;div class=\"buttons\" $onclick={button_click}&gt;\n      &lt;button&gt;CE&lt;/button&gt;\n      &lt;button&gt;+/-&lt;/button&gt;\n      &lt;button&gt;/&lt;/button&gt;\n      &lt;button&gt;7&lt;/button&gt;\n      &lt;button&gt;8&lt;/button&gt;\n      &lt;button&gt;9&lt;/button&gt;\n      &lt;button&gt;*&lt;/button&gt;\n      &lt;button&gt;4&lt;/button&gt;\n      &lt;button&gt;5&lt;/button&gt;\n      &lt;button&gt;6&lt;/button&gt;\n      &lt;button&gt;-&lt;/button&gt;\n      &lt;button&gt;1&lt;/button&gt;\n      &lt;button&gt;2&lt;/button&gt;\n      &lt;button&gt;3&lt;/button&gt;\n      &lt;button&gt;+&lt;/button&gt;\n      &lt;button&gt;0&lt;/button&gt;\n      &lt;button&gt;.&lt;/button&gt;\n      &lt;button&gt;=&lt;/button&gt;\n    &lt;/div&gt;\n    &lt;small&gt;\n      {stack.length &gt; 0 &amp;&amp; `${stack[0][0]} ${stack[0][1]} `}\n      {_state.startsWith(\"FIRST_\") &amp;&amp; `${display}`}\n      {_state === \"OP\" &amp;&amp; `${arg1} ${op}`}\n      {_state.startsWith(\"SECOND_\") &amp;&amp; `${arg1} ${op} ${display}`}\n      {_state === \"EQ\" &amp;&amp; `${arg1} ${op} ${arg2} = ${display}`}\n    &lt;/small&gt;\n  &lt;/div&gt;\n&lt;/&gt;;\n\nconst button_click = (state, e) =&gt; {\n\n  const priority = {\n    '*': 2,\n    '/': 2,\n    '+': 1,\n    '-': 1\n  }\n\n  const getEvent = c =&gt; {\n    switch (c) {\n      case '+/-':\n        return '+/-';\n      case 'CE':\n        return 'CE';\n      case '.':\n        return 'DOT';\n      case '=':\n        return 'EQ';\n      default:\n        return /\\d/.test(c) ? 'NUM' : 'OP';\n    }\n  };\n\n  const key = e.target?.textContent || e;\n  const event = getEvent(key);\n\n  let { _state, op, arg1, arg2, display, stack } = state;\n\n  const clear = () =&gt; {\n    display = '0';\n    arg1 = arg2 = 0;\n    op = '';\n    stack.length = 0;\n  }\n\n  const negative = () =&gt; {\n    display = display.startsWith('-') ? display.substring(1) : '-' + display;\n  };\n\n  const calc = () =&gt; {\n    display = eval(`${arg1}${op}${arg2}`).toString();\n  };\n\n  const op1 = () =&gt; {\n    op = key;\n    arg1 = parseFloat(display);\n  };\n\n  const op2 = () =&gt; {\n    if (priority[key] === priority[op]) {\n      arg2 = parseFloat(display);\n      calc();\n      op = key;\n      arg1 = parseFloat(display);\n    } else if (priority[key] &lt; priority[op]) {\n      arg2 = parseFloat(display);\n      calc();\n      arg1 = parseFloat(display);\n      op = key;\n      if (stack.length) {\n        const f = stack.pop();\n        arg1 = eval(`${f[0]}${f[1]}${display}`);\n        display = arg1.toString();\n      }\n    } else {\n      stack.push([arg1, op]);\n      arg1 = parseFloat(display);\n      op = key;\n    }\n\n  };\n\n  const eq0 = () =&gt; {\n    arg1 = parseFloat(display);\n    calc();\n  };\n\n  const eq2 = () =&gt; {\n    arg2 = parseFloat(display);\n    calc();\n    if (stack.length) {\n      arg2 = parseFloat(display);\n      const f = stack.pop();\n      display = eval(`${f[0]}${f[1]}${display}`).toString();\n      arg1 = f[0];\n      op = f[1];\n    }\n  };\n\n  const state_machine = {\n    START: [\n      ['NUM', 'FIRST_ARG', () =&gt; display = key],\n      ['DOT', 'FIRST_ARG_FLOAT', () =&gt; display = '0.']\n    ],\n\n    FIRST_ARG: [\n      ['+/-', 'FIRST_ARG', negative],\n      ['NUM', 'FIRST_ARG', () =&gt; display += key],\n      ['DOT', 'FIRST_ARG_FLOAT', () =&gt; display += key],\n      ['OP', 'OP', op1],\n      ['CE', 'START', clear]\n    ],\n\n    FIRST_ARG_FLOAT: [\n      ['+/-', 'FIRST_ARG_FLOAT', negative],\n      ['NUM', 'FIRST_ARG_FLOAT', () =&gt; display += key],\n      ['OP', 'OP', op1],\n      ['CE', 'START', clear]\n    ],\n\n    OP: [\n      ['NUM', 'SECOND_ARG', () =&gt; display = key],\n      ['DOT', 'SECOND_ARG', () =&gt; display = '0.'],\n      ['OP', 'OP', () =&gt; op = key],\n      ['CE', 'START', clear]\n    ],\n\n    SECOND_ARG: [\n      ['+/-', 'SECOND_ARG', negative],\n      ['NUM', 'SECOND_ARG', () =&gt; display += key],\n      ['DOT', 'SECOND_ARG_FLOAT', () =&gt; display += key],\n      ['EQ', 'EQ', eq2],\n      ['OP', 'OP', op2],\n      ['CE', 'OP', () =&gt; display = '0']\n    ],\n\n    SECOND_ARG_FLOAT: [\n      ['+/-', 'SECOND_ARG_FLOAT', negative],\n      ['NUM', 'SECOND_ARG_FLOAT', () =&gt; display += key],\n      ['EQ', 'EQ', eq2],\n      ['OP', 'OP', op2],\n      ['CE', 'OP', () =&gt; display = '0']\n    ],\n\n    EQ: [\n      ['+/-', 'FIRST_ARG', negative],\n      ['NUM', 'FIRST_ARG', () =&gt; display = key],\n      ['DOT', 'FIRST_ARG_FLOAT', () =&gt; display = '0.'],\n      ['EQ', 'EQ', eq0],\n      ['OP', 'OP', op1],\n      ['CE', 'START', clear]\n    ]\n  };\n\n  const { next_state, transition } = find_transition(state_machine, _state, event);\n  _state = next_state || _state;\n  transition &amp;&amp; transition();\n\n  return { _state, op, arg1, arg2, display, stack };\n}\napp.start(document.body, state, view);\n</code></pre> </p> <p>Click the 'Try the Code' button; you will see the source code.</p> <p>The calculator has a grid of buttons that users can click at any time. It also displays:</p> <ul> <li>The numbers that the user typed and the calculation result on top of the grid.</li> <li>The calculation formula includes the first argument, the operator, and the second argument, and the calculation result below the gird.</li> </ul> <p>Let's model the initial state of the calculator.</p> <pre><code>const state = {\n  display: '0',\n  arg1: 0,\n  arg2: 0,\n  op: '',\n};\n</code></pre> <p>We handle the buttons' click events in the event handler, button___click. Because of the HTML event bubbling, we only need one event handler for all the buttons.</p> <pre><code>const view =\n  &lt;div class=\"buttons\" $onclick={button_click}&gt;\n  ......\n  &lt;/div&gt;\n\nconst button_click = (state, e) =&gt; {\n}\n\napp.start(document.body, state, view);\n</code></pre> <p>That's all we need to do to create an AppRun application, an initial state, a view, and event handlers.</p> <p>Next, we will add the state machine implementation.</p>"},{"location":"architecture-ideas/state-machine/#state-machine","title":"State Machine","text":"<p>We follow and extend the calculator state machine from David's post. The post also provides a diagram helpful to understand the state machine.</p> <p>We first define the states and events of the state machine using TypeScript Discriminated Unions.</p> <pre><code>type Events = 'NUM' | 'OP' | 'DOT' | 'CE' | 'EQ' | '+/-';\n\ntype States =\n  'START' |\n  'FIRST_ARG' |\n  'FIRST_ARG_FLOAT' |\n  'OP' |\n  'SECOND_ARG' |\n  'SECOND_ARG_FLOAT' |\n  'EQ';\n</code></pre> <p>We then define the state machine. It is a collection of all the states. Each state has a list of available events and transitions in an array. The transition is the function to update the state.</p> <pre><code>const state_machine = {\n  START: [\n    ['NUM', 'FIRST_ARG', () =&gt; display = key],\n    ['DOT', 'FIRST_ARG_FLOAT', () =&gt; display = '0.']\n  ],\n  FIRST_ARG: [\n    ['+/-', 'FIRST_ARG', negative],\n    ['NUM', 'FIRST_ARG', () =&gt; display += key],\n    ['DOT', 'FIRST_ARG_FLOAT', () =&gt; display += key],\n    ['OP', 'OP', op1],\n    ['CE', 'START', clear]\n  ],\n   ...\n}\n</code></pre> <p>For example, when the current state is START, and the NUM event comes, the new state should be 'FIRST_ARG (waiting for 1st argument)'. The display property of the state should be the user's input.</p> <p>Another example, when the current state is FIRST_ARG, and the +/- event comes, the display property should toggle between positive and negative.</p> <p>So on and so forth. It is straightforward to create the state machine object according to the diagram.</p> <p>Next, we make the state machine type-safe by adding more types.</p> <pre><code>export type Transition = () =&gt; void;\nexport type EventStateTransition&lt;E, S&gt; = [E, S, Transition];\nexport type StateMachine&lt;S extends string, E&gt; = {\n  [key in S]: EventStateTransition&lt;E, S&gt;[];\n};\n</code></pre> <ul> <li>The Tansition is a function to update the application state.</li> <li>The EventStateTransition is a TypeScript Tuple. It describes which event leads to which new state.</li> <li>The StateMachine is an object that uses the _States as the index key.</li> </ul> <p>Now, the state machine is type-safe. The TypeScript compiler only allows you to use the states and events defined in States and Events.</p> <pre><code>const state_machine: StateMachine&lt;States, Events&gt; = {\n  START0: [ // Error on START0\n    ['NUM0', 'FIRST_ARG', () =&gt; {}], // Error on NUM0\n    ['DOT', 'FIRST_ARG_FLOAT0', () =&gt; {}] // Error on FIRST_ARG_FLOAT0\n  ],\n}\n</code></pre> <p>Also, the compiler makes sure all States have their relevant entries in the state machine.</p> <p><pre><code>const state_machine: StateMachine&lt;States, Events&gt; = {\n  START: [],\n  FIRST_ARG: [],\n  FIRST_ARG_FLOAT: [],\n  OP:[], SECOND_ARG:[],\n  SECOND_ARG_FLOAT:[],\n  //EQ:[] // Error on missing EQ state, if we commented it out\n}\n</code></pre> You can see the state machine is just a simple data structure.</p>"},{"location":"architecture-ideas/state-machine/#add-state-machine-state","title":"Add State-Machine State","text":"<p>We add a new property for tracking the state-machine state, called _state, into the initial state.</p> <pre><code>const state = {\n  _state: 'START' as States,\n  display: '0',\n  arg1: 0,\n  arg2: 0,\n  op: '',\n};\nexport type State = typeof state;\n</code></pre>"},{"location":"architecture-ideas/state-machine/#convert-ui-events","title":"Convert UI Events","text":"<p>All button clicks use the button___click event handler. We convert UI events into different state-machine events.</p> <pre><code>export const button_click = (state: State, e: any) =&gt; {\n\n  const getEvent = (c: string): Events =&gt; {\n    switch (c) {\n      case '+/-':\n        return '+/-';\n      case 'CE':\n        return 'CE';\n      case '.':\n        return 'DOT';\n      case '=':\n        return 'EQ';\n      default:\n        return /\\d/.test(c) ? 'NUM' : 'OP';\n    }\n  };\n\n  const key = e.target?.textContent || e;\n  const event = getEvent(key);\n\n\n}\n</code></pre>"},{"location":"architecture-ideas/state-machine/#use-state-machine","title":"Use State Machine","text":"<p>Now that we know the current state-machine state from the _state property of the application state. We also know which state-machine event we are in. We now can use the state___machine to find the matching transition.</p> <p>Finding transitions from the state___machine is straightforward.</p> <pre><code>const find_transition = &lt;S extends string, E&gt;(\n  state_machine: StateMachine&lt;S, E&gt;,\n  state: S,\n  event: E\n): { next_state?: S, transition?: Transition } =&gt; {\n  const current_state = state_machine[state];\n  if (!current_state) throw new Error(`No state: ${current_state} found in state machine`);\n  const event_tuple = current_state.find(s =&gt; s[0] === event);\n  return event_tuple ? {\n    next_state: event_tuple[1],\n    transition: event_tuple[2]\n  } : {}\n};\n</code></pre> <p>If we found the transition, we run the transition function. It updates the destructed application state properties, such as op, arg1, arg2, and display accordingly. We then update the application state to be the next state.</p> <pre><code>const button_click = (state, e) =&gt; {\n  let { _state, op, arg1, arg2, display } = state;\n  const event = getEvent(s);\n  const state_machine = {\n  };\n\n  const { next_state, transition } = find_transition(state_machine, _state, event);\n  transition &amp;&amp; transition();\n  _state = next_state || _state;\n\n  return { _state, op, arg1, arg2, display };\n}\n</code></pre> <p>If no transition found, nothing will happen.</p> <p>Finally, we return a new state from the event handler; AppRun will render the screen accordingly.</p> <p>Now, we have successfully created the calculator application. You can see the calculator in TypeScript below.</p> <p>Source</p> state machine <pre><code>export type Transition&lt;T = any&gt; = (state?: T) =&gt; void;\nexport type EventStateTransition&lt;E, S&gt; = [E, S, Transition];\nexport type StateMachine&lt;S extends string, E&gt; = {\n  [key in S]: EventStateTransition&lt;E, S&gt;[];\n};\n\nexport const find_transition = &lt;S extends string, E&gt;(\n  state_machine: StateMachine&lt;S, E&gt;,\n  state: S,\n  event: E\n): { next_state?: S, transition?: Transition } =&gt; {\n  const current_state = state_machine[state];\n  if (!current_state) throw new Error(`No state: ${current_state} found in state machine`);\n  const event_tuple = current_state.find(s =&gt; s[0] === event);\n  return event_tuple ? {\n    next_state: event_tuple[1],\n    transition: event_tuple[2]\n  } : {}\n};\n</code></pre> calculator app <pre><code>import app, { Component } from '../../src/apprun';\nimport { StateMachine, find_transition } from './state-machine';\n\ntype Events = 'NUM' | 'OP' | 'DOT' | 'CE' | 'EQ' | '+/-';\n\ntype States = 'START' | 'FIRST_ARG' | 'FIRST_ARG_FLOAT' | 'OP' | 'SECOND_ARG' | 'SECOND_ARG_FLOAT' | 'EQ';\n\nconst state = {\n  _state: 'START' as States,\n  display: '0',\n  arg1: 0,\n  arg2: 0,\n  op: '',\n  stack: []\n};\nexport type State = typeof state;\n\nconst view = ({ _state, op, arg1, arg2, display, stack }: State) =&gt; &lt;&gt;\n  &lt;style&gt; {`\n    .calculator { width: 200px; }\n    .buttons {\n      display: grid;\n      grid-template-columns: repeat(4, 1fr);\n      grid-gap: 2px;\n    }\n    button { padding: 10px; width:100%; }\n    button:nth-of-type(1) {\n      grid-column: span 2;\n    }\n    button:nth-of-type(16) {\n      grid-column: span 2;\n    }\n  `}\n  &lt;/style&gt;\n  &lt;div class=\"calculator\"&gt;\n    &lt;h1&gt;{display}&lt;/h1&gt;\n    &lt;div class=\"buttons\" $onclick={button_click}&gt;\n      &lt;button&gt;CE&lt;/button&gt;\n      &lt;button&gt;+/-&lt;/button&gt;\n      &lt;button&gt;/&lt;/button&gt;\n      &lt;button&gt;7&lt;/button&gt;\n      &lt;button&gt;8&lt;/button&gt;\n      &lt;button&gt;9&lt;/button&gt;\n      &lt;button&gt;*&lt;/button&gt;\n      &lt;button&gt;4&lt;/button&gt;\n      &lt;button&gt;5&lt;/button&gt;\n      &lt;button&gt;6&lt;/button&gt;\n      &lt;button&gt;-&lt;/button&gt;\n      &lt;button&gt;1&lt;/button&gt;\n      &lt;button&gt;2&lt;/button&gt;\n      &lt;button&gt;3&lt;/button&gt;\n      &lt;button&gt;+&lt;/button&gt;\n      &lt;button&gt;0&lt;/button&gt;\n      &lt;button&gt;.&lt;/button&gt;\n      &lt;button&gt;=&lt;/button&gt;\n    &lt;/div&gt;\n    &lt;small&gt;\n      {stack.length &gt; 0 &amp;&amp; `${stack[0][0]} ${stack[0][1]} `}\n      {_state.startsWith(\"FIRST_\") &amp;&amp; `${display}`}\n      {_state === \"OP\" &amp;&amp; `${arg1} ${op}`}\n      {_state.startsWith(\"SECOND_\") &amp;&amp; `${arg1} ${op} ${display}`}\n      {_state === \"EQ\" &amp;&amp; `${arg1} ${op} ${arg2} = ${display}`}\n    &lt;/small&gt;\n  &lt;/div&gt;\n&lt;/&gt;;\n\nexport const button_click = (state: State, e: any) =&gt; {\n\n  const priority = {\n    '*': 2,\n    '/': 2,\n    '+': 1,\n    '-': 1\n  }\n\n  const getEvent = (c: string): Events =&gt; {\n    switch (c) {\n      case '+/-':\n        return '+/-';\n      case 'CE':\n        return 'CE';\n      case '.':\n        return 'DOT';\n      case '=':\n        return 'EQ';\n      default:\n        return /\\d/.test(c) ? 'NUM' : 'OP';\n    }\n  };\n\n  const key = e.target?.textContent || e;\n  const event = getEvent(key);\n\n  let { _state, op, arg1, arg2, display, stack } = state;\n\n  const clear = () =&gt; {\n    display = '0';\n    arg1 = arg2 = 0;\n    op = '';\n    stack.length = 0;\n  }\n\n  const negative = () =&gt; {\n    display = display.startsWith('-') ? display.substring(1) : '-' + display;\n  };\n\n  const calc = () =&gt; {\n    display = eval(`${arg1}${op}${arg2}`).toString();\n  };\n\n  const op1 = () =&gt; {\n    op = key;\n    arg1 = parseFloat(display);\n  };\n\n  const op2 = () =&gt; {\n    if (priority[key] === priority[op]) {\n      arg2 = parseFloat(display);\n      calc();\n      op = key;\n      arg1 = parseFloat(display);\n    } else if (priority[key] &lt; priority[op]) {\n      arg2 = parseFloat(display);\n      calc();\n      arg1 = parseFloat(display);\n      op = key;\n      if (stack.length) {\n        const f = stack.pop();\n        arg1 = eval(`${f[0]}${f[1]}${display}`);\n        display = arg1.toString();\n      }\n    } else {\n      stack.push([arg1, op]);\n      arg1 = parseFloat(display);\n      op = key;\n    }\n\n  };\n\n  const eq0 = () =&gt; {\n    arg1 = parseFloat(display);\n    calc();\n  };\n\n  const eq2 = () =&gt; {\n    arg2 = parseFloat(display);\n    calc();\n    if (stack.length) {\n      arg2 = parseFloat(display);\n      const f = stack.pop();\n      display = eval(`${f[0]}${f[1]}${display}`).toString();\n      arg1 = f[0];\n      op = f[1];\n    }\n  };\n\n  const state_machine: StateMachine&lt;States, Events&gt; = {\n    START: [\n      ['NUM', 'FIRST_ARG', () =&gt; display = key],\n      ['DOT', 'FIRST_ARG_FLOAT', () =&gt; display = '0.']\n    ],\n\n    FIRST_ARG: [\n      ['+/-', 'FIRST_ARG', negative],\n      ['NUM', 'FIRST_ARG', () =&gt; display += key],\n      ['DOT', 'FIRST_ARG_FLOAT', () =&gt; display += key],\n      ['OP', 'OP', op1],\n      ['CE', 'START', clear]\n    ],\n\n    FIRST_ARG_FLOAT: [\n      ['+/-', 'FIRST_ARG_FLOAT', negative],\n      ['NUM', 'FIRST_ARG_FLOAT', () =&gt; display += key],\n      ['OP', 'OP', op1],\n      ['CE', 'START', clear]\n    ],\n\n    OP: [\n      ['NUM', 'SECOND_ARG', () =&gt; display = key],\n      ['DOT', 'SECOND_ARG', () =&gt; display = '0.'],\n      ['OP', 'OP', () =&gt; op = key],\n      ['CE', 'START', clear]\n    ],\n\n    SECOND_ARG: [\n      ['+/-', 'SECOND_ARG', negative],\n      ['NUM', 'SECOND_ARG', () =&gt; display += key],\n      ['DOT', 'SECOND_ARG_FLOAT', () =&gt; display += key],\n      ['EQ', 'EQ', eq2],\n      ['OP', 'OP', op2],\n      ['CE', 'OP', () =&gt; display = '0']\n    ],\n\n    SECOND_ARG_FLOAT: [\n      ['+/-', 'SECOND_ARG_FLOAT', negative],\n      ['NUM', 'SECOND_ARG_FLOAT', () =&gt; display += key],\n      ['EQ', 'EQ', eq2],\n      ['OP', 'OP', op2],\n      ['CE', 'OP', () =&gt; display = '0']\n    ],\n\n    EQ: [\n      ['+/-', 'FIRST_ARG', negative],\n      ['NUM', 'FIRST_ARG', () =&gt; display = key],\n      ['DOT', 'FIRST_ARG_FLOAT', () =&gt; display = '0.'],\n      ['EQ', 'EQ', eq0],\n      ['OP', 'OP', op1],\n      ['CE', 'START', clear]\n    ]\n  };\n\n  const { next_state, transition } = find_transition(state_machine, _state, event);\n  _state = next_state || _state;\n  transition &amp;&amp; transition();\n\n  return { _state, op, arg1, arg2, display, stack };\n};\n\nconst update = {\n  '#calculator': state =&gt; state\n};\n\nexport default element =&gt; new Component(state, view, update).mount(element);\n</code></pre> calculator specs <pre><code>import { button_click, State } from './calculator';\n\nconst state: State = {\n  _state: 'START',\n  display: '0',\n  arg1: 0,\n  arg2: 0,\n  op: '',\n  stack: []\n};\n\nconst click = (input: string) =&gt; {\n  const keys = [...input];\n  let s = state;\n  keys.forEach(key =&gt; {\n    const new_state = button_click(s, key);\n    s = new_state\n  })\n  return s;\n}\n\ndescribe('calculator', () =&gt; {\n\n  it('case 1', () =&gt; {\n    const { _state, display } = click('1');\n    expect(display).toBe('1');\n    expect(_state).toBe('FIRST_ARG');\n  })\n\n  it('case 2', () =&gt; {\n    const { _state, display } = click('12');\n    expect(display).toBe('12');\n    expect(_state).toBe('FIRST_ARG');\n  })\n\n  it('case 3', () =&gt; {\n    const { _state, display, arg1, arg2 } = click('1+2=');\n    expect(display).toBe('3');\n    expect(arg1).toBe(1);\n    expect(arg2).toBe(2);\n    expect(_state).toBe('EQ');\n  })\n\n  it('case 4', () =&gt; {\n    const { _state, display } = click('1/');\n    expect(display).toBe('1');\n    expect(_state).toBe('OP');\n  })\n\n  it('case 5', () =&gt; {\n    const { _state, display } = click('1/2');\n    expect(display).toBe('2');\n    expect(_state).toBe('SECOND_ARG');\n  })\n\n  it('case 6', () =&gt; {\n    const { _state, display, op } = click('1//');\n    expect(display).toBe('1');\n    expect(op).toBe('/');\n    expect(_state).toBe('OP');\n  })\n\n  it('case 7', () =&gt; {\n    const { _state, display, op } = click('1/=');\n    expect(display).toBe('1');\n    expect(op).toBe('/');\n    expect(_state).toBe('OP');\n  })\n\n  it('case 8', () =&gt; {\n    const { _state, display, op } = click('1/+');\n    expect(display).toBe('1');\n    expect(op).toBe('+');\n    expect(_state).toBe('OP');\n  })\n\n  it('case 9', () =&gt; {\n    const { _state, display } = click('1/10');\n    expect(display).toBe('10');\n    expect(_state).toBe('SECOND_ARG');\n  })\n\n  it('case 10', () =&gt; {\n    const { _state, display } = click('1+1.');\n    expect(display).toBe('1.');\n    expect(_state).toBe('SECOND_ARG_FLOAT');\n  })\n\n  it('case 11', () =&gt; {\n    const { _state, display } = click('0.');\n    expect(display).toBe('0.');\n    expect(_state).toBe('FIRST_ARG_FLOAT');\n  })\n\n  it('case 12', () =&gt; {\n    const { _state, display } = click('=');\n    expect(display).toBe('0');\n    expect(_state).toBe('START');\n  })\n\n  it('case 13', () =&gt; {\n    const { _state, display } = click('/');\n    expect(display).toBe('0');\n    expect(_state).toBe('START');\n  })\n\n  it('case 14', () =&gt; {\n    const { _state, display } = click('1+2=5');\n    expect(display).toBe('5');\n    expect(_state).toBe('FIRST_ARG');\n  })\n\n  it('case 15', () =&gt; {\n    const { _state, display } = click('1+2=/');\n    expect(display).toBe('3');\n    expect(_state).toBe('OP');\n  })\n\n  it('case 16', () =&gt; {\n    const { _state, display } = click('1/+=');\n    expect(display).toBe('1');\n    expect(_state).toBe('OP');\n  })\n\n  it('case 17', () =&gt; {\n    const { _state, display } = click('1+2=*3=');\n    expect(display).toBe('9');\n    expect(_state).toBe('EQ');\n  })\n\n  it('case 18', () =&gt; {\n    const { _state, display, arg1, arg2 } = click('1+2*3=');\n    expect(display).toBe('7');\n    expect(arg1).toBe(1);\n    expect(arg2).toBe(6);\n    expect(_state).toBe('EQ');\n  })\n\n  it('case 19', () =&gt; {\n    const { _state, display, arg1, arg2 } = click('1*2+3=');\n    expect(display).toBe('5');\n    expect(arg1).toBe(2);\n    expect(arg2).toBe(3);\n    expect(_state).toBe('EQ');\n  })\n\n  it('case 20', () =&gt; {\n    const { _state, display } = click('1+2*3*');\n    expect(display).toBe('6');\n    expect(_state).toBe('OP');\n  })\n\n});\n</code></pre>"},{"location":"architecture-ideas/state-machine/#conclusion","title":"Conclusion","text":"<p>We have created a declarative and type-safe state machine. The state machine data structure is technology agnostic. You can try to use it in React or other frameworks you like. It can naturally fit into AppRun applications.</p> <p>AppRun is event-driven. Often I feel it is challenging to make events right. Sometimes we define too many events. Sometimes the events come out of order. By using the state machine, I can handle the events within limited state scopes. I have started to think of using more state machines to control the events.</p>"},{"location":"architecture-ideas/state-machine/#references","title":"References","text":"<p>There are many references online about the state machine. I got most of my inspiration from the following posts. I recommend you read the concept explanation of the posts and pay less attention to the implementations because using AppRun; you can do better.</p> <ul> <li> <p>[1] Krasimir Tsonev explains Mealy and Moore in the post: The Rise Of The State Machines</p> </li> <li> <p>[2] Jon Bellah describes the paradigm shift from event-driven to the state machine in this post: A Complete Introduction to State Machines in JavaScript</p> </li> <li> <p>[3] Erik Mogensen explains state machine and introduced the statechart in this post: What is a state machine?</p> </li> </ul> <p>Have fun coding!</p>"}]}